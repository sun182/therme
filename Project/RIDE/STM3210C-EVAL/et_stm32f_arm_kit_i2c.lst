
D:\sunny\stm32\therme\Project\RIDE\STM3210C-EVAL\et_stm32f_arm_kit_i2c.o:     file format elf32-littlearm
D:\sunny\stm32\therme\Project\RIDE\STM3210C-EVAL\et_stm32f_arm_kit_i2c.o


Disassembly of section .text.GPIO_Configurationi2c:

00000000 <GPIO_Configurationi2c>:
GPIO_Configurationi2c():
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:60
  * @brief  Configure the used I/O ports pin
  * @param  None
  * @retval None
  */
void GPIO_Configurationi2c(void)
{
   0:	b507      	push	{r0, r1, r2, lr}
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:64
  GPIO_InitTypeDef  GPIO_InitStructure; 
  
  /* Enable the I2C1 Pins Software Remapping */
  GPIO_PinRemapConfig(GPIO_Remap_I2C1, ENABLE);
   2:	2002      	movs	r0, #2
   4:	2101      	movs	r1, #1
   6:	f7ff fffe 	bl	0 <GPIO_PinRemapConfig>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:67

  /* Configure I2C_EE pins: SCL and SDA */
  GPIO_InitStructure.GPIO_Pin =  I2C_EE_SCL | I2C_EE_SDA; 
   a:	f44f 7340 	mov.w	r3, #768	; 0x300
   e:	f8ad 3004 	strh.w	r3, [sp, #4]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:68
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  12:	2303      	movs	r3, #3
  14:	f88d 3006 	strb.w	r3, [sp, #6]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:70
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
  GPIO_Init(I2C_EE_GPIO, &GPIO_InitStructure);
  18:	4803      	ldr	r0, [pc, #12]	; (28 <GPIO_Configurationi2c+0x28>)
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:69
  GPIO_PinRemapConfig(GPIO_Remap_I2C1, ENABLE);

  /* Configure I2C_EE pins: SCL and SDA */
  GPIO_InitStructure.GPIO_Pin =  I2C_EE_SCL | I2C_EE_SDA; 
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
  1a:	3319      	adds	r3, #25
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:70
  GPIO_Init(I2C_EE_GPIO, &GPIO_InitStructure);
  1c:	a901      	add	r1, sp, #4
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:69
  GPIO_PinRemapConfig(GPIO_Remap_I2C1, ENABLE);

  /* Configure I2C_EE pins: SCL and SDA */
  GPIO_InitStructure.GPIO_Pin =  I2C_EE_SCL | I2C_EE_SDA; 
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
  1e:	f88d 3007 	strb.w	r3, [sp, #7]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:70
  GPIO_Init(I2C_EE_GPIO, &GPIO_InitStructure);
  22:	f7ff fffe 	bl	0 <GPIO_Init>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:71
}
  26:	bd0e      	pop	{r1, r2, r3, pc}
  28:	40010c00 	.word	0x40010c00

Disassembly of section .text.I2C_Configuration:

00000000 <I2C_Configuration>:
I2C_Configuration():
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:79
  * @brief  I2C Configuration
  * @param  None
  * @retval None
  */
void I2C_Configuration(void)
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:83
  I2C_InitTypeDef  I2C_InitStructure; 
  
  /* I2C configuration */
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
   2:	2300      	movs	r3, #0
   4:	f8ad 3004 	strh.w	r3, [sp, #4]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:85
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
   8:	f8ad 3008 	strh.w	r3, [sp, #8]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:84
{
  I2C_InitTypeDef  I2C_InitStructure; 
  
  /* I2C configuration */
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
   c:	f64b 72ff 	movw	r2, #49151	; 0xbfff
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:86
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  10:	f44f 6380 	mov.w	r3, #1024	; 0x400
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:84
{
  I2C_InitTypeDef  I2C_InitStructure; 
  
  /* I2C configuration */
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  14:	f8ad 2006 	strh.w	r2, [sp, #6]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:86
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  18:	f8ad 300a 	strh.w	r3, [sp, #10]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:87
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  1c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:88
  I2C_InitStructure.I2C_ClockSpeed = I2C_EE_Speed;
  20:	f24c 3350 	movw	r3, #50000	; 0xc350
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:91
  
  /* I2C Peripheral Enable */
  I2C_Cmd(I2C_EE, ENABLE);
  24:	2101      	movs	r1, #1
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:88
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = I2C_EE_Speed;
  26:	ac04      	add	r4, sp, #16
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:91
  
  /* I2C Peripheral Enable */
  I2C_Cmd(I2C_EE, ENABLE);
  28:	4805      	ldr	r0, [pc, #20]	; (40 <I2C_Configuration+0x40>)
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:87
  /* I2C configuration */
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  2a:	f8ad 200c 	strh.w	r2, [sp, #12]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:88
  I2C_InitStructure.I2C_ClockSpeed = I2C_EE_Speed;
  2e:	f844 3d10 	str.w	r3, [r4, #-16]!
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:91
  
  /* I2C Peripheral Enable */
  I2C_Cmd(I2C_EE, ENABLE);
  32:	f7ff fffe 	bl	0 <I2C_Cmd>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:93
  /* Apply I2C configuration after enabling it */
  I2C_Init(I2C_EE, &I2C_InitStructure);
  36:	4802      	ldr	r0, [pc, #8]	; (40 <I2C_Configuration+0x40>)
  38:	4669      	mov	r1, sp
  3a:	f7ff fffe 	bl	0 <I2C_Init>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:94
}
  3e:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
  40:	40005400 	.word	0x40005400

Disassembly of section .text.I2C_EE_Init:

00000000 <I2C_EE_Init>:
I2C_EE_Init():
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:102
  * @brief  Initializes peripherals used by the I2C EEPROM driver.
  * @param  None
  * @retval None
  */
void I2C_EE_Init()
{
   0:	f44fb508 	.word	0xf44fb508
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:104
  /* I2C Periph clock enable */
  RCC_APB1PeriphClockCmd(I2C_EE_CLK, ENABLE);   
   4:	1000      	asrs	r0, r0, #32
   6:	2101      	movs	r1, #1
   8:	f7ff fffe 	bl	0 <RCC_APB1PeriphClockCmd>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:107
  
  /* GPIO Periph clock enable */
  RCC_APB2PeriphClockCmd(I2C_EE_GPIO_CLK, ENABLE);    
   c:	2008      	movs	r0, #8
   e:	2101      	movs	r1, #1
  10:	f7ff fffe 	bl	0 <RCC_APB2PeriphClockCmd>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:110
  
  /* GPIO configuration */
  GPIO_Configurationi2c();
  14:	f7ff fffe 	bl	0 <I2C_EE_Init>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:113

  /* I2C configuration */
  I2C_Configuration();
  18:	f7ff fffe 	bl	0 <I2C_EE_Init>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:115

    EEPROM_ADDRESS = EEPROM_Block0_ADDRESS;
  1c:	4b03      	ldr	r3, [pc, #12]	; (2c <I2C_EE_Init+0x2c>)
  1e:	22a0      	movs	r2, #160	; 0xa0
  20:	801a      	strh	r2, [r3, #0]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:118
  
  TWI_SLA_ds1307 = address_ds1307HW;
  TWI_SLA_ds1307 = 0xd0;
  22:	4b03      	ldr	r3, [pc, #12]	; (30 <I2C_EE_Init+0x30>)
  24:	22d0      	movs	r2, #208	; 0xd0
  26:	801a      	strh	r2, [r3, #0]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:119
}
  28:	bd08      	pop	{r3, pc}
  2a:	bf00      	nop
	...

Disassembly of section .text.I2C_EE_BufferRead:

00000000 <I2C_EE_BufferRead>:
I2C_EE_BufferRead():
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:183
  * @param  ReadAddr : EEPROM's internal address to read from.
  * @param  NumByteToRead : number of bytes to read from the EEPROM.
  * @retval None
  */
void I2C_EE_BufferRead(char* pBuffer, uint16_t ReadAddr, uint16_t NumByteToRead)
{  
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4605      	mov	r5, r0
   6:	460f      	mov	r7, r1
   8:	4614      	mov	r4, r2
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:186
	
    /* While the bus is busy */
 while(I2C_GetFlagStatus(I2C_EE, I2C_FLAG_BUSY));
   a:	482e      	ldr	r0, [pc, #184]	; (c4 <I2C_EE_BufferRead+0xc4>)
   c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  10:	f7ff fffe 	bl	0 <I2C_GetFlagStatus>
  14:	2800      	cmp	r0, #0
  16:	d1f8      	bne.n	a <I2C_EE_BufferRead+0xa>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:189

  /* Send START condition */
  I2C_GenerateSTART(I2C_EE, ENABLE);
  18:	482a      	ldr	r0, [pc, #168]	; (c4 <I2C_EE_BufferRead+0xc4>)
  1a:	2101      	movs	r1, #1
  1c:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:192
  
  /* Test on EV5 and clear it */
  while(!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_MODE_SELECT));
  20:	4828      	ldr	r0, [pc, #160]	; (c4 <I2C_EE_BufferRead+0xc4>)
  22:	4929      	ldr	r1, [pc, #164]	; (c8 <I2C_EE_BufferRead+0xc8>)
  24:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  28:	2800      	cmp	r0, #0
  2a:	d0f9      	beq.n	20 <I2C_EE_BufferRead+0x20>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:195
 
  /* Send EEPROM address for write */
  I2C_Send7bitAddress(I2C_EE, EEPROM_ADDRESS, I2C_Direction_Transmitter);
  2c:	4e27      	ldr	r6, [pc, #156]	; (cc <I2C_EE_BufferRead+0xcc>)
  2e:	4825      	ldr	r0, [pc, #148]	; (c4 <I2C_EE_BufferRead+0xc4>)
  30:	7831      	ldrb	r1, [r6, #0]
  32:	2200      	movs	r2, #0
  34:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:198

  /* Test on EV6 and clear it */
  while(!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
  38:	4822      	ldr	r0, [pc, #136]	; (c4 <I2C_EE_BufferRead+0xc4>)
  3a:	4925      	ldr	r1, [pc, #148]	; (d0 <I2C_EE_BufferRead+0xd0>)
  3c:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  40:	2800      	cmp	r0, #0
  42:	d0f9      	beq.n	38 <I2C_EE_BufferRead+0x38>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:202

  
  /* Send the EEPROM's internal address to read from: Only one byte address */
  I2C_SendData(I2C_EE, ReadAddr);  
  44:	481f      	ldr	r0, [pc, #124]	; (c4 <I2C_EE_BufferRead+0xc4>)
  46:	b2f9      	uxtb	r1, r7
  48:	f7ff fffe 	bl	0 <I2C_SendData>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:205

  /* Test on EV8 and clear it */
  while(!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  4c:	481d      	ldr	r0, [pc, #116]	; (c4 <I2C_EE_BufferRead+0xc4>)
  4e:	4921      	ldr	r1, [pc, #132]	; (d4 <I2C_EE_BufferRead+0xd4>)
  50:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  54:	2800      	cmp	r0, #0
  56:	d0f9      	beq.n	4c <I2C_EE_BufferRead+0x4c>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:208

  /* Send STRAT condition a second time */  
  I2C_GenerateSTART(I2C_EE, ENABLE);
  58:	481a      	ldr	r0, [pc, #104]	; (c4 <I2C_EE_BufferRead+0xc4>)
  5a:	2101      	movs	r1, #1
  5c:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:211
  
  /* Test on EV5 and clear it */
  while(!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_MODE_SELECT));
  60:	4818      	ldr	r0, [pc, #96]	; (c4 <I2C_EE_BufferRead+0xc4>)
  62:	4919      	ldr	r1, [pc, #100]	; (c8 <I2C_EE_BufferRead+0xc8>)
  64:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  68:	2800      	cmp	r0, #0
  6a:	d0f9      	beq.n	60 <I2C_EE_BufferRead+0x60>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:214
  
  /* Send EEPROM address for read */
  I2C_Send7bitAddress(I2C_EE, EEPROM_ADDRESS, I2C_Direction_Receiver);
  6c:	4815      	ldr	r0, [pc, #84]	; (c4 <I2C_EE_BufferRead+0xc4>)
  6e:	7831      	ldrb	r1, [r6, #0]
  70:	2201      	movs	r2, #1
  72:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:217
  
  /* Test on EV6 and clear it */
  while(!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
  76:	4813      	ldr	r0, [pc, #76]	; (c4 <I2C_EE_BufferRead+0xc4>)
  78:	4917      	ldr	r1, [pc, #92]	; (d8 <I2C_EE_BufferRead+0xd8>)
  7a:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  7e:	2800      	cmp	r0, #0
  80:	d0f9      	beq.n	76 <I2C_EE_BufferRead+0x76>
  82:	e016      	b.n	b2 <I2C_EE_BufferRead+0xb2>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:222

  /* While there is data to be read */
  while(NumByteToRead)  
  {
    if(NumByteToRead == 1)
  84:	2c01      	cmp	r4, #1
  86:	d107      	bne.n	98 <I2C_EE_BufferRead+0x98>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:225
    {
      /* Disable Acknowledgement */
      I2C_AcknowledgeConfig(I2C_EE, DISABLE);
  88:	480e      	ldr	r0, [pc, #56]	; (c4 <I2C_EE_BufferRead+0xc4>)
  8a:	2100      	movs	r1, #0
  8c:	f7ff fffe 	bl	0 <I2C_AcknowledgeConfig>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:228
      
      /* Send STOP Condition */
      I2C_GenerateSTOP(I2C_EE, ENABLE);
  90:	480c      	ldr	r0, [pc, #48]	; (c4 <I2C_EE_BufferRead+0xc4>)
  92:	4621      	mov	r1, r4
  94:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:232
    }

    /* Test on EV7 and clear it */
    if(I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_BYTE_RECEIVED))  
  98:	480a      	ldr	r0, [pc, #40]	; (c4 <I2C_EE_BufferRead+0xc4>)
  9a:	4910      	ldr	r1, [pc, #64]	; (dc <I2C_EE_BufferRead+0xdc>)
  9c:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  a0:	2800      	cmp	r0, #0
  a2:	d0ef      	beq.n	84 <I2C_EE_BufferRead+0x84>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:235
    {      
      /* Read a byte from the EEPROM */
      *pBuffer = I2C_ReceiveData(I2C_EE);
  a4:	4807      	ldr	r0, [pc, #28]	; (c4 <I2C_EE_BufferRead+0xc4>)
  a6:	f7ff fffe 	bl	0 <I2C_ReceiveData>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:241

      /* Point to the next location where the byte read will be saved */
      pBuffer++; 
      
      /* Decrement the read bytes counter */
      NumByteToRead--; 
  aa:	3c01      	subs	r4, #1
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:235

    /* Test on EV7 and clear it */
    if(I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_BYTE_RECEIVED))  
    {      
      /* Read a byte from the EEPROM */
      *pBuffer = I2C_ReceiveData(I2C_EE);
  ac:	f805 0b01 	strb.w	r0, [r5], #1
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:241

      /* Point to the next location where the byte read will be saved */
      pBuffer++; 
      
      /* Decrement the read bytes counter */
      NumByteToRead--; 
  b0:	b2a4      	uxth	r4, r4
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:220
  
  /* Test on EV6 and clear it */
  while(!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));

  /* While there is data to be read */
  while(NumByteToRead)  
  b2:	2c00      	cmp	r4, #0
  b4:	d1e6      	bne.n	84 <I2C_EE_BufferRead+0x84>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:246
      NumByteToRead--; 
    }   
  }

  /* Enable Acknowledgement to be ready for another reception */
  I2C_AcknowledgeConfig(I2C_EE, ENABLE);
  b6:	4803      	ldr	r0, [pc, #12]	; (c4 <I2C_EE_BufferRead+0xc4>)
  b8:	2101      	movs	r1, #1
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:248
 
}
  ba:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:246
      NumByteToRead--; 
    }   
  }

  /* Enable Acknowledgement to be ready for another reception */
  I2C_AcknowledgeConfig(I2C_EE, ENABLE);
  be:	f7ff bffe 	b.w	0 <I2C_AcknowledgeConfig>
  c2:	bf00      	nop
  c4:	40005400 	.word	0x40005400
  c8:	00030001 	.word	0x00030001
  cc:	00000000 	.word	0x00000000
  d0:	00070082 	.word	0x00070082
  d4:	00070084 	.word	0x00070084
  d8:	00030002 	.word	0x00030002
  dc:	00030040 	.word	0x00030040

Disassembly of section .text.I2C_EE_PageWrite:

00000000 <I2C_EE_PageWrite>:
I2C_EE_PageWrite():
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:360
  * @param  WriteAddr : EEPROM's internal address to write to.
  * @param  NumByteToWrite : number of bytes to write to the EEPROM.
  * @retval None
  */
void I2C_EE_PageWrite(uint8_t* pBuffer, uint16_t WriteAddr, uint8_t NumByteToWrite)
{ 
   0:	4605b570 	.word	0x4605b570
   4:	460e      	mov	r6, r1
   6:	4614      	mov	r4, r2
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:362
  /* While the bus is busy */
  while(I2C_GetFlagStatus(I2C_EE, I2C_FLAG_BUSY));
   8:	481e      	ldr	r0, [pc, #120]	; (84 <I2C_EE_PageWrite+0x84>)
   a:	f44f 3100 	mov.w	r1, #131072	; 0x20000
   e:	f7ff fffe 	bl	0 <I2C_GetFlagStatus>
  12:	2800      	cmp	r0, #0
  14:	d1f8      	bne.n	8 <I2C_EE_PageWrite+0x8>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:365
  
  /* Send START condition */
  I2C_GenerateSTART(I2C_EE, ENABLE);
  16:	481b      	ldr	r0, [pc, #108]	; (84 <I2C_EE_PageWrite+0x84>)
  18:	2101      	movs	r1, #1
  1a:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:368
  
  /* Test on EV5 and clear it */
  while(!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_MODE_SELECT)); 
  1e:	4819      	ldr	r0, [pc, #100]	; (84 <I2C_EE_PageWrite+0x84>)
  20:	4919      	ldr	r1, [pc, #100]	; (88 <I2C_EE_PageWrite+0x88>)
  22:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  26:	2800      	cmp	r0, #0
  28:	d0f9      	beq.n	1e <I2C_EE_PageWrite+0x1e>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:371
  
  /* Send EEPROM address for write */
  I2C_Send7bitAddress(I2C_EE, EEPROM_ADDRESS, I2C_Direction_Transmitter);
  2a:	4b18      	ldr	r3, [pc, #96]	; (8c <I2C_EE_PageWrite+0x8c>)
  2c:	4815      	ldr	r0, [pc, #84]	; (84 <I2C_EE_PageWrite+0x84>)
  2e:	7819      	ldrb	r1, [r3, #0]
  30:	2200      	movs	r2, #0
  32:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:374

  /* Test on EV6 and clear it */
  while(!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));  
  36:	4813      	ldr	r0, [pc, #76]	; (84 <I2C_EE_PageWrite+0x84>)
  38:	4915      	ldr	r1, [pc, #84]	; (90 <I2C_EE_PageWrite+0x90>)
  3a:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  3e:	2800      	cmp	r0, #0
  40:	d0f9      	beq.n	36 <I2C_EE_PageWrite+0x36>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:379

#ifdef EE_M24C08
  
  /* Send the EEPROM's internal address to write to : only one byte Address */
  I2C_SendData(I2C_EE, WriteAddr);
  42:	4810      	ldr	r0, [pc, #64]	; (84 <I2C_EE_PageWrite+0x84>)
  44:	b2f1      	uxtb	r1, r6
  46:	f7ff fffe 	bl	0 <I2C_SendData>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:395
  I2C_SendData(I2C_EE, (uint8_t)(WriteAddr & 0x00FF));
  
#endif /* EE_M24C08 */  

  /* Test on EV8 and clear it */
  while(! I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  4a:	480e      	ldr	r0, [pc, #56]	; (84 <I2C_EE_PageWrite+0x84>)
  4c:	4911      	ldr	r1, [pc, #68]	; (94 <I2C_EE_PageWrite+0x94>)
  4e:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  52:	2800      	cmp	r0, #0
  54:	d0f9      	beq.n	4a <I2C_EE_PageWrite+0x4a>
  56:	e00c      	b.n	72 <I2C_EE_PageWrite+0x72>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:401

  /* While there is data to be written */
  while(NumByteToWrite--)  
  {
    /* Send the current byte */
    I2C_SendData(I2C_EE, *pBuffer); 
  58:	480a      	ldr	r0, [pc, #40]	; (84 <I2C_EE_PageWrite+0x84>)
  5a:	f815 1b01 	ldrb.w	r1, [r5], #1
  5e:	f7ff fffe 	bl	0 <I2C_SendData>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:407

    /* Point to the next byte to be written */
    pBuffer++; 
  
    /* Test on EV8 and clear it */
    while (!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  62:	4808      	ldr	r0, [pc, #32]	; (84 <I2C_EE_PageWrite+0x84>)
  64:	490b      	ldr	r1, [pc, #44]	; (94 <I2C_EE_PageWrite+0x94>)
  66:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  6a:	2800      	cmp	r0, #0
  6c:	d0f9      	beq.n	62 <I2C_EE_PageWrite+0x62>
  6e:	3c01      	subs	r4, #1
  70:	b2e4      	uxtb	r4, r4
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:398

  /* Test on EV8 and clear it */
  while(! I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_BYTE_TRANSMITTED));

  /* While there is data to be written */
  while(NumByteToWrite--)  
  72:	2c00      	cmp	r4, #0
  74:	d1f0      	bne.n	58 <I2C_EE_PageWrite+0x58>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:411
    /* Test on EV8 and clear it */
    while (!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  }

  /* Send STOP condition */
  I2C_GenerateSTOP(I2C_EE, ENABLE);
  76:	4803      	ldr	r0, [pc, #12]	; (84 <I2C_EE_PageWrite+0x84>)
  78:	2101      	movs	r1, #1
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:412
}
  7a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:411
    /* Test on EV8 and clear it */
    while (!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  }

  /* Send STOP condition */
  I2C_GenerateSTOP(I2C_EE, ENABLE);
  7e:	f7ff bffe 	b.w	0 <I2C_GenerateSTOP>
  82:	bf00      	nop
  84:	40005400 	.word	0x40005400
  88:	00030001 	.word	0x00030001
  8c:	00000000 	.word	0x00000000
  90:	00070082 	.word	0x00070082
  94:	00070084 	.word	0x00070084

Disassembly of section .text.I2C_EE_WaitEepromStandbyState:

00000000 <I2C_EE_WaitEepromStandbyState>:
I2C_EE_WaitEepromStandbyState():
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:420
  * @brief  Wait for EEPROM Standby state
  * @param  None
  * @retval None
  */
void I2C_EE_WaitEepromStandbyState(void)      
{
   0:	2300b507 	.word	0x2300b507
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:421
  __IO uint16_t SR1_Tmp = 0;
   4:	f8ad 3006 	strh.w	r3, [sp, #6]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:426

  do
  {
    /* Send START condition */
    I2C_GenerateSTART(I2C_EE, ENABLE);
   8:	2101      	movs	r1, #1
   a:	4810      	ldr	r0, [pc, #64]	; (4c <I2C_EE_WaitEepromStandbyState+0x4c>)
   c:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:429

    /* Read I2C_EE SR1 register to clear pending flags */
    SR1_Tmp = I2C_ReadRegister(I2C_EE, I2C_Register_SR1);
  10:	2114      	movs	r1, #20
  12:	480e      	ldr	r0, [pc, #56]	; (4c <I2C_EE_WaitEepromStandbyState+0x4c>)
  14:	f7ff fffe 	bl	0 <I2C_ReadRegister>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:432

    /* Send EEPROM address for write */
    I2C_Send7bitAddress(I2C_EE, EEPROM_ADDRESS, I2C_Direction_Transmitter);
  18:	4b0d      	ldr	r3, [pc, #52]	; (50 <I2C_EE_WaitEepromStandbyState+0x50>)
  1a:	2200      	movs	r2, #0
  1c:	7819      	ldrb	r1, [r3, #0]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:429
  {
    /* Send START condition */
    I2C_GenerateSTART(I2C_EE, ENABLE);

    /* Read I2C_EE SR1 register to clear pending flags */
    SR1_Tmp = I2C_ReadRegister(I2C_EE, I2C_Register_SR1);
  1e:	f8ad 0006 	strh.w	r0, [sp, #6]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:432

    /* Send EEPROM address for write */
    I2C_Send7bitAddress(I2C_EE, EEPROM_ADDRESS, I2C_Direction_Transmitter);
  22:	480a      	ldr	r0, [pc, #40]	; (2c <I2C_Send7bitAddress+0x2c>)
  24:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:434

  }while(!(I2C_ReadRegister(I2C_EE, I2C_Register_SR1) & 0x0002));
  28:	2114      	movs	r1, #20
  2a:	4808      	ldr	r0, [pc, #32]	; (4c <I2C_EE_WaitEepromStandbyState+0x4c>)
  2c:	f7ff fffe 	bl	0 <I2C_ReadRegister>
  30:	f010 0f02 	tst.w	r0, #2
  34:	d0e8      	beq.n	8 <I2C_EE_WaitEepromStandbyState+0x8>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:437
  
  /* Clear AF flag */
  I2C_ClearFlag(I2C_EE, I2C_FLAG_AF);
  36:	4805      	ldr	r0, [pc, #20]	; (4c <I2C_EE_WaitEepromStandbyState+0x4c>)
  38:	4906      	ldr	r1, [pc, #24]	; (54 <I2C_EE_WaitEepromStandbyState+0x54>)
  3a:	f7ff fffe 	bl	0 <I2C_ClearFlag>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:440
  
  /* STOP condition */    
  I2C_GenerateSTOP(I2C_EE, ENABLE);  
  3e:	4803      	ldr	r0, [pc, #12]	; (4c <I2C_EE_WaitEepromStandbyState+0x4c>)
  40:	2101      	movs	r1, #1
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:441
}
  42:	b003      	add	sp, #12
  44:	f85d eb04 	ldr.w	lr, [sp], #4
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:440
  
  /* Clear AF flag */
  I2C_ClearFlag(I2C_EE, I2C_FLAG_AF);
  
  /* STOP condition */    
  I2C_GenerateSTOP(I2C_EE, ENABLE);  
  48:	f7ff bffe 	b.w	0 <I2C_GenerateSTOP>
  4c:	40005400 	.word	0x40005400
  50:	00000000 	.word	0x00000000
  54:	10000400 	.word	0x10000400

Disassembly of section .text.I2C_EE_BufferWrite:

00000000 <I2C_EE_BufferWrite>:
I2C_EE_BufferWrite():
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:259
  * @param  WriteAddr : EEPROM's internal address to write to.
  * @param  NumByteToWrite : number of bytes to write to the EEPROM.
  * @retval None
  */
void I2C_EE_BufferWrite(char* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:265
  uint8_t NumOfPage = 0, NumOfSingle = 0, count = 0;
  uint16_t Addr = 0;
	
  Addr = WriteAddr % I2C_FLASH_PAGESIZE;
  count = I2C_FLASH_PAGESIZE - Addr;
  NumOfPage =  NumByteToWrite / I2C_FLASH_PAGESIZE;
   4:	0913      	lsrs	r3, r2, #4
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:266
  NumOfSingle = NumByteToWrite % I2C_FLASH_PAGESIZE;
   6:	fa5f f982 	uxtb.w	r9, r2
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:269
 
  /* If WriteAddr is I2C_FLASH_PAGESIZE aligned  */
  if(Addr == 0) 
   a:	f011 080f 	ands.w	r8, r1, #15
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:259
  * @param  WriteAddr : EEPROM's internal address to write to.
  * @param  NumByteToWrite : number of bytes to write to the EEPROM.
  * @retval None
  */
void I2C_EE_BufferWrite(char* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)
{
   e:	4605      	mov	r5, r0
  10:	460c      	mov	r4, r1
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:265
  uint8_t NumOfPage = 0, NumOfSingle = 0, count = 0;
  uint16_t Addr = 0;
	
  Addr = WriteAddr % I2C_FLASH_PAGESIZE;
  count = I2C_FLASH_PAGESIZE - Addr;
  NumOfPage =  NumByteToWrite / I2C_FLASH_PAGESIZE;
  12:	b2df      	uxtb	r7, r3
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:266
  NumOfSingle = NumByteToWrite % I2C_FLASH_PAGESIZE;
  14:	f009 060f 	and.w	r6, r9, #15
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:269
 
  /* If WriteAddr is I2C_FLASH_PAGESIZE aligned  */
  if(Addr == 0) 
  18:	d11f      	bne.n	5a <I2C_EE_BufferWrite+0x5a>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:272
  {
    /* If NumByteToWrite < I2C_FLASH_PAGESIZE */
    if(NumOfPage == 0) 
  1a:	2f00      	cmp	r7, #0
  1c:	d032      	beq.n	84 <I2C_EE_BufferWrite+0x84>
  1e:	46b9      	mov	r9, r7
  20:	4688      	mov	r8, r1
  22:	4682      	mov	sl, r0
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:285
      while(NumOfPage--)
      {
        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_FLASH_PAGESIZE); 
        I2C_EE_WaitEepromStandbyState();
        WriteAddr +=  I2C_FLASH_PAGESIZE;
        pBuffer += I2C_FLASH_PAGESIZE;
  24:	f109 39ff 	add.w	r9, r9, #4294967295
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:282
    /* If NumByteToWrite > I2C_FLASH_PAGESIZE */
    else  
    {
      while(NumOfPage--)
      {
        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_FLASH_PAGESIZE); 
  28:	4650      	mov	r0, sl
  2a:	4641      	mov	r1, r8
  2c:	2210      	movs	r2, #16
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:284
        I2C_EE_WaitEepromStandbyState();
        WriteAddr +=  I2C_FLASH_PAGESIZE;
  2e:	f108 0810 	add.w	r8, r8, #16
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:285
        pBuffer += I2C_FLASH_PAGESIZE;
  32:	fa5f f989 	uxtb.w	r9, r9
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:282
    /* If NumByteToWrite > I2C_FLASH_PAGESIZE */
    else  
    {
      while(NumOfPage--)
      {
        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_FLASH_PAGESIZE); 
  36:	f7ff fffe 	bl	0 <I2C_EE_BufferWrite>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:284
        I2C_EE_WaitEepromStandbyState();
        WriteAddr +=  I2C_FLASH_PAGESIZE;
  3a:	fa1f f888 	uxth.w	r8, r8
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:283
    else  
    {
      while(NumOfPage--)
      {
        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_FLASH_PAGESIZE); 
        I2C_EE_WaitEepromStandbyState();
  3e:	f7ff fffe 	bl	0 <I2C_EE_BufferWrite>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:285
        WriteAddr +=  I2C_FLASH_PAGESIZE;
        pBuffer += I2C_FLASH_PAGESIZE;
  42:	f10a 0a10 	add.w	sl, sl, #16
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:280
      I2C_EE_WaitEepromStandbyState();
    }
    /* If NumByteToWrite > I2C_FLASH_PAGESIZE */
    else  
    {
      while(NumOfPage--)
  46:	f1b9 0f00 	cmp.w	r9, #0
  4a:	d1eb      	bne.n	24 <I2C_EE_BufferWrite+0x24>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:258
  *   written to the EEPROM.
  * @param  WriteAddr : EEPROM's internal address to write to.
  * @param  NumByteToWrite : number of bytes to write to the EEPROM.
  * @retval None
  */
void I2C_EE_BufferWrite(char* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)
  4c:	013f      	lsls	r7, r7, #4
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:280
      I2C_EE_WaitEepromStandbyState();
    }
    /* If NumByteToWrite > I2C_FLASH_PAGESIZE */
    else  
    {
      while(NumOfPage--)
  4e:	19e8      	adds	r0, r5, r7
  50:	19e7      	adds	r7, r4, r7
  52:	b2b9      	uxth	r1, r7
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:288
        I2C_EE_WaitEepromStandbyState();
        WriteAddr +=  I2C_FLASH_PAGESIZE;
        pBuffer += I2C_FLASH_PAGESIZE;
      }

      if(NumOfSingle!=0)
  54:	2e00      	cmp	r6, #0
  56:	d04c      	beq.n	f2 <I2C_EE_BufferWrite+0xf2>
  58:	e014      	b.n	84 <I2C_EE_BufferWrite+0x84>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:264
{
  uint8_t NumOfPage = 0, NumOfSingle = 0, count = 0;
  uint16_t Addr = 0;
	
  Addr = WriteAddr % I2C_FLASH_PAGESIZE;
  count = I2C_FLASH_PAGESIZE - Addr;
  5a:	f1c8 0810 	rsb	r8, r8, #16
  5e:	fa5f f888 	uxtb.w	r8, r8
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:299
  }
  /* If WriteAddr is not I2C_FLASH_PAGESIZE aligned  */
  else 
  {
    /* If NumByteToWrite < I2C_FLASH_PAGESIZE */
    if(NumOfPage== 0) 
  62:	b98f      	cbnz	r7, 88 <I2C_EE_BufferWrite+0x88>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:303
    {
      /* If the number of data to be written is more than the remaining space 
      in the current page: */
      if (NumByteToWrite > count)
  64:	4542      	cmp	r2, r8
  66:	d90d      	bls.n	84 <I2C_EE_BufferWrite+0x84>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:306
      {
        /* Write the data conained in same page */
        I2C_EE_PageWrite(pBuffer, WriteAddr, count);
  68:	4642      	mov	r2, r8
  6a:	f7ff fffe 	bl	0 <I2C_EE_BufferWrite>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:307
        I2C_EE_WaitEepromStandbyState();      
  6e:	f7ff fffe 	bl	0 <I2C_EE_BufferWrite>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:310
        
        /* Write the remaining data in the following page */
        I2C_EE_PageWrite((uint8_t*)(pBuffer + count), (WriteAddr + count), (NumByteToWrite - count));
  72:	eb08 0104 	add.w	r1, r8, r4
  76:	ebc8 0209 	rsb	r2, r8, r9
  7a:	eb05 0008 	add.w	r0, r5, r8
  7e:	b289      	uxth	r1, r1
  80:	b2d2      	uxtb	r2, r2
  82:	e030      	b.n	e6 <I2C_EE_BufferWrite+0xe6>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:315
        I2C_EE_WaitEepromStandbyState();        
      }      
      else      
      {
        I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
  84:	4632      	mov	r2, r6
  86:	e02e      	b.n	e6 <I2C_EE_BufferWrite+0xe6>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:322
      }     
    }
    /* If NumByteToWrite > I2C_FLASH_PAGESIZE */
    else
    {
      NumByteToWrite -= count;
  88:	ebc8 0a02 	rsb	sl, r8, r2
  8c:	fa1f fa8a 	uxth.w	sl, sl
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:323
      NumOfPage =  NumByteToWrite / I2C_FLASH_PAGESIZE;
  90:	ea4f 191a 	mov.w	r9, sl, lsr #4
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:330
      
      if(count != 0)
      {  
        I2C_EE_PageWrite(pBuffer, WriteAddr, count);
        I2C_EE_WaitEepromStandbyState();
        WriteAddr += count;
  94:	4444      	add	r4, r8
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:328
      NumOfPage =  NumByteToWrite / I2C_FLASH_PAGESIZE;
      NumOfSingle = NumByteToWrite % I2C_FLASH_PAGESIZE;
      
      if(count != 0)
      {  
        I2C_EE_PageWrite(pBuffer, WriteAddr, count);
  96:	4642      	mov	r2, r8
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:323
    }
    /* If NumByteToWrite > I2C_FLASH_PAGESIZE */
    else
    {
      NumByteToWrite -= count;
      NumOfPage =  NumByteToWrite / I2C_FLASH_PAGESIZE;
  98:	fa5f f989 	uxtb.w	r9, r9
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:331
      if(count != 0)
      {  
        I2C_EE_PageWrite(pBuffer, WriteAddr, count);
        I2C_EE_WaitEepromStandbyState();
        WriteAddr += count;
        pBuffer += count;
  9c:	44a8      	add	r8, r5
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:330
      
      if(count != 0)
      {  
        I2C_EE_PageWrite(pBuffer, WriteAddr, count);
        I2C_EE_WaitEepromStandbyState();
        WriteAddr += count;
  9e:	b2a4      	uxth	r4, r4
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:328
      NumOfPage =  NumByteToWrite / I2C_FLASH_PAGESIZE;
      NumOfSingle = NumByteToWrite % I2C_FLASH_PAGESIZE;
      
      if(count != 0)
      {  
        I2C_EE_PageWrite(pBuffer, WriteAddr, count);
  a0:	f7ff fffe 	bl	0 <I2C_EE_BufferWrite>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:324
    /* If NumByteToWrite > I2C_FLASH_PAGESIZE */
    else
    {
      NumByteToWrite -= count;
      NumOfPage =  NumByteToWrite / I2C_FLASH_PAGESIZE;
      NumOfSingle = NumByteToWrite % I2C_FLASH_PAGESIZE;
  a4:	f00a 0a0f 	and.w	sl, sl, #15
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:329
      
      if(count != 0)
      {  
        I2C_EE_PageWrite(pBuffer, WriteAddr, count);
        I2C_EE_WaitEepromStandbyState();
  a8:	f7ff fffe 	bl	0 <I2C_EE_BufferWrite>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:331
        WriteAddr += count;
        pBuffer += count;
  ac:	464d      	mov	r5, r9
  ae:	4627      	mov	r7, r4
  b0:	4646      	mov	r6, r8
  b2:	e00b      	b.n	cc <I2C_EE_BufferWrite+0xcc>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:336
      } 
      
      while(NumOfPage--)
      {
        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_FLASH_PAGESIZE);
  b4:	4630      	mov	r0, r6
  b6:	4639      	mov	r1, r7
  b8:	2210      	movs	r2, #16
  ba:	f7ff fffe 	bl	0 <I2C_EE_BufferWrite>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:337
        I2C_EE_WaitEepromStandbyState();
  be:	f7ff fffe 	bl	0 <I2C_EE_BufferWrite>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:338
        WriteAddr +=  I2C_FLASH_PAGESIZE;
  c2:	3710      	adds	r7, #16
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:339
        pBuffer += I2C_FLASH_PAGESIZE;  
  c4:	3d01      	subs	r5, #1
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:338
      
      while(NumOfPage--)
      {
        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_FLASH_PAGESIZE);
        I2C_EE_WaitEepromStandbyState();
        WriteAddr +=  I2C_FLASH_PAGESIZE;
  c6:	b2bf      	uxth	r7, r7
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:339
        pBuffer += I2C_FLASH_PAGESIZE;  
  c8:	3610      	adds	r6, #16
  ca:	b2ed      	uxtb	r5, r5
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:334
        I2C_EE_WaitEepromStandbyState();
        WriteAddr += count;
        pBuffer += count;
      } 
      
      while(NumOfPage--)
  cc:	2d00      	cmp	r5, #0
  ce:	d1f1      	bne.n	b4 <I2C_EE_BufferWrite+0xb4>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:258
  *   written to the EEPROM.
  * @param  WriteAddr : EEPROM's internal address to write to.
  * @param  NumByteToWrite : number of bytes to write to the EEPROM.
  * @retval None
  */
void I2C_EE_BufferWrite(char* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)
  d0:	ea4f 1909 	mov.w	r9, r9, lsl #4
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:334
        I2C_EE_WaitEepromStandbyState();
        WriteAddr += count;
        pBuffer += count;
      } 
      
      while(NumOfPage--)
  d4:	eb08 0009 	add.w	r0, r8, r9
  d8:	44a1      	add	r9, r4
  da:	fa1f f189 	uxth.w	r1, r9
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:341
        I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_FLASH_PAGESIZE);
        I2C_EE_WaitEepromStandbyState();
        WriteAddr +=  I2C_FLASH_PAGESIZE;
        pBuffer += I2C_FLASH_PAGESIZE;  
      }
      if(NumOfSingle != 0)
  de:	f1ba 0f00 	cmp.w	sl, #0
  e2:	d006      	beq.n	f2 <I2C_EE_BufferWrite+0xf2>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:343
      {
        I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle); 
  e4:	4652      	mov	r2, sl
  e6:	f7ff fffe 	bl	0 <I2C_EE_BufferWrite>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:348
        I2C_EE_WaitEepromStandbyState();
      }
    }
  }  
}
  ea:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:344
        pBuffer += I2C_FLASH_PAGESIZE;  
      }
      if(NumOfSingle != 0)
      {
        I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle); 
        I2C_EE_WaitEepromStandbyState();
  ee:	f7ff bffe 	b.w	0 <I2C_EE_BufferWrite>
  f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

Disassembly of section .text.I2C_EE_ByteWrite:

00000000 <I2C_EE_ByteWrite>:
I2C_EE_ByteWrite():
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:129
  *   written to the EEPROM.
  * @param  WriteAddr : EEPROM's internal address to write to.
  * @retval None
  */
void I2C_EE_ByteWrite(char* pBuffer, uint16_t WriteAddr)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
   4:	460d      	mov	r5, r1
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:131
  /* Send STRAT condition */
  I2C_GenerateSTART(I2C_EE, ENABLE);
   6:	4819      	ldr	r0, [pc, #100]	; (6c <I2C_EE_ByteWrite+0x6c>)
   8:	2101      	movs	r1, #1
   a:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:134

  /* Test on EV5 and clear it */
  while(!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_MODE_SELECT));  
   e:	4817      	ldr	r0, [pc, #92]	; (6c <I2C_EE_ByteWrite+0x6c>)
  10:	4917      	ldr	r1, [pc, #92]	; (70 <I2C_EE_ByteWrite+0x70>)
  12:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  16:	2800      	cmp	r0, #0
  18:	d0f9      	beq.n	e <I2C_EE_ByteWrite+0xe>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:137

  /* Send EEPROM address for write */
  I2C_Send7bitAddress(I2C_EE, EEPROM_ADDRESS, I2C_Direction_Transmitter);
  1a:	4b16      	ldr	r3, [pc, #88]	; (74 <I2C_EE_ByteWrite+0x74>)
  1c:	4813      	ldr	r0, [pc, #76]	; (6c <I2C_EE_ByteWrite+0x6c>)
  1e:	7819      	ldrb	r1, [r3, #0]
  20:	2200      	movs	r2, #0
  22:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:140
  
  /* Test on EV6 and clear it */
  while(!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
  26:	4811      	ldr	r0, [pc, #68]	; (6c <I2C_EE_ByteWrite+0x6c>)
  28:	4913      	ldr	r1, [pc, #76]	; (78 <I2C_EE_ByteWrite+0x78>)
  2a:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  2e:	2800      	cmp	r0, #0
  30:	d0f9      	beq.n	26 <I2C_EE_ByteWrite+0x26>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:145

#ifdef EE_M24C08
  
  /* Send the EEPROM's internal address to write to : only one byte Address */
  I2C_SendData(I2C_EE, WriteAddr);
  32:	480e      	ldr	r0, [pc, #56]	; (6c <I2C_EE_ByteWrite+0x6c>)
  34:	b2e9      	uxtb	r1, r5
  36:	f7ff fffe 	bl	0 <I2C_SendData>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:161
  I2C_SendData(I2C_EE, (uint8_t)(WriteAddr & 0x00FF));
  
#endif /* EE_M24C08 */  
  
  /* Test on EV8 and clear it */
  while(!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  3a:	480c      	ldr	r0, [pc, #48]	; (6c <I2C_EE_ByteWrite+0x6c>)
  3c:	490f      	ldr	r1, [pc, #60]	; (7c <I2C_EE_ByteWrite+0x7c>)
  3e:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  42:	2800      	cmp	r0, #0
  44:	d0f9      	beq.n	3a <I2C_EE_ByteWrite+0x3a>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:164

  /* Send the byte to be written */
  I2C_SendData(I2C_EE, *pBuffer); 
  46:	4809      	ldr	r0, [pc, #36]	; (6c <I2C_EE_ByteWrite+0x6c>)
  48:	7821      	ldrb	r1, [r4, #0]
  4a:	f7ff fffe 	bl	0 <I2C_SendData>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:167
   
  /* Test on EV8 and clear it */
  while(!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  4e:	4807      	ldr	r0, [pc, #28]	; (6c <I2C_EE_ByteWrite+0x6c>)
  50:	490a      	ldr	r1, [pc, #40]	; (7c <I2C_EE_ByteWrite+0x7c>)
  52:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  56:	2800      	cmp	r0, #0
  58:	d0f9      	beq.n	4e <I2C_EE_ByteWrite+0x4e>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:170
  
  /* Send STOP condition */
  I2C_GenerateSTOP(I2C_EE, ENABLE);
  5a:	4804      	ldr	r0, [pc, #16]	; (6c <I2C_EE_ByteWrite+0x6c>)
  5c:	2101      	movs	r1, #1
  5e:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:172
   I2C_EE_WaitEepromStandbyState();
}
  62:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:171
  /* Test on EV8 and clear it */
  while(!I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  
  /* Send STOP condition */
  I2C_GenerateSTOP(I2C_EE, ENABLE);
   I2C_EE_WaitEepromStandbyState();
  66:	f7ff bffe 	b.w	0 <I2C_EE_ByteWrite>
  6a:	bf00      	nop
  6c:	40005400 	.word	0x40005400
  70:	00030001 	.word	0x00030001
  74:	00000000 	.word	0x00000000
  78:	00070082 	.word	0x00070082
  7c:	00070084 	.word	0x00070084

Disassembly of section .text.I2C_StandbyState:

00000000 <I2C_StandbyState>:
I2C_StandbyState():
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:443
  
  /* STOP condition */    
  I2C_GenerateSTOP(I2C_EE, ENABLE);  
}
void I2C_StandbyState(uint16_t add)      
{
   0:	2300b513 	.word	0x2300b513
   4:	4604      	mov	r4, r0
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:444
  __IO uint16_t SR1_Tmp = 0;
   6:	f8ad 3006 	strh.w	r3, [sp, #6]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:449

  do
  {
    /* Send START condition */
    I2C_GenerateSTART(I2C_EE, ENABLE);
   a:	2101      	movs	r1, #1
   c:	480f      	ldr	r0, [pc, #60]	; (4c <I2C_StandbyState+0x4c>)
   e:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:452

    /* Read I2C_EE SR1 register to clear pending flags */
    SR1_Tmp = I2C_ReadRegister(I2C_EE, I2C_Register_SR1);
  12:	2114      	movs	r1, #20
  14:	480d      	ldr	r0, [pc, #52]	; (4c <I2C_StandbyState+0x4c>)
  16:	f7ff fffe 	bl	0 <I2C_ReadRegister>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:455

    /* Send EEPROM address for write */
    I2C_Send7bitAddress(I2C_EE, add, I2C_Direction_Transmitter);
  1a:	2200      	movs	r2, #0
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:452
  {
    /* Send START condition */
    I2C_GenerateSTART(I2C_EE, ENABLE);

    /* Read I2C_EE SR1 register to clear pending flags */
    SR1_Tmp = I2C_ReadRegister(I2C_EE, I2C_Register_SR1);
  1c:	f8ad 0006 	strh.w	r0, [sp, #6]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:455

    /* Send EEPROM address for write */
    I2C_Send7bitAddress(I2C_EE, add, I2C_Direction_Transmitter);
  20:	b2e1      	uxtb	r1, r4
  22:	480a      	ldr	r0, [pc, #40]	; (4c <I2C_StandbyState+0x4c>)
  24:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:457

  }while(!(I2C_ReadRegister(I2C_EE, I2C_Register_SR1) & 0x0002));
  28:	2114      	movs	r1, #20
  2a:	4808      	ldr	r0, [pc, #32]	; (4c <I2C_StandbyState+0x4c>)
  2c:	f7ff fffe 	bl	0 <I2C_ReadRegister>
  30:	f010 0f02 	tst.w	r0, #2
  34:	d0e9      	beq.n	a <I2C_StandbyState+0xa>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:460
  
  /* Clear AF flag */
  I2C_ClearFlag(I2C_EE, I2C_FLAG_AF);
  36:	4805      	ldr	r0, [pc, #20]	; (4c <I2C_StandbyState+0x4c>)
  38:	4905      	ldr	r1, [pc, #20]	; (50 <I2C_StandbyState+0x50>)
  3a:	f7ff fffe 	bl	0 <I2C_ClearFlag>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:463
  
  /* STOP condition */    
  I2C_GenerateSTOP(I2C_EE, ENABLE);  
  3e:	4803      	ldr	r0, [pc, #12]	; (4c <I2C_StandbyState+0x4c>)
  40:	2101      	movs	r1, #1
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:464
}
  42:	b002      	add	sp, #8
  44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:463
  
  /* Clear AF flag */
  I2C_ClearFlag(I2C_EE, I2C_FLAG_AF);
  
  /* STOP condition */    
  I2C_GenerateSTOP(I2C_EE, ENABLE);  
  48:	f7ff bffe 	b.w	0 <I2C_GenerateSTOP>
  4c:	40005400 	.word	0x40005400
  50:	10000400 	.word	0x10000400

Disassembly of section .text.DS1307_Write:

00000000 <DS1307_Write>:
DS1307_Write():
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:469
}


/************************************************************** DS1307_Write */
void DS1307_Write(unsigned char ctl,unsigned char dat)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4606      	mov	r6, r0
   4:	460d      	mov	r5, r1
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:472

 /* Send STRAT condition */
  I2C_GenerateSTART(I2C_ds, ENABLE);
   6:	4819      	ldr	r0, [pc, #100]	; (6c <DS1307_Write+0x6c>)
   8:	2101      	movs	r1, #1
   a:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:475

  /* Test on EV5 and clear it */
  while(!I2C_CheckEvent(I2C_ds, I2C_EVENT_MASTER_MODE_SELECT));  
   e:	4817      	ldr	r0, [pc, #92]	; (6c <DS1307_Write+0x6c>)
  10:	4917      	ldr	r1, [pc, #92]	; (70 <DS1307_Write+0x70>)
  12:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  16:	2800      	cmp	r0, #0
  18:	d0f9      	beq.n	e <DS1307_Write+0xe>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:478

  /* Send EEPROM address for write */
  I2C_Send7bitAddress(I2C_ds, TWI_SLA_ds1307, I2C_Direction_Transmitter);
  1a:	4c16      	ldr	r4, [pc, #88]	; (74 <DS1307_Write+0x74>)
  1c:	4813      	ldr	r0, [pc, #76]	; (6c <DS1307_Write+0x6c>)
  1e:	7821      	ldrb	r1, [r4, #0]
  20:	2200      	movs	r2, #0
  22:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:481
  
  /* Test on EV6 and clear it */
  while(!I2C_CheckEvent(I2C_ds, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
  26:	4811      	ldr	r0, [pc, #68]	; (6c <DS1307_Write+0x6c>)
  28:	4913      	ldr	r1, [pc, #76]	; (78 <DS1307_Write+0x78>)
  2a:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  2e:	2800      	cmp	r0, #0
  30:	d0f9      	beq.n	26 <DS1307_Write+0x26>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:484

  /* Send the EEPROM's internal address to write to : only one byte Address */
	I2C_SendData(I2C_ds, ctl);
  32:	480e      	ldr	r0, [pc, #56]	; (6c <DS1307_Write+0x6c>)
  34:	4631      	mov	r1, r6
  36:	f7ff fffe 	bl	0 <I2C_SendData>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:485
   while (!I2C_CheckEvent(I2C_ds, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  3a:	480c      	ldr	r0, [pc, #48]	; (6c <DS1307_Write+0x6c>)
  3c:	490f      	ldr	r1, [pc, #60]	; (7c <DS1307_Write+0x7c>)
  3e:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  42:	2800      	cmp	r0, #0
  44:	d0f9      	beq.n	3a <DS1307_Write+0x3a>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:486
	 I2C_SendData(I2C_ds, dat);
  46:	4809      	ldr	r0, [pc, #36]	; (6c <DS1307_Write+0x6c>)
  48:	4629      	mov	r1, r5
  4a:	f7ff fffe 	bl	0 <I2C_SendData>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:487
	while (!I2C_CheckEvent(I2C_ds, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  4e:	4807      	ldr	r0, [pc, #28]	; (6c <DS1307_Write+0x6c>)
  50:	490a      	ldr	r1, [pc, #40]	; (7c <DS1307_Write+0x7c>)
  52:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  56:	2800      	cmp	r0, #0
  58:	d0f9      	beq.n	4e <DS1307_Write+0x4e>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:490
	 
      /* STOP condition */    
  I2C_GenerateSTOP(I2C_ds, ENABLE); 
  5a:	4804      	ldr	r0, [pc, #16]	; (6c <DS1307_Write+0x6c>)
  5c:	2101      	movs	r1, #1
  5e:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:492
    
   I2C_StandbyState(TWI_SLA_ds1307);
  62:	8820      	ldrh	r0, [r4, #0]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:495
    /* Send STOP condition */

}
  64:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:492
	while (!I2C_CheckEvent(I2C_ds, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
	 
      /* STOP condition */    
  I2C_GenerateSTOP(I2C_ds, ENABLE); 
    
   I2C_StandbyState(TWI_SLA_ds1307);
  68:	f7ff bffe 	b.w	0 <DS1307_Write>
  6c:	40005400 	.word	0x40005400
  70:	00030001 	.word	0x00030001
  74:	00000000 	.word	0x00000000
  78:	00070082 	.word	0x00070082
  7c:	00070084 	.word	0x00070084

Disassembly of section .text.DS1307_R:

00000000 <DS1307_R>:
DS1307_R():
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:498
    /* Send STOP condition */

}

unsigned char DS1307_R(unsigned char ctl)
{
   0:	b538      	push	{r3, r4, r5, lr}
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:504
	
    unsigned char dat;
	               // Read NACK Received
   // while(I2C_GetFlagStatus(I2C_EE, I2C_FLAG_BUSY));
 
   I2C_GenerateSTART(I2C_ds, ENABLE);
   2:	2101      	movs	r1, #1
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:498
    /* Send STOP condition */

}

unsigned char DS1307_R(unsigned char ctl)
{
   4:	4605      	mov	r5, r0
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:504
	
    unsigned char dat;
	               // Read NACK Received
   // while(I2C_GetFlagStatus(I2C_EE, I2C_FLAG_BUSY));
 
   I2C_GenerateSTART(I2C_ds, ENABLE);
   6:	4825      	ldr	r0, [pc, #148]	; (9c <DS1307_R+0x9c>)
   8:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:507

  /* Test on EV5 and clear it */
  while(!I2C_CheckEvent(I2C_ds, I2C_EVENT_MASTER_MODE_SELECT));  
   c:	4823      	ldr	r0, [pc, #140]	; (9c <DS1307_R+0x9c>)
   e:	4924      	ldr	r1, [pc, #144]	; (a0 <DS1307_R+0xa0>)
  10:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  14:	2800      	cmp	r0, #0
  16:	d0f9      	beq.n	c <DS1307_R+0xc>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:509
  /* Send EEPROM address for write */
   I2C_Send7bitAddress(I2C_ds, 0xd0, I2C_Direction_Transmitter);
  18:	4820      	ldr	r0, [pc, #128]	; (9c <DS1307_R+0x9c>)
  1a:	21d0      	movs	r1, #208	; 0xd0
  1c:	2200      	movs	r2, #0
  1e:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:512
  
   /* Test on EV6 and clear it */
   while(!I2C_CheckEvent(I2C_ds, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
  22:	481e      	ldr	r0, [pc, #120]	; (9c <DS1307_R+0x9c>)
  24:	491f      	ldr	r1, [pc, #124]	; (a4 <DS1307_R+0xa4>)
  26:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  2a:	2800      	cmp	r0, #0
  2c:	d0f9      	beq.n	22 <DS1307_R+0x22>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:514
  // /* Send the EEPROM's internal address to write to : only one byte Address */
   I2C_SendData(I2C_ds, ctl);
  2e:	481b      	ldr	r0, [pc, #108]	; (9c <DS1307_R+0x9c>)
  30:	4629      	mov	r1, r5
  32:	f7ff fffe 	bl	0 <I2C_SendData>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:515
  while (!I2C_CheckEvent(I2C_ds, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  36:	4819      	ldr	r0, [pc, #100]	; (9c <DS1307_R+0x9c>)
  38:	491b      	ldr	r1, [pc, #108]	; (a8 <DS1307_R+0xa8>)
  3a:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  3e:	2800      	cmp	r0, #0
  40:	d0f9      	beq.n	36 <DS1307_R+0x36>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:517
   // while (!I2C_CheckEvent(I2C_ds, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
   I2C_GenerateSTART(I2C_ds, ENABLE);
  42:	4816      	ldr	r0, [pc, #88]	; (9c <DS1307_R+0x9c>)
  44:	2101      	movs	r1, #1
  46:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:520
  
  // /* Test on EV5 and clear it */
   while(!I2C_CheckEvent(I2C_ds, I2C_EVENT_MASTER_MODE_SELECT));
  4a:	4814      	ldr	r0, [pc, #80]	; (9c <DS1307_R+0x9c>)
  4c:	4914      	ldr	r1, [pc, #80]	; (a0 <DS1307_R+0xa0>)
  4e:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  52:	2800      	cmp	r0, #0
  54:	d0f9      	beq.n	4a <DS1307_R+0x4a>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:522
  /* Send address for read */
  I2C_Send7bitAddress(I2C_ds,TWI_SLA_ds1307 , I2C_Direction_Receiver);
  56:	4b15      	ldr	r3, [pc, #84]	; (ac <DS1307_R+0xac>)
  58:	4810      	ldr	r0, [pc, #64]	; (9c <DS1307_R+0x9c>)
  5a:	7819      	ldrb	r1, [r3, #0]
  5c:	2201      	movs	r2, #1
  5e:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:525
  
  /* Test on EV6 and clear it */
  while(!I2C_CheckEvent(I2C_ds, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
  62:	480e      	ldr	r0, [pc, #56]	; (9c <DS1307_R+0x9c>)
  64:	4912      	ldr	r1, [pc, #72]	; (b0 <DS1307_R+0xb0>)
  66:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  6a:	2800      	cmp	r0, #0
  6c:	d0f9      	beq.n	62 <DS1307_R+0x62>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:530
   /* While there is data to be read */


    /* Test on EV7 and clear it */
    if(I2C_CheckEvent(I2C_EE, I2C_EVENT_MASTER_BYTE_RECEIVED))  
  6e:	480b      	ldr	r0, [pc, #44]	; (9c <DS1307_R+0x9c>)
  70:	4910      	ldr	r1, [pc, #64]	; (b4 <DS1307_R+0xb4>)
  72:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  76:	b118      	cbz	r0, 80 <DS1307_R+0x80>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:533
    {      
      /* Read a byte from the EEPROM */
      dat = I2C_ReceiveData(I2C_EE);
  78:	4808      	ldr	r0, [pc, #32]	; (9c <DS1307_R+0x9c>)
  7a:	f7ff fffe 	bl	0 <I2C_ReceiveData>
  7e:	4604      	mov	r4, r0
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:537

	}
	
        I2C_AcknowledgeConfig(I2C_EE, DISABLE);
  80:	2100      	movs	r1, #0
  82:	4806      	ldr	r0, [pc, #24]	; (9c <DS1307_R+0x9c>)
  84:	f7ff fffe 	bl	0 <I2C_AcknowledgeConfig>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:540
      
      /* Send STOP Condition */
      I2C_GenerateSTOP(I2C_EE, ENABLE);
  88:	2101      	movs	r1, #1
  8a:	4804      	ldr	r0, [pc, #16]	; (9c <DS1307_R+0x9c>)
  8c:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:542
  /* Enable Acknowledgement to be ready for another reception */
        I2C_AcknowledgeConfig(I2C_EE, ENABLE);
  90:	4802      	ldr	r0, [pc, #8]	; (9c <DS1307_R+0x9c>)
  92:	2101      	movs	r1, #1
  94:	f7ff fffe 	bl	0 <I2C_AcknowledgeConfig>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:547

  return dat;


}
  98:	4620      	mov	r0, r4
  9a:	bd38      	pop	{r3, r4, r5, pc}
  9c:	40005400 	.word	0x40005400
  a0:	00030001 	.word	0x00030001
  a4:	00070082 	.word	0x00070082
  a8:	00070084 	.word	0x00070084
  ac:	00000000 	.word	0x00000000
  b0:	00030002 	.word	0x00030002
  b4:	00030040 	.word	0x00030040

Disassembly of section .text.DS1307_Read:

00000000 <DS1307_Read>:
DS1307_Read():
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:550

void DS1307_Read(unsigned char *pBuffer)
{
   0:	4605b538 	.word	0x4605b538
   4:	2400      	movs	r4, #0
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:559
  for(dat=0;dat<=6;dat++)
  {
    //Delay1(10);
  	
      /* Read a byte from the EEPROM */
      *pBuffer = DS1307_R(dat);
   6:	b2e0      	uxtb	r0, r4
   8:	f7ff fffe 	bl	0 <DS1307_Read>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:560
  sprintf(uart_buf,"%u : %u\r\n",*pBuffer,dat);
   c:	4623      	mov	r3, r4
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:559
  for(dat=0;dat<=6;dat++)
  {
    //Delay1(10);
  	
      /* Read a byte from the EEPROM */
      *pBuffer = DS1307_R(dat);
   e:	4602      	mov	r2, r0
  10:	5528      	strb	r0, [r5, r4]
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:560
  sprintf(uart_buf,"%u : %u\r\n",*pBuffer,dat);
  12:	4905      	ldr	r1, [pc, #20]	; (28 <DS1307_Read+0x28>)
  14:	4805      	ldr	r0, [pc, #20]	; (2c <DS1307_Read+0x2c>)
  16:	f7ff fffe 	bl	0 <sprintf>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:561
  printUART2((unsigned int *)uart_buf);
  1a:	3401      	adds	r4, #1
  1c:	4803      	ldr	r0, [pc, #12]	; (2c <DS1307_Read+0x2c>)
  1e:	f7ff fffe 	bl	0 <printUART2>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:554
void DS1307_Read(unsigned char *pBuffer)
{
    unsigned char dat;
   /* While there is data to be read */

  for(dat=0;dat<=6;dat++)
  22:	2c07      	cmp	r4, #7
  24:	d1ef      	bne.n	6 <DS1307_Read+0x6>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:566
  printUART2((unsigned int *)uart_buf);
    pBuffer ++;

	}
  
}
  26:	bd38      	pop	{r3, r4, r5, pc}
	...

Disassembly of section .text.write_to_MCP:

00000000 <write_to_MCP>:
write_to_MCP():
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:569

void write_to_MCP(unsigned char address, unsigned char cmd,unsigned char data1, unsigned char data2)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4604      	mov	r4, r0
   6:	460e      	mov	r6, r1
   8:	4615      	mov	r5, r2
   a:	461f      	mov	r7, r3
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:570
	I2C_StandbyState(address);
   c:	f7ff fffe 	bl	0 <write_to_MCP>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:572

while(I2C_GetFlagStatus(I2C_EE, I2C_FLAG_BUSY));
  10:	4821      	ldr	r0, [pc, #132]	; (98 <write_to_MCP+0x98>)
  12:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  16:	f7ff fffe 	bl	0 <I2C_GetFlagStatus>
  1a:	2800      	cmp	r0, #0
  1c:	d1f8      	bne.n	10 <write_to_MCP+0x10>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:574

	I2C_GenerateSTART(I2C_mcp, ENABLE);
  1e:	481e      	ldr	r0, [pc, #120]	; (98 <write_to_MCP+0x98>)
  20:	2101      	movs	r1, #1
  22:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:576
  /* Test on EV5 and clear it */
  while(!I2C_CheckEvent(I2C_mcp, I2C_EVENT_MASTER_MODE_SELECT));  
  26:	481c      	ldr	r0, [pc, #112]	; (98 <write_to_MCP+0x98>)
  28:	491c      	ldr	r1, [pc, #112]	; (9c <write_to_MCP+0x9c>)
  2a:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  2e:	2800      	cmp	r0, #0
  30:	d0f9      	beq.n	26 <write_to_MCP+0x26>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:579
 	//Transmit the "ADDRESS and WRITE" byte

  I2C_Send7bitAddress(I2C_mcp,address, I2C_Direction_Transmitter);
  32:	4819      	ldr	r0, [pc, #100]	; (98 <write_to_MCP+0x98>)
  34:	4621      	mov	r1, r4
  36:	2200      	movs	r2, #0
  38:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:581
  /* Test on EV6 and clear it */
  while(!I2C_CheckEvent(I2C_mcp, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
  3c:	4816      	ldr	r0, [pc, #88]	; (98 <write_to_MCP+0x98>)
  3e:	4918      	ldr	r1, [pc, #96]	; (a0 <write_to_MCP+0xa0>)
  40:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  44:	2800      	cmp	r0, #0
  46:	d0f9      	beq.n	3c <write_to_MCP+0x3c>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:583

	I2C_SendData(I2C_mcp, cmd);	//Transmit the COMMAND byte
  48:	4813      	ldr	r0, [pc, #76]	; (98 <write_to_MCP+0x98>)
  4a:	4631      	mov	r1, r6
  4c:	f7ff fffe 	bl	0 <I2C_SendData>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:584
   while (!I2C_CheckEvent(I2C_mcp, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  50:	4811      	ldr	r0, [pc, #68]	; (98 <write_to_MCP+0x98>)
  52:	4914      	ldr	r1, [pc, #80]	; (a4 <write_to_MCP+0xa4>)
  54:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  58:	2800      	cmp	r0, #0
  5a:	d0f9      	beq.n	50 <write_to_MCP+0x50>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:586

	 I2C_SendData(I2C_mcp, data1);	//Transmit first DATA byte
  5c:	480e      	ldr	r0, [pc, #56]	; (98 <write_to_MCP+0x98>)
  5e:	4629      	mov	r1, r5
  60:	f7ff fffe 	bl	0 <I2C_SendData>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:587
	while (!I2C_CheckEvent(I2C_mcp, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  64:	480c      	ldr	r0, [pc, #48]	; (98 <write_to_MCP+0x98>)
  66:	490f      	ldr	r1, [pc, #60]	; (a4 <write_to_MCP+0xa4>)
  68:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  6c:	2800      	cmp	r0, #0
  6e:	d0f9      	beq.n	64 <write_to_MCP+0x64>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:589

	 I2C_SendData(I2C_mcp, data2);	//Transmit second DATA byte
  70:	4809      	ldr	r0, [pc, #36]	; (98 <write_to_MCP+0x98>)
  72:	4639      	mov	r1, r7
  74:	f7ff fffe 	bl	0 <I2C_SendData>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:590
	while (!I2C_CheckEvent(I2C_mcp, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  78:	4807      	ldr	r0, [pc, #28]	; (98 <write_to_MCP+0x98>)
  7a:	490a      	ldr	r1, [pc, #40]	; (a4 <write_to_MCP+0xa4>)
  7c:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  80:	2800      	cmp	r0, #0
  82:	d0f9      	beq.n	78 <write_to_MCP+0x78>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:594


      /* STOP condition */    
  I2C_GenerateSTOP(I2C_mcp, ENABLE); 
  84:	4804      	ldr	r0, [pc, #16]	; (98 <write_to_MCP+0x98>)
  86:	2101      	movs	r1, #1
  88:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:595
    I2C_StandbyState(address);
  8c:	4620      	mov	r0, r4
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:605
   i2c_write(cmd);		//Transmit the COMMAND byte
   i2c_write(data1);		//Transmit first DATA byte
   i2c_write(data2);		//Transmit second DATA byte
   i2c_stop();			//Generate a STOP condition
*/
}
  8e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:595
	while (!I2C_CheckEvent(I2C_mcp, I2C_EVENT_MASTER_BYTE_TRANSMITTED));


      /* STOP condition */    
  I2C_GenerateSTOP(I2C_mcp, ENABLE); 
    I2C_StandbyState(address);
  92:	f7ff bffe 	b.w	0 <write_to_MCP>
  96:	bf00      	nop
  98:	40005400 	.word	0x40005400
  9c:	00030001 	.word	0x00030001
  a0:	00070082 	.word	0x00070082
  a4:	00070084 	.word	0x00070084

Disassembly of section .text.MCP_read:

00000000 <MCP_read>:
MCP_read():
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:607
   i2c_write(data2);		//Transmit second DATA byte
   i2c_stop();			//Generate a STOP condition
*/
}
void MCP_read(int* pBuffer,unsigned char addressw, unsigned char cmd)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
   4:	460d      	mov	r5, r1
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:612
	unsigned char NumByteToRead;
	unsigned char i;
	NumByteToRead = 4;

	while(I2C_GetFlagStatus(I2C_mcp, I2C_FLAG_BUSY));
   6:	4830      	ldr	r0, [pc, #192]	; (c8 <MCP_read+0xc8>)
   8:	f44f 3100 	mov.w	r1, #131072	; 0x20000
   c:	f7ff fffe 	bl	0 <I2C_GetFlagStatus>
  10:	2800      	cmp	r0, #0
  12:	d1f8      	bne.n	6 <MCP_read+0x6>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:628
	////printU(i++);
	//I2C_SendData(I2C_mcp, cmd);	//Transmit the COMMAND byte
	//while (!I2C_CheckEvent(I2C_mcp, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
   ////
	//printU(i++);
	I2C_GenerateSTART(I2C_mcp, ENABLE);
  14:	482c      	ldr	r0, [pc, #176]	; (c8 <MCP_read+0xc8>)
  16:	2101      	movs	r1, #1
  18:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:630
	/* Test on EV5 and clear it */
	while(!I2C_CheckEvent(I2C_mcp, I2C_EVENT_MASTER_MODE_SELECT));  
  1c:	482a      	ldr	r0, [pc, #168]	; (c8 <MCP_read+0xc8>)
  1e:	492b      	ldr	r1, [pc, #172]	; (cc <MCP_read+0xcc>)
  20:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  24:	2800      	cmp	r0, #0
  26:	d0f9      	beq.n	1c <MCP_read+0x1c>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:632
	//printU(i++);
	 I2C_Send7bitAddress(I2C_mcp,addressw, I2C_Direction_Transmitter);
  28:	4827      	ldr	r0, [pc, #156]	; (c8 <MCP_read+0xc8>)
  2a:	4629      	mov	r1, r5
  2c:	2200      	movs	r2, #0
  2e:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:634
  /* Test on EV6 and clear it */
  while(!I2C_CheckEvent(I2C_mcp, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
  32:	4825      	ldr	r0, [pc, #148]	; (c8 <MCP_read+0xc8>)
  34:	4926      	ldr	r1, [pc, #152]	; (d0 <MCP_read+0xd0>)
  36:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  3a:	2800      	cmp	r0, #0
  3c:	d0f9      	beq.n	32 <MCP_read+0x32>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:636

	I2C_SendData(I2C_mcp, 0x00);	//Transmit the COMMAND byte 00
  3e:	4822      	ldr	r0, [pc, #136]	; (c8 <MCP_read+0xc8>)
  40:	2100      	movs	r1, #0
  42:	f7ff fffe 	bl	0 <I2C_SendData>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:637
   while (!I2C_CheckEvent(I2C_mcp, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  46:	4820      	ldr	r0, [pc, #128]	; (c8 <MCP_read+0xc8>)
  48:	4922      	ldr	r1, [pc, #136]	; (d4 <MCP_read+0xd4>)
  4a:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  4e:	2800      	cmp	r0, #0
  50:	d0f9      	beq.n	46 <MCP_read+0x46>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:640
   
   
   	I2C_GenerateSTART(I2C_mcp, ENABLE);
  52:	481d      	ldr	r0, [pc, #116]	; (c8 <MCP_read+0xc8>)
  54:	2101      	movs	r1, #1
  56:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:642
	/* Test on EV5 and clear it */
	while(!I2C_CheckEvent(I2C_mcp, I2C_EVENT_MASTER_MODE_SELECT));  
  5a:	481b      	ldr	r0, [pc, #108]	; (c8 <MCP_read+0xc8>)
  5c:	491b      	ldr	r1, [pc, #108]	; (cc <MCP_read+0xcc>)
  5e:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  62:	2800      	cmp	r0, #0
  64:	d0f9      	beq.n	5a <MCP_read+0x5a>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:645
	
		/* Send address for read */
	I2C_Send7bitAddress(I2C_mcp,addressw +0x01, I2C_Direction_Receiver);
  66:	1c69      	adds	r1, r5, #1
  68:	4817      	ldr	r0, [pc, #92]	; (c8 <MCP_read+0xc8>)
  6a:	b2c9      	uxtb	r1, r1
  6c:	2201      	movs	r2, #1
  6e:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:648
  
	/* Test on EV6 and clear it */
	while(!I2C_CheckEvent(I2C_mcp, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
  72:	4815      	ldr	r0, [pc, #84]	; (c8 <MCP_read+0xc8>)
  74:	4918      	ldr	r1, [pc, #96]	; (d8 <MCP_read+0xd8>)
  76:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  7a:	2800      	cmp	r0, #0
  7c:	d0f9      	beq.n	72 <MCP_read+0x72>
  7e:	2505      	movs	r5, #5
  80:	e014      	b.n	ac <MCP_read+0xac>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:655



	while(NumByteToRead)  
	{
		if(NumByteToRead == 1)
  82:	2d01      	cmp	r5, #1
  84:	d107      	bne.n	96 <MCP_read+0x96>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:657
		{
			I2C_AcknowledgeConfig(I2C_mcp, DISABLE);
  86:	4810      	ldr	r0, [pc, #64]	; (c8 <MCP_read+0xc8>)
  88:	2100      	movs	r1, #0
  8a:	f7ff fffe 	bl	0 <I2C_AcknowledgeConfig>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:658
			I2C_GenerateSTOP(I2C_mcp, ENABLE);
  8e:	480e      	ldr	r0, [pc, #56]	; (c8 <MCP_read+0xc8>)
  90:	4629      	mov	r1, r5
  92:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:661
		}
		
		if(I2C_CheckEvent(I2C_mcp, I2C_EVENT_MASTER_BYTE_RECEIVED))  
  96:	480c      	ldr	r0, [pc, #48]	; (c8 <MCP_read+0xc8>)
  98:	4910      	ldr	r1, [pc, #64]	; (dc <MCP_read+0xdc>)
  9a:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  9e:	2800      	cmp	r0, #0
  a0:	d0ef      	beq.n	82 <MCP_read+0x82>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:664
		{
		  
		  *pBuffer  = I2C_ReceiveData(I2C_mcp);
  a2:	4809      	ldr	r0, [pc, #36]	; (c8 <MCP_read+0xc8>)
  a4:	f7ff fffe 	bl	0 <I2C_ReceiveData>
  a8:	f844 0b04 	str.w	r0, [r4], #4
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:665
		  pBuffer++;
  ac:	3d01      	subs	r5, #1
  ae:	b2ed      	uxtb	r5, r5
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:653
	while(!I2C_CheckEvent(I2C_mcp, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
	//printU(i++);



	while(NumByteToRead)  
  b0:	2d00      	cmp	r5, #0
  b2:	d1e6      	bne.n	82 <MCP_read+0x82>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:670
		  pBuffer++;
		  NumByteToRead--; 
		}       
	}
	  /* Enable Acknowledgement to be ready for another reception */
	I2C_AcknowledgeConfig(I2C_mcp, ENABLE);
  b4:	2101      	movs	r1, #1
  b6:	4804      	ldr	r0, [pc, #16]	; (c8 <MCP_read+0xc8>)
  b8:	f7ff fffe 	bl	0 <I2C_AcknowledgeConfig>
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:671
    I2C_AcknowledgeConfig(I2C_mcp, ENABLE);
  bc:	4802      	ldr	r0, [pc, #8]	; (c8 <MCP_read+0xc8>)
  be:	2101      	movs	r1, #1
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:683
   i2c_write(AddressR);      // Transmit ADDRESS with READ command
   MCP_LSB=i2c_read(1);      // Receive first DATA byte  (LSB) and acknowledge
   MCP_MSB=i2c_read(0);      // Receive second DATA byte (MSB) and don't acknowledge
   i2c_stop();		     // Generate a STOP condition
*/
}
  c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
D:\sunny\stm32\therme\Utilities\STM32_EVAL\STM3210C_EVAL/et_stm32f_arm_kit_i2c.c:671
		  NumByteToRead--; 
		}       
	}
	  /* Enable Acknowledgement to be ready for another reception */
	I2C_AcknowledgeConfig(I2C_mcp, ENABLE);
    I2C_AcknowledgeConfig(I2C_mcp, ENABLE);
  c4:	f7ff bffe 	b.w	0 <I2C_AcknowledgeConfig>
  c8:	40005400 	.word	0x40005400
  cc:	00030001 	.word	0x00030001
  d0:	00070082 	.word	0x00070082
  d4:	00070084 	.word	0x00070084
  d8:	00030002 	.word	0x00030002
  dc:	00030040 	.word	0x00030040
