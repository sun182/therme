
D:\sunny\stm32\therme\Project\RIDE\STM3210C-EVAL\stm32f10x_adc.o:     file format elf32-littlearm
D:\sunny\stm32\therme\Project\RIDE\STM3210C-EVAL\stm32f10x_adc.o


Disassembly of section .text.ADC_DeInit:

00000000 <ADC_DeInit>:
ADC_DeInit():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:183
void ADC_DeInit(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  if (ADCx == ADC1)
   0:	4b13      	ldr	r3, [pc, #76]	; (50 <ADC_DeInit+0x50>)
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:179
  * @brief  Deinitializes the ADCx peripheral registers to their default reset values.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval None
  */
void ADC_DeInit(ADC_TypeDef* ADCx)
{
   2:	b510      	push	{r4, lr}
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:183
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  if (ADCx == ADC1)
   4:	4298      	cmp	r0, r3
   6:	d107      	bne.n	18 <ADC_DeInit+0x18>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:186
  {
    /* Enable ADC1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
   8:	f44f 7000 	mov.w	r0, #512	; 0x200
   c:	2101      	movs	r1, #1
   e:	f7ff fffe 	bl	0 <RCC_APB2PeriphResetCmd>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:188
    /* Release ADC1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
  12:	f44f 7000 	mov.w	r0, #512	; 0x200
  16:	e014      	b.n	42 <ADC_DeInit+0x42>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:190
  }
  else if (ADCx == ADC2)
  18:	4b0e      	ldr	r3, [pc, #56]	; (54 <ADC_DeInit+0x54>)
  1a:	4298      	cmp	r0, r3
  1c:	d107      	bne.n	2e <ADC_DeInit+0x2e>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:193
  {
    /* Enable ADC2 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
  1e:	f44f 6080 	mov.w	r0, #1024	; 0x400
  22:	2101      	movs	r1, #1
  24:	f7ff fffe 	bl	0 <RCC_APB2PeriphResetCmd>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:195
    /* Release ADC2 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
  28:	f44f 6080 	mov.w	r0, #1024	; 0x400
  2c:	e009      	b.n	42 <ADC_DeInit+0x42>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:199
  }
  else
  {
    if (ADCx == ADC3)
  2e:	4b0a      	ldr	r3, [pc, #40]	; (58 <ADC_DeInit+0x58>)
  30:	4298      	cmp	r0, r3
  32:	d10b      	bne.n	4c <ADC_DeInit+0x4c>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:202
    {
      /* Enable ADC3 reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
  34:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  38:	2101      	movs	r1, #1
  3a:	f7ff fffe 	bl	0 <RCC_APB2PeriphResetCmd>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:204
      /* Release ADC3 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
  3e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  42:	2100      	movs	r1, #0
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:207
    }
  }
}
  44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:204
    if (ADCx == ADC3)
    {
      /* Enable ADC3 reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
      /* Release ADC3 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
  48:	f7ff bffe 	b.w	0 <RCC_APB2PeriphResetCmd>
  4c:	bd10      	pop	{r4, pc}
  4e:	bf00      	nop
  50:	40012400 	.word	0x40012400
  54:	40012800 	.word	0x40012800
  58:	40013c00 	.word	0x40013c00

Disassembly of section .text.ADC_Init:

00000000 <ADC_Init>:
ADC_Init():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:232
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));

  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
   0:	680a6843 	.word	0x680a6843
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:234
  /* Clear DUALMOD and SCAN bits */
  tmpreg1 &= CR1_CLEAR_Mask;
   4:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
   8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:238
  /* Configure ADCx: Dual mode and scan conversion mode */
  /* Set DUALMOD bits according to ADC_Mode value */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
   c:	4313      	orrs	r3, r2
   e:	790a      	ldrb	r2, [r1, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:218
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *   the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
  10:	b510      	push	{r4, lr}
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:238
  /* Clear DUALMOD and SCAN bits */
  tmpreg1 &= CR1_CLEAR_Mask;
  /* Configure ADCx: Dual mode and scan conversion mode */
  /* Set DUALMOD bits according to ADC_Mode value */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
  12:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:240
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
  16:	6043      	str	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:251
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
  18:	688a      	ldr	r2, [r1, #8]
  1a:	68cb      	ldr	r3, [r1, #12]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:244
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;

  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
  1c:	6884      	ldr	r4, [r0, #8]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:251
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
  1e:	431a      	orrs	r2, r3
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:246

  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
  /* Clear CONT, ALIGN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_Mask;
  20:	4b09      	ldr	r3, [pc, #36]	; (48 <ADC_Init+0x48>)
  22:	ea04 0303 	and.w	r3, r4, r3
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:251
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
  26:	ea42 0303 	orr.w	r3, r2, r3
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:252
            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
  2a:	794a      	ldrb	r2, [r1, #5]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:251
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
  2c:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:254
            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
  30:	6083      	str	r3, [r0, #8]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:263
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
  32:	7c0b      	ldrb	r3, [r1, #16]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:258
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  34:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:263
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
  36:	3b01      	subs	r3, #1
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:260

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  38:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:264
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
  tmpreg1 |= (uint32_t)tmpreg2 << 20;
  3c:	b2db      	uxtb	r3, r3
  3e:	ea42 5303 	orr.w	r3, r2, r3, lsl #20
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:266
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
  42:	62c3      	str	r3, [r0, #44]	; 0x2c
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:267
}
  44:	bd10      	pop	{r4, pc}
  46:	bf00      	nop
  48:	fff1f7fd 	.word	0xfff1f7fd

Disassembly of section .text.ADC_StructInit:

00000000 <ADC_StructInit>:
ADC_StructInit():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:278
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Reset ADC init structure parameters values */
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
   0:	2300      	movs	r3, #0
   2:	6003      	str	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:280
  /* initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
   4:	7103      	strb	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:282
  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
   6:	7143      	strb	r3, [r0, #5]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:284
  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
   8:	6083      	str	r3, [r0, #8]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:286
  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
   a:	60c3      	str	r3, [r0, #12]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:288
  /* Initialize the ADC_NbrOfChannel member */
  ADC_InitStruct->ADC_NbrOfChannel = 1;
   c:	3301      	adds	r3, #1
   e:	7403      	strb	r3, [r0, #16]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:289
}
  10:	4770      	bx	lr

Disassembly of section .text.ADC_Cmd:

00000000 <ADC_Cmd>:
ADC_Cmd():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:303
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_Cmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:306
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= CR2_ADON_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f043 0301 	orr.w	r3, r3, #1
   8:	e002      	b.n	10 <ADC_Cmd+0x10>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:311
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= CR2_ADON_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f023 0301 	bic.w	r3, r3, #1
  10:	6083      	str	r3, [r0, #8]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_DMACmd:

00000000 <ADC_DMACmd>:
ADC_DMACmd():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:328
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_DMACmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:331
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= CR2_DMA_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   8:	e002      	b.n	10 <ADC_DMACmd+0x10>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:336
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= CR2_DMA_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  10:	6083      	str	r3, [r0, #8]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_ITConfig:

00000000 <ADC_ITConfig>:
ADC_ITConfig():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:360
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_ADC_IT(ADC_IT));
  /* Get the ADC IT index */
  itmask = (uint8_t)ADC_IT;
   0:	b2c9      	uxtb	r1, r1
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:361
  if (NewState != DISABLE)
   2:	b112      	cbz	r2, a <ADC_ITConfig+0xa>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:364
  {
    /* Enable the selected ADC interrupts */
    ADCx->CR1 |= itmask;
   4:	6843      	ldr	r3, [r0, #4]
   6:	4319      	orrs	r1, r3
   8:	e002      	b.n	10 <ADC_ITConfig+0x10>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:369
  }
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->CR1 &= (~(uint32_t)itmask);
   a:	6843      	ldr	r3, [r0, #4]
   c:	ea23 0101 	bic.w	r1, r3, r1
  10:	6041      	str	r1, [r0, #4]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_ResetCalibration:

00000000 <ADC_ResetCalibration>:
ADC_ResetCalibration():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:383
void ADC_ResetCalibration(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Resets the selected ADC calibartion registers */  
  ADCx->CR2 |= CR2_RSTCAL_Set;
   0:	6883      	ldr	r3, [r0, #8]
   2:	f043 0308 	orr.w	r3, r3, #8
   6:	6083      	str	r3, [r0, #8]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:384
}
   8:	4770      	bx	lr

Disassembly of section .text.ADC_GetResetCalibrationStatus:

00000000 <ADC_GetResetCalibrationStatus>:
ADC_GetResetCalibrationStatus():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:397
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of RSTCAL bit */
  if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
   0:	6880      	ldr	r0, [r0, #8]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:409
    /* RSTCAL bit is reset */
    bitstatus = RESET;
  }
  /* Return the RSTCAL bit status */
  return  bitstatus;
}
   2:	f3c0 00c0 	ubfx	r0, r0, #3, #1
   6:	4770      	bx	lr

Disassembly of section .text.ADC_StartCalibration:

00000000 <ADC_StartCalibration>:
ADC_StartCalibration():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:421
void ADC_StartCalibration(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Enable the selected ADC calibration process */  
  ADCx->CR2 |= CR2_CAL_Set;
   0:	6883      	ldr	r3, [r0, #8]
   2:	f043 0304 	orr.w	r3, r3, #4
   6:	6083      	str	r3, [r0, #8]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:422
}
   8:	4770      	bx	lr

Disassembly of section .text.ADC_GetCalibrationStatus:

00000000 <ADC_GetCalibrationStatus>:
ADC_GetCalibrationStatus():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:435
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of CAL bit */
  if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
   0:	6880      	ldr	r0, [r0, #8]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:447
    /* CAL bit is reset: end of calibration */
    bitstatus = RESET;
  }
  /* Return the CAL bit status */
  return  bitstatus;
}
   2:	f3c0 0080 	ubfx	r0, r0, #2, #1
   6:	4770      	bx	lr

Disassembly of section .text.ADC_SoftwareStartConvCmd:

00000000 <ADC_SoftwareStartConvCmd>:
ADC_SoftwareStartConvCmd():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:461
void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_SoftwareStartConvCmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:465
  {
    /* Enable the selected ADC conversion on external event and start the selected
       ADC conversion */
    ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 03a0 	orr.w	r3, r3, #5242880	; 0x500000
   8:	e002      	b.n	10 <ADC_SoftwareStartConvCmd+0x10>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:471
  }
  else
  {
    /* Disable the selected ADC conversion on external event and stop the selected
       ADC conversion */
    ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 03a0 	bic.w	r3, r3, #5242880	; 0x500000
  10:	6083      	str	r3, [r0, #8]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_GetSoftwareStartConvStatus:

00000000 <ADC_GetSoftwareStartConvStatus>:
ADC_GetSoftwareStartConvStatus():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:486
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of SWSTART bit */
  if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)
   0:	6880      	ldr	r0, [r0, #8]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:498
    /* SWSTART bit is reset */
    bitstatus = RESET;
  }
  /* Return the SWSTART bit status */
  return  bitstatus;
}
   2:	f3c0 5080 	ubfx	r0, r0, #22, #1
   6:	4770      	bx	lr

Disassembly of section .text.ADC_DiscModeChannelCountConfig:

00000000 <ADC_DiscModeChannelCountConfig>:
ADC_DiscModeChannelCountConfig():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:516
  uint32_t tmpreg2 = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
   0:	6843      	ldr	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:520
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_Reset;
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
   2:	3901      	subs	r1, #1
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:518
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_Reset;
   4:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:521
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
  tmpreg1 |= tmpreg2 << 13;
   8:	ea43 3341 	orr.w	r3, r3, r1, lsl #13
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:523
  /* Store the new register value */
  ADCx->CR1 = tmpreg1;
   c:	6043      	str	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:524
}
   e:	4770      	bx	lr

Disassembly of section .text.ADC_DiscModeCmd:

00000000 <ADC_DiscModeCmd>:
ADC_DiscModeCmd():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:540
void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_DiscModeCmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:543
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CR1 |= CR1_DISCEN_Set;
   2:	6843      	ldr	r3, [r0, #4]
   4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   8:	e002      	b.n	10 <ADC_DiscModeCmd+0x10>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:548
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    ADCx->CR1 &= CR1_DISCEN_Reset;
   a:	6843      	ldr	r3, [r0, #4]
   c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  10:	6043      	str	r3, [r0, #4]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_RegularChannelConfig:

00000000 <ADC_RegularChannelConfig>:
ADC_RegularChannelConfig():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:598
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
   0:	2909      	cmp	r1, #9
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:590
  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
   2:	b570      	push	{r4, r5, r6, lr}
   4:	ea4f 0441 	mov.w	r4, r1, lsl #1
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:598
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
   8:	d90b      	bls.n	22 <ADC_RegularChannelConfig+0x22>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:603
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
   a:	1864      	adds	r4, r4, r1
   c:	3c1e      	subs	r4, #30
   e:	2507      	movs	r5, #7
  10:	40a5      	lsls	r5, r4
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:607
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
  12:	40a3      	lsls	r3, r4
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:601
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
  14:	68c6      	ldr	r6, [r0, #12]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:605
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
  16:	ea26 0505 	bic.w	r5, r6, r5
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:609
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
  1a:	ea45 0403 	orr.w	r4, r5, r3
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:611
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
  1e:	60c4      	str	r4, [r0, #12]
  20:	e00a      	b.n	38 <ADC_RegularChannelConfig+0x38>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:618
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
  22:	1864      	adds	r4, r4, r1
  24:	2507      	movs	r5, #7
  26:	40a5      	lsls	r5, r4
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:622
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
  28:	fa13 f404 	lsls.w	r4, r3, r4
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:616
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
  2c:	6906      	ldr	r6, [r0, #16]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:620
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
  2e:	ea26 0505 	bic.w	r5, r6, r5
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:624
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
  32:	ea45 0304 	orr.w	r3, r5, r4
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:626
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
  36:	6103      	str	r3, [r0, #16]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:629
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
  38:	2a06      	cmp	r2, #6
  3a:	d80c      	bhi.n	56 <ADC_RegularChannelConfig+0x56>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:634
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
  3c:	3a01      	subs	r2, #1
  3e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  42:	231f      	movs	r3, #31
  44:	4093      	lsls	r3, r2
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:638
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
  46:	4091      	lsls	r1, r2
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:632
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
  48:	6b44      	ldr	r4, [r0, #52]	; 0x34
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:636
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  4a:	ea24 0303 	bic.w	r3, r4, r3
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:640
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
  4e:	ea43 0201 	orr.w	r2, r3, r1
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:642
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
  52:	6342      	str	r2, [r0, #52]	; 0x34
  54:	bd70      	pop	{r4, r5, r6, pc}
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:645
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
  56:	2a0c      	cmp	r2, #12
  58:	ea4f 0382 	mov.w	r3, r2, lsl #2
  5c:	d80b      	bhi.n	76 <ADC_RegularChannelConfig+0x76>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:650
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
  5e:	189a      	adds	r2, r3, r2
  60:	3a23      	subs	r2, #35	; 0x23
  62:	231f      	movs	r3, #31
  64:	4093      	lsls	r3, r2
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:654
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
  66:	4091      	lsls	r1, r2
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:648
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
  68:	6b04      	ldr	r4, [r0, #48]	; 0x30
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:652
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  6a:	ea24 0303 	bic.w	r3, r4, r3
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:656
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
  6e:	ea43 0201 	orr.w	r2, r3, r1
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:658
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
  72:	6302      	str	r2, [r0, #48]	; 0x30
  74:	bd70      	pop	{r4, r5, r6, pc}
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:666
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
  76:	189a      	adds	r2, r3, r2
  78:	3a41      	subs	r2, #65	; 0x41
  7a:	231f      	movs	r3, #31
  7c:	4093      	lsls	r3, r2
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:670
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
  7e:	4091      	lsls	r1, r2
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:664
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
  80:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:668
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  82:	ea24 0303 	bic.w	r3, r4, r3
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:672
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
  86:	ea43 0201 	orr.w	r2, r3, r1
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:674
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
  8a:	62c2      	str	r2, [r0, #44]	; 0x2c
  8c:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.ADC_ExternalTrigConvCmd:

00000000 <ADC_ExternalTrigConvCmd>:
ADC_ExternalTrigConvCmd():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:690
void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_ExternalTrigConvCmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:693
  {
    /* Enable the selected ADC conversion on external event */
    ADCx->CR2 |= CR2_EXTTRIG_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   8:	e002      	b.n	10 <ADC_ExternalTrigConvCmd+0x10>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:698
  }
  else
  {
    /* Disable the selected ADC conversion on external event */
    ADCx->CR2 &= CR2_EXTTRIG_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
  10:	6083      	str	r3, [r0, #8]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_GetConversionValue:

00000000 <ADC_GetConversionValue>:
ADC_GetConversionValue():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:712
uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Return the selected ADC conversion value */
  return (uint16_t) ADCx->DR;
   0:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:713
}
   2:	b280      	uxth	r0, r0
   4:	4770      	bx	lr

Disassembly of section .text.ADC_GetDualModeConversionValue:

00000000 <ADC_GetDualModeConversionValue>:
ADC_GetDualModeConversionValue():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:722
  * @retval The Data conversion value.
  */
uint32_t ADC_GetDualModeConversionValue(void)
{
  /* Return the dual mode conversion value */
  return (*(__IO uint32_t *) DR_ADDRESS);
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <ADC_GetDualModeConversionValue+0x8>)
   2:	6818      	ldr	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:723
}
   4:	4770      	bx	lr
   6:	bf00      	nop
   8:	4001244c 	.word	0x4001244c

Disassembly of section .text.ADC_AutoInjectedConvCmd:

00000000 <ADC_AutoInjectedConvCmd>:
ADC_AutoInjectedConvCmd():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:738
void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_AutoInjectedConvCmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:741
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CR1 |= CR1_JAUTO_Set;
   2:	6843      	ldr	r3, [r0, #4]
   4:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   8:	e002      	b.n	10 <ADC_AutoInjectedConvCmd+0x10>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:746
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    ADCx->CR1 &= CR1_JAUTO_Reset;
   a:	6843      	ldr	r3, [r0, #4]
   c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  10:	6043      	str	r3, [r0, #4]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_InjectedDiscModeCmd:

00000000 <ADC_InjectedDiscModeCmd>:
ADC_InjectedDiscModeCmd():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:764
void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_InjectedDiscModeCmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:767
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CR1 |= CR1_JDISCEN_Set;
   2:	6843      	ldr	r3, [r0, #4]
   4:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   8:	e002      	b.n	10 <ADC_InjectedDiscModeCmd+0x10>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:772
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    ADCx->CR1 &= CR1_JDISCEN_Reset;
   a:	6843      	ldr	r3, [r0, #4]
   c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  10:	6043      	str	r3, [r0, #4]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_ExternalTrigInjectedConvConfig:

00000000 <ADC_ExternalTrigInjectedConvConfig>:
ADC_ExternalTrigInjectedConvConfig():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:805
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
  /* Get the old register value */
  tmpreg = ADCx->CR2;
   0:	6883      	ldr	r3, [r0, #8]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:807
  /* Clear the old external event selection for injected group */
  tmpreg &= CR2_JEXTSEL_Reset;
   2:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:809
  /* Set the external event selection for injected group */
  tmpreg |= ADC_ExternalTrigInjecConv;
   6:	ea41 0303 	orr.w	r3, r1, r3
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:811
  /* Store the new register value */
  ADCx->CR2 = tmpreg;
   a:	6083      	str	r3, [r0, #8]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:812
}
   c:	4770      	bx	lr

Disassembly of section .text.ADC_ExternalTrigInjectedConvCmd:

00000000 <ADC_ExternalTrigInjectedConvCmd>:
ADC_ExternalTrigInjectedConvCmd():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:828
void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_ExternalTrigInjectedConvCmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:831
  {
    /* Enable the selected ADC external event selection for injected group */
    ADCx->CR2 |= CR2_JEXTTRIG_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   8:	e002      	b.n	10 <ADC_ExternalTrigInjectedConvCmd+0x10>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:836
  }
  else
  {
    /* Disable the selected ADC external event selection for injected group */
    ADCx->CR2 &= CR2_JEXTTRIG_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  10:	6083      	str	r3, [r0, #8]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_SoftwareStartInjectedConvCmd:

00000000 <ADC_SoftwareStartInjectedConvCmd>:
ADC_SoftwareStartInjectedConvCmd():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:853
void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_SoftwareStartInjectedConvCmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:857
  {
    /* Enable the selected ADC conversion for injected group on external event and start the selected
       ADC injected conversion */
    ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 1302 	orr.w	r3, r3, #2129920	; 0x208000
   8:	e002      	b.n	10 <ADC_SoftwareStartInjectedConvCmd+0x10>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:863
  }
  else
  {
    /* Disable the selected ADC conversion on external event for injected group and stop the selected
       ADC injected conversion */
    ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 1302 	bic.w	r3, r3, #2129920	; 0x208000
  10:	6083      	str	r3, [r0, #8]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_GetSoftwareStartInjectedConvCmdStatus:

00000000 <ADC_GetSoftwareStartInjectedConvCmdStatus>:
ADC_GetSoftwareStartInjectedConvCmdStatus():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:878
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of JSWSTART bit */
  if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET)
   0:	6880      	ldr	r0, [r0, #8]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:890
    /* JSWSTART bit is reset */
    bitstatus = RESET;
  }
  /* Return the JSWSTART bit status */
  return  bitstatus;
}
   2:	f3c0 5040 	ubfx	r0, r0, #21, #1
   6:	4770      	bx	lr

Disassembly of section .text.ADC_InjectedChannelConfig:

00000000 <ADC_InjectedChannelConfig>:
ADC_InjectedChannelConfig():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:938
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
   0:	2909      	cmp	r1, #9
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:930
  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
  * @retval None
  */
void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
   2:	b570      	push	{r4, r5, r6, lr}
   4:	ea4f 0441 	mov.w	r4, r1, lsl #1
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:938
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
   8:	d90b      	bls.n	22 <ADC_InjectedChannelConfig+0x22>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:943
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
   a:	1864      	adds	r4, r4, r1
   c:	3c1e      	subs	r4, #30
   e:	2507      	movs	r5, #7
  10:	40a5      	lsls	r5, r4
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:947
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
  12:	40a3      	lsls	r3, r4
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:941
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
  14:	68c6      	ldr	r6, [r0, #12]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:945
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
  16:	ea26 0505 	bic.w	r5, r6, r5
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:949
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
  1a:	ea45 0403 	orr.w	r4, r5, r3
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:951
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
  1e:	60c4      	str	r4, [r0, #12]
  20:	e00a      	b.n	38 <ADC_InjectedChannelConfig+0x38>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:958
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
  22:	1864      	adds	r4, r4, r1
  24:	2507      	movs	r5, #7
  26:	40a5      	lsls	r5, r4
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:962
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
  28:	fa13 f404 	lsls.w	r4, r3, r4
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:956
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
  2c:	6906      	ldr	r6, [r0, #16]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:960
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
  2e:	ea26 0505 	bic.w	r5, r6, r5
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:964
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
  32:	ea45 0304 	orr.w	r3, r5, r4
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:966
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
  36:	6103      	str	r3, [r0, #16]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:970
  }
  /* Rank configuration */
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
  38:	6b83      	ldr	r3, [r0, #56]	; 0x38
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:972
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
  3a:	f403 1440 	and.w	r4, r3, #3145728	; 0x300000
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:974
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
  3e:	ea6f 5414 	mvn.w	r4, r4, lsr #20
  42:	1912      	adds	r2, r2, r4
  44:	3203      	adds	r2, #3
  46:	b2d2      	uxtb	r2, r2
  48:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  4c:	241f      	movs	r4, #31
  4e:	4094      	lsls	r4, r2
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:978
  /* Clear the old JSQx bits for the selected rank */
  tmpreg1 &= ~tmpreg2;
  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
  50:	4091      	lsls	r1, r2
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:976
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
  /* Clear the old JSQx bits for the selected rank */
  tmpreg1 &= ~tmpreg2;
  52:	ea23 0304 	bic.w	r3, r3, r4
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:980
  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
  /* Set the JSQx bits for the selected rank */
  tmpreg1 |= tmpreg2;
  56:	430b      	orrs	r3, r1
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:982
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
  58:	6383      	str	r3, [r0, #56]	; 0x38
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:983
}
  5a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.ADC_InjectedSequencerLengthConfig:

00000000 <ADC_InjectedSequencerLengthConfig>:
ADC_InjectedSequencerLengthConfig():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1001
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_LENGTH(Length));
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
   0:	6b83      	ldr	r3, [r0, #56]	; 0x38
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1005
  /* Clear the old injected sequnence lenght JL bits */
  tmpreg1 &= JSQR_JL_Reset;
  /* Set the injected sequnence lenght JL bits */
  tmpreg2 = Length - 1; 
   2:	3901      	subs	r1, #1
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1003
  assert_param(IS_ADC_INJECTED_LENGTH(Length));
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
  /* Clear the old injected sequnence lenght JL bits */
  tmpreg1 &= JSQR_JL_Reset;
   4:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1006
  /* Set the injected sequnence lenght JL bits */
  tmpreg2 = Length - 1; 
  tmpreg1 |= tmpreg2 << 20;
   8:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1008
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
   c:	6383      	str	r3, [r0, #56]	; 0x38
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1009
}
   e:	4770      	bx	lr

Disassembly of section .text.ADC_SetInjectedOffset:

00000000 <ADC_SetInjectedOffset>:
ADC_SetInjectedOffset():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1025
  * @param  Offset: the offset value for the selected ADC injected channel
  *   This parameter must be a 12bit value.
  * @retval None
  */
void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
{
   0:	b082      	sub	sp, #8
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1026
  __IO uint32_t tmp = 0;
   2:	2300      	movs	r3, #0
   4:	9301      	str	r3, [sp, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1033
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_OFFSET(Offset));  
  
  tmp = (uint32_t)ADCx;
   6:	9001      	str	r0, [sp, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1034
  tmp += ADC_InjectedChannel;
   8:	9b01      	ldr	r3, [sp, #4]
   a:	18cb      	adds	r3, r1, r3
   c:	9301      	str	r3, [sp, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1037
  
  /* Set the selected injected channel data offset */
  *(__IO uint32_t *) tmp = (uint32_t)Offset;
   e:	9b01      	ldr	r3, [sp, #4]
  10:	601a      	str	r2, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1038
}
  12:	b002      	add	sp, #8
  14:	4770      	bx	lr

Disassembly of section .text.ADC_GetInjectedConversionValue:

00000000 <ADC_GetInjectedConversionValue>:
ADC_GetInjectedConversionValue():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1052
  *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
  *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
  * @retval The Data conversion value.
  */
uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
{
   0:	b082      	sub	sp, #8
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1053
  __IO uint32_t tmp = 0;
   2:	2300      	movs	r3, #0
   4:	9301      	str	r3, [sp, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1059
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));

  tmp = (uint32_t)ADCx;
   6:	9001      	str	r0, [sp, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1060
  tmp += ADC_InjectedChannel + JDR_Offset;
   8:	9b01      	ldr	r3, [sp, #4]
   a:	3328      	adds	r3, #40	; 0x28
   c:	185b      	adds	r3, r3, r1
   e:	9301      	str	r3, [sp, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1063
  
  /* Returns the selected injected channel conversion data value */
  return (uint16_t) (*(__IO uint32_t*)  tmp);   
  10:	9b01      	ldr	r3, [sp, #4]
  12:	6818      	ldr	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1064
}
  14:	b280      	uxth	r0, r0
  16:	b002      	add	sp, #8
  18:	4770      	bx	lr

Disassembly of section .text.ADC_AnalogWatchdogCmd:

00000000 <ADC_AnalogWatchdogCmd>:
ADC_AnalogWatchdogCmd():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1088
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
  /* Get the old register value */
  tmpreg = ADCx->CR1;
   0:	6843      	ldr	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1090
  /* Clear AWDEN, AWDENJ and AWDSGL bits */
  tmpreg &= CR1_AWDMode_Reset;
   2:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
   6:	f423 7300 	bic.w	r3, r3, #512	; 0x200
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1092
  /* Set the analog watchdog enable mode */
  tmpreg |= ADC_AnalogWatchdog;
   a:	ea41 0303 	orr.w	r3, r1, r3
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1094
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
   e:	6043      	str	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1095
}
  10:	4770      	bx	lr

Disassembly of section .text.ADC_AnalogWatchdogThresholdsConfig:

00000000 <ADC_AnalogWatchdogThresholdsConfig>:
ADC_AnalogWatchdogThresholdsConfig():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1114
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_THRESHOLD(HighThreshold));
  assert_param(IS_ADC_THRESHOLD(LowThreshold));
  /* Set the ADCx high threshold */
  ADCx->HTR = HighThreshold;
   0:	6241      	str	r1, [r0, #36]	; 0x24
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1116
  /* Set the ADCx low threshold */
  ADCx->LTR = LowThreshold;
   2:	6282      	str	r2, [r0, #40]	; 0x28
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1117
}
   4:	4770      	bx	lr

Disassembly of section .text.ADC_AnalogWatchdogSingleChannelConfig:

00000000 <ADC_AnalogWatchdogSingleChannelConfig>:
ADC_AnalogWatchdogSingleChannelConfig():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1151
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  /* Get the old register value */
  tmpreg = ADCx->CR1;
   0:	6843      	ldr	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1153
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= CR1_AWDCH_Reset;
   2:	f023 031f 	bic.w	r3, r3, #31
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1155
  /* Set the Analog watchdog channel */
  tmpreg |= ADC_Channel;
   6:	ea41 0303 	orr.w	r3, r1, r3
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1157
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
   a:	6043      	str	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1158
}
   c:	4770      	bx	lr

Disassembly of section .text.ADC_TempSensorVrefintCmd:

00000000 <ADC_TempSensorVrefintCmd>:
ADC_TempSensorVrefintCmd():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1167
  * @param  NewState: new state of the temperature sensor.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_TempSensorVrefintCmd(FunctionalState NewState)
{
   0:	4b05      	ldr	r3, [pc, #20]	; (18 <ADC_TempSensorVrefintCmd+0x18>)
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1170
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   2:	b118      	cbz	r0, c <ADC_TempSensorVrefintCmd+0xc>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1173
  {
    /* Enable the temperature sensor and Vrefint channel*/
    ADC1->CR2 |= CR2_TSVREFE_Set;
   4:	689a      	ldr	r2, [r3, #8]
   6:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
   a:	e002      	b.n	12 <ADC_TempSensorVrefintCmd+0x12>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1178
  }
  else
  {
    /* Disable the temperature sensor and Vrefint channel*/
    ADC1->CR2 &= CR2_TSVREFE_Reset;
   c:	689a      	ldr	r2, [r3, #8]
   e:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
  12:	609a      	str	r2, [r3, #8]
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	40012400 	.word	0x40012400

Disassembly of section .text.ADC_GetFlagStatus:

00000000 <ADC_GetFlagStatus>:
ADC_GetFlagStatus():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1201
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
  /* Check the status of the specified ADC flag */
  if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   0:	6803      	ldr	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1204
  {
    /* ADC_FLAG is set */
    bitstatus = SET;
   2:	4219      	tst	r1, r3
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1213
    /* ADC_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
}
   4:	bf0c      	ite	eq
   6:	2000      	moveq	r0, #0
   8:	2001      	movne	r0, #1
   a:	4770      	bx	lr

Disassembly of section .text.ADC_ClearFlag:

00000000 <ADC_ClearFlag>:
ADC_ClearFlag():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1233
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
  /* Clear the selected ADC flags */
  ADCx->SR = ~(uint32_t)ADC_FLAG;
   0:	43c9      	mvns	r1, r1
   2:	6001      	str	r1, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1234
}
   4:	4770      	bx	lr

Disassembly of section .text.ADC_GetITStatus:

00000000 <ADC_GetITStatus>:
ADC_GetITStatus():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1256
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_IT(ADC_IT));
  /* Get the ADC IT index */
  itmask = ADC_IT >> 8;
  /* Get the ADC_IT enable bit status */
  enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;
   0:	6843      	ldr	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1258
  /* Check the status of the specified ADC interrupt */
  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
   2:	6800      	ldr	r0, [r0, #0]
   4:	ea10 2011 	ands.w	r0, r0, r1, lsr #8
   8:	d004      	beq.n	14 <ADC_GetITStatus+0x14>
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1256
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_IT(ADC_IT));
  /* Get the ADC IT index */
  itmask = ADC_IT >> 8;
  /* Get the ADC_IT enable bit status */
  enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;
   a:	b2c9      	uxtb	r1, r1
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1261
  /* Check the status of the specified ADC interrupt */
  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
  {
    /* ADC_IT is set */
    bitstatus = SET;
   c:	4219      	tst	r1, r3
   e:	bf0c      	ite	eq
  10:	2000      	moveq	r0, #0
  12:	2001      	movne	r0, #1
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1270
    /* ADC_IT is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_IT status */
  return  bitstatus;
}
  14:	4770      	bx	lr

Disassembly of section .text.ADC_ClearITPendingBit:

00000000 <ADC_ClearITPendingBit>:
ADC_ClearITPendingBit():
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1291
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_IT(ADC_IT));
  /* Get the ADC IT index */
  itmask = (uint8_t)(ADC_IT >> 8);
  /* Clear the selected ADC interrupt pending bits */
  ADCx->SR = ~(uint32_t)itmask;
   0:	ea6f 2111 	mvn.w	r1, r1, lsr #8
   4:	6001      	str	r1, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1292
}
   6:	4770      	bx	lr
