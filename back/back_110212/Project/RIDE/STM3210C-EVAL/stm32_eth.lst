
D:\sunny\stm32\therme\Project\RIDE\STM3210C-EVAL\stm32_eth.o:     file format elf32-littlearm
D:\sunny\stm32\therme\Project\RIDE\STM3210C-EVAL\stm32_eth.o


Disassembly of section .text.ETH_Delay:

00000000 <ETH_Delay>:
ETH_Delay():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3050
  * @brief  Inserts a delay time.
  * @param  nCount: specifies the delay time length.
  * @retval None
  */
static void ETH_Delay(__IO uint32_t nCount)
{
   0:	b084      	sub	sp, #16
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3051
  __IO uint32_t index = 0; 
   2:	2300      	movs	r3, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3050
  * @brief  Inserts a delay time.
  * @param  nCount: specifies the delay time length.
  * @retval None
  */
static void ETH_Delay(__IO uint32_t nCount)
{
   4:	9001      	str	r0, [sp, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3051
  __IO uint32_t index = 0; 
   6:	9303      	str	r3, [sp, #12]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3052
  for(index = nCount; index != 0; index--)
   8:	9b01      	ldr	r3, [sp, #4]
   a:	e001      	b.n	10 <ETH_Delay+0x10>
   c:	9b03      	ldr	r3, [sp, #12]
   e:	3b01      	subs	r3, #1
  10:	9303      	str	r3, [sp, #12]
  12:	9b03      	ldr	r3, [sp, #12]
  14:	2b00      	cmp	r3, #0
  16:	d1f9      	bne.n	c <ETH_Delay+0xc>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3055
  {
  }
}
  18:	b004      	add	sp, #16
  1a:	4770      	bx	lr

Disassembly of section .text.ETH_DeInit:

00000000 <ETH_DeInit>:
ETH_DeInit():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:125
  * @param  None 
  * @retval None
  */
void ETH_DeInit(void)
{
  RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, ENABLE);
   0:	2101      	movs	r1, #1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:124
  * @brief  Deinitializes the ETHERNET peripheral registers to their default reset values.
  * @param  None 
  * @retval None
  */
void ETH_DeInit(void)
{
   2:	b510      	push	{r4, lr}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:125
  RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, ENABLE);
   4:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   8:	f7ff fffe 	bl	0 <RCC_AHBPeriphResetCmd>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:126
  RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, DISABLE);
   c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  10:	2100      	movs	r1, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:127
}
  12:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:126
  * @retval None
  */
void ETH_DeInit(void)
{
  RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, ENABLE);
  RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, DISABLE);
  16:	f7ff bffe 	b.w	0 <RCC_AHBPeriphResetCmd>

Disassembly of section .text.ETH_StructInit:

00000000 <ETH_StructInit>:
ETH_StructInit():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:460
  ETH_InitStruct->ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;                                                         
  ETH_InitStruct->ETH_BackOffLimit = ETH_BackOffLimit_10;                                                                
  ETH_InitStruct->ETH_DeferralCheck = ETH_DeferralCheck_Disable;                                                                                                                  
  ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;                                                               
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;                                
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;          
   0:	2240      	movs	r2, #64	; 0x40
   2:	6402      	str	r2, [r0, #64]	; 0x40
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:461
  ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
   4:	3a20      	subs	r2, #32
   6:	6442      	str	r2, [r0, #68]	; 0x44
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:469
  ETH_InitStruct->ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;      
  ETH_InitStruct->ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;      
  ETH_InitStruct->ETH_HashTableHigh = 0x0;                
  ETH_InitStruct->ETH_HashTableLow = 0x0;                     
  ETH_InitStruct->ETH_PauseTime = 0x0;                 
  ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;            
   8:	3260      	adds	r2, #96	; 0x60
   a:	6642      	str	r2, [r0, #100]	; 0x64
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:477
  ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;        
  ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;      
  ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;          
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
  /*------------------------   DMA   -----------------------------------*/  
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
   c:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:444
  */
void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct)
{
  /* ETH_InitStruct members default value */
  /*------------------------   MAC   -----------------------------------*/     
  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Disable;           
  10:	2300      	movs	r3, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:477
  ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;        
  ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;      
  ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;          
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
  /*------------------------   DMA   -----------------------------------*/  
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
  12:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:478
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
  16:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:479
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Disable;       
  1a:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:444
  */
void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct)
{
  /* ETH_InitStruct members default value */
  /*------------------------   MAC   -----------------------------------*/     
  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Disable;           
  1e:	6003      	str	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:445
  ETH_InitStruct->ETH_Watchdog = ETH_Watchdog_Enable;                   
  20:	6043      	str	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:446
  ETH_InitStruct->ETH_Jabber = ETH_Jabber_Enable;                                                     
  22:	6083      	str	r3, [r0, #8]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:447
  ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;                                                                                                                          
  24:	60c3      	str	r3, [r0, #12]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:448
  ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable;                              
  26:	6103      	str	r3, [r0, #16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:449
  ETH_InitStruct->ETH_Speed = ETH_Speed_10M;                       
  28:	6143      	str	r3, [r0, #20]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:450
  ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;               
  2a:	6183      	str	r3, [r0, #24]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:451
  ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable;              
  2c:	61c3      	str	r3, [r0, #28]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:452
  ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;                       
  2e:	6203      	str	r3, [r0, #32]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:453
  ETH_InitStruct->ETH_ChecksumOffload = ETH_ChecksumOffload_Disable;                                                            
  30:	6243      	str	r3, [r0, #36]	; 0x24
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:454
  ETH_InitStruct->ETH_RetryTransmission = ETH_RetryTransmission_Enable;                                                                                  
  32:	6283      	str	r3, [r0, #40]	; 0x28
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:455
  ETH_InitStruct->ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;                                                         
  34:	62c3      	str	r3, [r0, #44]	; 0x2c
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:456
  ETH_InitStruct->ETH_BackOffLimit = ETH_BackOffLimit_10;                                                                
  36:	6303      	str	r3, [r0, #48]	; 0x30
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:457
  ETH_InitStruct->ETH_DeferralCheck = ETH_DeferralCheck_Disable;                                                                                                                  
  38:	6343      	str	r3, [r0, #52]	; 0x34
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:458
  ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;                                                               
  3a:	6383      	str	r3, [r0, #56]	; 0x38
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:459
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;                                
  3c:	63c3      	str	r3, [r0, #60]	; 0x3c
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:462
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;          
  ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
  ETH_InitStruct->ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal;      
  3e:	6483      	str	r3, [r0, #72]	; 0x48
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:463
  ETH_InitStruct->ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;                                                             
  40:	64c3      	str	r3, [r0, #76]	; 0x4c
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:464
  ETH_InitStruct->ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;      
  42:	6503      	str	r3, [r0, #80]	; 0x50
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:465
  ETH_InitStruct->ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;      
  44:	6543      	str	r3, [r0, #84]	; 0x54
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:466
  ETH_InitStruct->ETH_HashTableHigh = 0x0;                
  46:	6583      	str	r3, [r0, #88]	; 0x58
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:467
  ETH_InitStruct->ETH_HashTableLow = 0x0;                     
  48:	65c3      	str	r3, [r0, #92]	; 0x5c
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:468
  ETH_InitStruct->ETH_PauseTime = 0x0;                 
  4a:	6603      	str	r3, [r0, #96]	; 0x60
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:470
  ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;            
  ETH_InitStruct->ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4;         
  4c:	6683      	str	r3, [r0, #104]	; 0x68
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:471
  ETH_InitStruct->ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable;   
  4e:	66c3      	str	r3, [r0, #108]	; 0x6c
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:472
  ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;        
  50:	6703      	str	r3, [r0, #112]	; 0x70
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:473
  ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;      
  52:	6743      	str	r3, [r0, #116]	; 0x74
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:474
  ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;          
  54:	6783      	str	r3, [r0, #120]	; 0x78
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:475
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
  56:	67c3      	str	r3, [r0, #124]	; 0x7c
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:478
  /*------------------------   DMA   -----------------------------------*/  
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
  58:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:486
  ETH_InitStruct->ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes;  
  ETH_InitStruct->ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;       
  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; 
  ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;   
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  5c:	f8c0 20a4 	str.w	r2, [r0, #164]	; 0xa4
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:488
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Disable;
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_1Beat;
  60:	f44f 3200 	mov.w	r2, #131072	; 0x20000
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:479
  ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;          
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
  /*------------------------   DMA   -----------------------------------*/  
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Disable;       
  64:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:488
  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; 
  ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;   
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Disable;
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_1Beat;
  68:	f8c0 20ac 	str.w	r2, [r0, #172]	; 0xac
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:480
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
  /*------------------------   DMA   -----------------------------------*/  
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Disable;       
  ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;     
  6c:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:489
  ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;   
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Disable;
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_1Beat;
  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_1Beat;
  70:	f44f 7280 	mov.w	r2, #256	; 0x100
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:480
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
  /*------------------------   DMA   -----------------------------------*/  
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Disable;       
  ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;     
  74:	f8c0 108c 	str.w	r1, [r0, #140]	; 0x8c
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:481
  ETH_InitStruct->ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes;  
  78:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:482
  ETH_InitStruct->ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;       
  7c:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:483
  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; 
  80:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:484
  ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;   
  84:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:485
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
  88:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:487
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Disable;
  8c:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:489
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_1Beat;
  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_1Beat;
  90:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:490
  ETH_InitStruct->ETH_DescriptorSkipLength = 0x0;
  94:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:491
  ETH_InitStruct->ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1;
  98:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:492
}
  9c:	4770      	bx	lr

Disassembly of section .text.ETH_HandleTxPkt:

00000000 <ETH_HandleTxPkt>:
ETH_HandleTxPkt():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:526
uint32_t ETH_HandleTxPkt(uint8_t *ppkt, uint16_t FrameLength)
{ 
  uint32_t offset = 0;
    
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (uint32_t)RESET)
   0:	4b1b      	ldr	r3, [pc, #108]	; (70 <ETH_HandleTxPkt+0x70>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:522
  * @param  FrameLength: Tx Packet size.
  * @retval ETH_ERROR: in case of Tx desc owned by DMA
  *         ETH_SUCCESS: for correct transmission
  */
uint32_t ETH_HandleTxPkt(uint8_t *ppkt, uint16_t FrameLength)
{ 
   2:	b530      	push	{r4, r5, lr}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:526
  uint32_t offset = 0;
    
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (uint32_t)RESET)
   4:	681a      	ldr	r2, [r3, #0]
   6:	6812      	ldr	r2, [r2, #0]
   8:	2a00      	cmp	r2, #0
   a:	db2f      	blt.n	6c <ETH_HandleTxPkt+0x6c>
   c:	2200      	movs	r2, #0
   e:	e004      	b.n	1a <ETH_HandleTxPkt+0x1a>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:535
  }
  
  /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */      
  for(offset=0; offset<FrameLength; offset++)       
  {
    (*(__IO uint8_t *)((DMATxDescToSet->Buffer1Addr) + offset)) = (*(ppkt + offset));
  10:	681c      	ldr	r4, [r3, #0]
  12:	5c85      	ldrb	r5, [r0, r2]
  14:	68a4      	ldr	r4, [r4, #8]
  16:	5515      	strb	r5, [r2, r4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:533
    /* Return ERROR: OWN bit set */
    return ETH_ERROR;
  }
  
  /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */      
  for(offset=0; offset<FrameLength; offset++)       
  18:	3201      	adds	r2, #1
  1a:	428a      	cmp	r2, r1
  1c:	d3f8      	bcc.n	10 <ETH_HandleTxPkt+0x10>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:539
  {
    (*(__IO uint8_t *)((DMATxDescToSet->Buffer1Addr) + offset)) = (*(ppkt + offset));
  }
        
  /* Setting the Frame Length: bits[12:0] */
  DMATxDescToSet->ControlBufferSize = (FrameLength & ETH_DMATxDesc_TBS1);
  1e:	681a      	ldr	r2, [r3, #0]
  20:	04c9      	lsls	r1, r1, #19
  22:	0cc9      	lsrs	r1, r1, #19
  24:	6051      	str	r1, [r2, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:543
  /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */    
  DMATxDescToSet->Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
  /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
  26:	6811      	ldr	r1, [r2, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:545
  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
  28:	4812      	ldr	r0, [pc, #72]	; (74 <ETH_HandleTxPkt+0x74>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:543
  /* Setting the Frame Length: bits[12:0] */
  DMATxDescToSet->ControlBufferSize = (FrameLength & ETH_DMATxDesc_TBS1);
  /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */    
  DMATxDescToSet->Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
  /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
  2a:	f041 4130 	orr.w	r1, r1, #2952790016	; 0xb0000000
  2e:	6011      	str	r1, [r2, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:545
  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
  30:	6804      	ldr	r4, [r0, #0]
  32:	f014 0f04 	tst.w	r4, #4
  36:	d004      	beq.n	42 <ETH_HandleTxPkt+0x42>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:548
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
  38:	2404      	movs	r4, #4
  3a:	6004      	str	r4, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:550
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
  3c:	3c04      	subs	r4, #4
  3e:	f840 4c10 	str.w	r4, [r0, #-16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:555
  }
  
  /* Update the ETHERNET DMA global Tx descriptor with next Tx decriptor */  
  /* Chained Mode */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_TCH) != (uint32_t)RESET)
  42:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  46:	d001      	beq.n	4c <ETH_HandleTxPkt+0x4c>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:558
  {     
    /* Selects the next DMA Tx descriptor list for next buffer to send */ 
    DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMATxDescToSet->Buffer2NextDescAddr);    
  48:	68d2      	ldr	r2, [r2, #12]
  4a:	e00c      	b.n	66 <ETH_HandleTxPkt+0x66>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:562
  }
  else /* Ring Mode */
  {  
    if((DMATxDescToSet->Status & ETH_DMATxDesc_TER) != (uint32_t)RESET)
  4c:	f411 1f00 	tst.w	r1, #2097152	; 0x200000
  50:	d002      	beq.n	58 <ETH_HandleTxPkt+0x58>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:565
    {
      /* Selects the first DMA Tx descriptor for next buffer to send: last Tx descriptor was used */
      DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH->DMATDLAR);      
  52:	4a09      	ldr	r2, [pc, #36]	; (78 <ETH_HandleTxPkt+0x78>)
  54:	6812      	ldr	r2, [r2, #0]
  56:	e006      	b.n	66 <ETH_HandleTxPkt+0x66>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:570
    }
    else
    {  
      /* Selects the next DMA Tx descriptor list for next buffer to send */
      DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
  58:	4908      	ldr	r1, [pc, #32]	; (7c <ETH_HandleTxPkt+0x7c>)
  5a:	3210      	adds	r2, #16
  5c:	6809      	ldr	r1, [r1, #0]
  5e:	f001 017c 	and.w	r1, r1, #124	; 0x7c
  62:	eb02 0291 	add.w	r2, r2, r1, lsr #2
  66:	601a      	str	r2, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:574
    }
  }
  /* Return SUCCESS */
  return ETH_SUCCESS;   
  68:	2001      	movs	r0, #1
  6a:	bd30      	pop	{r4, r5, pc}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:529
    
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (uint32_t)RESET)
  {
    /* Return ERROR: OWN bit set */
    return ETH_ERROR;
  6c:	2000      	movs	r0, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:575
      DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
    }
  }
  /* Return SUCCESS */
  return ETH_SUCCESS;   
}
  6e:	bd30      	pop	{r4, r5, pc}
  70:	00000000 	.word	0x00000000
  74:	40029014 	.word	0x40029014
  78:	40029010 	.word	0x40029010
  7c:	40029000 	.word	0x40029000

Disassembly of section .text.ETH_HandleRxPkt:

00000000 <ETH_HandleRxPkt>:
ETH_HandleRxPkt():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:587
  */
uint32_t ETH_HandleRxPkt(uint8_t *ppkt)
{ 
  uint32_t offset = 0, framelength = 0;
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (uint32_t)RESET)
   0:	4b20      	ldr	r3, [pc, #128]	; (84 <ETH_HandleRxPkt+0x84>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:584
  * @param  ppkt: pointer to the application packet receive buffer.
  * @retval ETH_ERROR: if there is error in reception
  *         framelength: received packet size if packet reception is correct
  */
uint32_t ETH_HandleRxPkt(uint8_t *ppkt)
{ 
   2:	b510      	push	{r4, lr}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:587
  uint32_t offset = 0, framelength = 0;
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (uint32_t)RESET)
   4:	681a      	ldr	r2, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:584
  * @param  ppkt: pointer to the application packet receive buffer.
  * @retval ETH_ERROR: if there is error in reception
  *         framelength: received packet size if packet reception is correct
  */
uint32_t ETH_HandleRxPkt(uint8_t *ppkt)
{ 
   6:	4604      	mov	r4, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:587
  uint32_t offset = 0, framelength = 0;
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (uint32_t)RESET)
   8:	6811      	ldr	r1, [r2, #0]
   a:	2900      	cmp	r1, #0
   c:	db37      	blt.n	7e <ETH_HandleRxPkt+0x7e>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:594
    /* Return error: OWN bit set */
    return ETH_ERROR; 
  }
  
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) && 
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&  
   e:	f401 4203 	and.w	r2, r1, #33536	; 0x8300
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:593
  {
    /* Return error: OWN bit set */
    return ETH_ERROR; 
  }
  
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) && 
  12:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
  16:	d10e      	bne.n	36 <ETH_HandleRxPkt+0x36>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:598
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&  
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))  
  {      
    /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
    framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4;
  18:	4a1b      	ldr	r2, [pc, #108]	; (88 <ETH_HandleRxPkt+0x88>)
  1a:	ea01 0202 	and.w	r2, r1, r2
  1e:	0c12      	lsrs	r2, r2, #16
  20:	1f10      	subs	r0, r2, #4
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:600
    /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */
    for(offset=0; offset<framelength; offset++)       
  22:	2200      	movs	r2, #0
  24:	e004      	b.n	30 <ETH_HandleRxPkt+0x30>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:602
    {
      (*(ppkt + offset)) = (*(__IO uint8_t *)((DMARxDescToGet->Buffer1Addr) + offset));
  26:	6819      	ldr	r1, [r3, #0]
  28:	6889      	ldr	r1, [r1, #8]
  2a:	5c51      	ldrb	r1, [r2, r1]
  2c:	54a1      	strb	r1, [r4, r2]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:600
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))  
  {      
    /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
    framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4;
    /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */
    for(offset=0; offset<framelength; offset++)       
  2e:	3201      	adds	r2, #1
  30:	4282      	cmp	r2, r0
  32:	d3f8      	bcc.n	26 <ETH_HandleRxPkt+0x26>
  34:	e000      	b.n	38 <ETH_HandleRxPkt+0x38>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:608
    }
  }
  else
  {
    /* Return ERROR */
    framelength = ETH_ERROR;
  36:	2000      	movs	r0, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:611
  }
  /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMARxDescToGet->Status = ETH_DMARxDesc_OWN; 
  38:	681a      	ldr	r2, [r3, #0]
  3a:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
  3e:	6011      	str	r1, [r2, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:614
 
  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
  if ((ETH->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
  40:	4912      	ldr	r1, [pc, #72]	; (8c <ETH_HandleRxPkt+0x8c>)
  42:	680c      	ldr	r4, [r1, #0]
  44:	f014 0f80 	tst.w	r4, #128	; 0x80
  48:	d004      	beq.n	54 <ETH_HandleRxPkt+0x54>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:617
  {
    /* Clear RBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_RBUS;
  4a:	2480      	movs	r4, #128	; 0x80
  4c:	600c      	str	r4, [r1, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:619
    /* Resume DMA reception */
    ETH->DMARPDR = 0;
  4e:	3c80      	subs	r4, #128	; 0x80
  50:	f841 4c0c 	str.w	r4, [r1, #-12]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:624
  }
  
  /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */      
  /* Chained Mode */
  if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RCH) != (uint32_t)RESET)
  54:	6851      	ldr	r1, [r2, #4]
  56:	f411 4f80 	tst.w	r1, #16384	; 0x4000
  5a:	d001      	beq.n	60 <ETH_HandleRxPkt+0x60>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:627
  {     
    /* Selects the next DMA Rx descriptor list for next buffer to read */ 
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);    
  5c:	68d2      	ldr	r2, [r2, #12]
  5e:	e00c      	b.n	7a <ETH_HandleRxPkt+0x7a>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:631
  }
  else /* Ring Mode */
  {   
    if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RER) != (uint32_t)RESET)
  60:	f411 4f00 	tst.w	r1, #32768	; 0x8000
  64:	d002      	beq.n	6c <ETH_HandleRxPkt+0x6c>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:634
    {
      /* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH->DMARDLAR);      
  66:	4a0a      	ldr	r2, [pc, #40]	; (90 <ETH_HandleRxPkt+0x90>)
  68:	6812      	ldr	r2, [r2, #0]
  6a:	e006      	b.n	7a <ETH_HandleRxPkt+0x7a>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:639
    }
    else
    { 
      /* Selects the next DMA Rx descriptor list for next buffer to read */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
  6c:	4909      	ldr	r1, [pc, #36]	; (94 <ETH_HandleRxPkt+0x94>)
  6e:	3210      	adds	r2, #16
  70:	6809      	ldr	r1, [r1, #0]
  72:	f001 017c 	and.w	r1, r1, #124	; 0x7c
  76:	eb02 0291 	add.w	r2, r2, r1, lsr #2
  7a:	601a      	str	r2, [r3, #0]
  7c:	bd10      	pop	{r4, pc}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:590
  uint32_t offset = 0, framelength = 0;
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (uint32_t)RESET)
  {
    /* Return error: OWN bit set */
    return ETH_ERROR; 
  7e:	2000      	movs	r0, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:645
    }
  }
  
  /* Return Frame Length/ERROR */
  return (framelength);  
}
  80:	bd10      	pop	{r4, pc}
  82:	bf00      	nop
  84:	00000000 	.word	0x00000000
  88:	3fff0000 	.word	0x3fff0000
  8c:	40029014 	.word	0x40029014
  90:	4002900c 	.word	0x4002900c
  94:	40029000 	.word	0x40029000

Disassembly of section .text.ETH_DropRxPkt:

00000000 <ETH_DropRxPkt>:
ETH_DropRxPkt():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:676
  * @retval None
  */
void ETH_DropRxPkt(void)
{
  /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMARxDescToGet->Status = ETH_DMARxDesc_OWN;  
   0:	f04f4b0c 	.word	0xf04f4b0c
   4:	4100      	asrs	r0, r0
   6:	681a      	ldr	r2, [r3, #0]
   8:	6011      	str	r1, [r2, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:678
  /* Chained Mode */
  if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RCH) != (uint32_t)RESET)
   a:	6851      	ldr	r1, [r2, #4]
   c:	f411 4f80 	tst.w	r1, #16384	; 0x4000
  10:	d001      	beq.n	16 <ETH_DropRxPkt+0x16>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:681
  {
    /* Selects the next DMA Rx descriptor list for next buffer read */
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
  12:	68d2      	ldr	r2, [r2, #12]
  14:	e00c      	b.n	30 <ETH_DropRxPkt+0x30>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:685
  }
  else /* Ring Mode */
  {
    if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RER) != (uint32_t)RESET)
  16:	f411 4f00 	tst.w	r1, #32768	; 0x8000
  1a:	d002      	beq.n	22 <ETH_DropRxPkt+0x22>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:689
    {
      /* Selects the next DMA Rx descriptor list for next buffer read: this will
         be the first Rx descriptor in this case */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH->DMARDLAR);
  1c:	4a06      	ldr	r2, [pc, #24]	; (38 <ETH_DropRxPkt+0x38>)
  1e:	6812      	ldr	r2, [r2, #0]
  20:	e006      	b.n	30 <ETH_DropRxPkt+0x30>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:694
    }
    else
    {
      /* Selects the next DMA Rx descriptor list for next buffer read */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));
  22:	4906      	ldr	r1, [pc, #24]	; (3c <ETH_DropRxPkt+0x3c>)
  24:	3210      	adds	r2, #16
  26:	6809      	ldr	r1, [r1, #0]
  28:	f001 017c 	and.w	r1, r1, #124	; 0x7c
  2c:	eb02 0291 	add.w	r2, r2, r1, lsr #2
  30:	601a      	str	r2, [r3, #0]
  32:	4770      	bx	lr
  34:	00000000 	.word	0x00000000
  38:	4002900c 	.word	0x4002900c
  3c:	40029000 	.word	0x40029000

Disassembly of section .text.ETH_ReadPHYRegister:

00000000 <ETH_ReadPHYRegister>:
ETH_ReadPHYRegister():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:716
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
  uint32_t tmpreg = 0;     
__IO uint32_t timeout = 0;
   0:	2300      	movs	r3, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:714
  *     @arg More PHY register could be read depending on the used PHY
  * @retval ETH_ERROR: in case of timeout
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
   2:	b082      	sub	sp, #8
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:716
  uint32_t tmpreg = 0;     
__IO uint32_t timeout = 0;
   4:	9301      	str	r3, [sp, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:722
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
   6:	4b12      	ldr	r3, [pc, #72]	; (50 <ETH_ReadPHYRegister+0x50>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:726
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII address register value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
   8:	06c0      	lsls	r0, r0, #27
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:722
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
   a:	691a      	ldr	r2, [r3, #16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:727
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII address register value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
   c:	0189      	lsls	r1, r1, #6
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:724
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
   e:	f002 021c 	and.w	r2, r2, #28
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:726
  /* Prepare the MII address register value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  12:	ea42 4210 	orr.w	r2, r2, r0, lsr #16
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:727
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  16:	f401 61f8 	and.w	r1, r1, #1984	; 0x7c0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:728
  tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
  1a:	430a      	orrs	r2, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:729
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  1c:	f042 0201 	orr.w	r2, r2, #1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:731
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
  20:	611a      	str	r2, [r3, #16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:735
  /* Check for the Busy flag */
  do
  {
    timeout++;
  22:	9b01      	ldr	r3, [sp, #4]
  24:	3301      	adds	r3, #1
  26:	9301      	str	r3, [sp, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:736
    tmpreg = ETH->MACMIIAR;
  28:	4b09      	ldr	r3, [pc, #36]	; (50 <ETH_ReadPHYRegister+0x50>)
  2a:	691b      	ldr	r3, [r3, #16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:737
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
  2c:	f013 0f01 	tst.w	r3, #1
  30:	d003      	beq.n	3a <ETH_ReadPHYRegister+0x3a>
  32:	9a01      	ldr	r2, [sp, #4]
  34:	4b07      	ldr	r3, [pc, #28]	; (54 <ETH_ReadPHYRegister+0x54>)
  36:	429a      	cmp	r2, r3
  38:	d9f3      	bls.n	22 <ETH_ReadPHYRegister+0x22>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:739
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
  3a:	4b07      	ldr	r3, [pc, #28]	; (58 <ETH_ReadPHYRegister+0x58>)
  3c:	9a01      	ldr	r2, [sp, #4]
  3e:	429a      	cmp	r2, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:745
  {
    return (uint16_t)ETH_ERROR;
  }
  
  /* Return data register value */
  return (uint16_t)(ETH->MACMIIDR);
  40:	bf1d      	ittte	ne
  42:	4b03      	ldrne	r3, [pc, #12]	; (50 <ETH_ReadPHYRegister+0x50>)
  44:	6958      	ldrne	r0, [r3, #20]
  46:	b280      	uxthne	r0, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:741
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
  {
    return (uint16_t)ETH_ERROR;
  48:	2000      	moveq	r0, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:746
  }
  
  /* Return data register value */
  return (uint16_t)(ETH->MACMIIDR);
}
  4a:	b002      	add	sp, #8
  4c:	4770      	bx	lr
  4e:	bf00      	nop
  50:	40028000 	.word	0x40028000
  54:	0004fffe 	.word	0x0004fffe
  58:	0004ffff 	.word	0x0004ffff

Disassembly of section .text.ETH_WritePHYRegister:

00000000 <ETH_WritePHYRegister>:
ETH_WritePHYRegister():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:761
  * @param  PHYValue: the value to write
  * @retval ETH_ERROR: in case of timeout
  *         ETH_SUCCESS: for correct write
  */
uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
{
   0:	2300b513 	.word	0x2300b513
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:763
  uint32_t tmpreg = 0;     
  __IO uint32_t timeout = 0;
   4:	9301      	str	r3, [sp, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:769
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
   6:	4b10      	ldr	r3, [pc, #64]	; (48 <ETH_WritePHYRegister+0x48>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:773
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
   8:	06c0      	lsls	r0, r0, #27
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:769
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
   a:	691c      	ldr	r4, [r3, #16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:774
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
   c:	0189      	lsls	r1, r1, #6
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:771
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
   e:	f004 041c 	and.w	r4, r4, #28
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:774
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  12:	f044 0403 	orr.w	r4, r4, #3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:775
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  16:	ea44 4410 	orr.w	r4, r4, r0, lsr #16
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:774
  tmpreg = ETH->MACMIIAR;
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  1a:	f401 61f8 	and.w	r1, r1, #1984	; 0x7c0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:776
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  1e:	430c      	orrs	r4, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:778
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
  20:	615a      	str	r2, [r3, #20]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:780
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
  22:	611c      	str	r4, [r3, #16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:784
  /* Check for the Busy flag */
  do
  {
    timeout++;
  24:	9b01      	ldr	r3, [sp, #4]
  26:	3301      	adds	r3, #1
  28:	9301      	str	r3, [sp, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:785
    tmpreg = ETH->MACMIIAR;
  2a:	4b07      	ldr	r3, [pc, #28]	; (48 <ETH_WritePHYRegister+0x48>)
  2c:	691b      	ldr	r3, [r3, #16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:786
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
  2e:	f013 0f01 	tst.w	r3, #1
  32:	d003      	beq.n	3c <ETH_WritePHYRegister+0x3c>
  34:	9a01      	ldr	r2, [sp, #4]
  36:	4b05      	ldr	r3, [pc, #20]	; (4c <ETH_WritePHYRegister+0x4c>)
  38:	429a      	cmp	r2, r3
  3a:	d9f3      	bls.n	24 <ETH_WritePHYRegister+0x24>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:788
  /* Return ERROR in case of timeout */
  if(timeout == PHY_WRITE_TO)
  3c:	9801      	ldr	r0, [sp, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:795
    return ETH_ERROR;
  }
  
  /* Return SUCCESS */
  return ETH_SUCCESS;  
}
  3e:	4b04      	ldr	r3, [pc, #16]	; (50 <ETH_WritePHYRegister+0x50>)
  40:	1ac0      	subs	r0, r0, r3
  42:	bf18      	it	ne
  44:	2001      	movne	r0, #1
  46:	bd1c      	pop	{r2, r3, r4, pc}
  48:	40028000 	.word	0x40028000
  4c:	0004fffe 	.word	0x0004fffe
  50:	0004ffff 	.word	0x0004ffff

Disassembly of section .text.ETH_Init:

00000000 <ETH_Init>:
ETH_Init():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:139
  * @param PHYAddress: external PHY address                    
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:141
  uint32_t RegValue = 0, tmpreg = 0;
  __IO uint32_t i = 0;
   2:	2300      	movs	r3, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:139
  * @param PHYAddress: external PHY address                    
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
   4:	b088      	sub	sp, #32
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:141
  uint32_t RegValue = 0, tmpreg = 0;
  __IO uint32_t i = 0;
   6:	9307      	str	r3, [sp, #28]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:144
  RCC_ClocksTypeDef  rcc_clocks;
  uint32_t hclk = 60000000;
  __IO uint32_t timeout = 0;
   8:	9306      	str	r3, [sp, #24]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:196
  assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));  
  assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));       
  /*-------------------------------- MAC Config ------------------------------*/   
  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
   a:	4b86      	ldr	r3, [pc, #536]	; (224 <ETH_Init+0x224>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:139
  * @param PHYAddress: external PHY address                    
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
   c:	4604      	mov	r4, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:200
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Clear CSR Clock Range CR[2:0] bits */
  tmpreg &= MACMIIAR_CR_MASK;
  /* Get hclk frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
   e:	a801      	add	r0, sp, #4
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:196
  assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));  
  assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));       
  /*-------------------------------- MAC Config ------------------------------*/   
  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  10:	691e      	ldr	r6, [r3, #16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:139
  * @param PHYAddress: external PHY address                    
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
  12:	460d      	mov	r5, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:200
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Clear CSR Clock Range CR[2:0] bits */
  tmpreg &= MACMIIAR_CR_MASK;
  /* Get hclk frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  14:	f7ff fffe 	bl	0 <RCC_GetClocksFreq>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:201
  hclk = rcc_clocks.HCLK_Frequency;
  18:	9a02      	ldr	r2, [sp, #8]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:203
  /* Set CR bits depending on hclk value */
  if((hclk >= 20000000)&&(hclk < 35000000))
  1a:	4b83      	ldr	r3, [pc, #524]	; (228 <ETH_Init+0x228>)
  1c:	4983      	ldr	r1, [pc, #524]	; (22c <ETH_Init+0x22c>)
  1e:	18d3      	adds	r3, r2, r3
  20:	428b      	cmp	r3, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:198
  /*-------------------------------- MAC Config ------------------------------*/   
  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Clear CSR Clock Range CR[2:0] bits */
  tmpreg &= MACMIIAR_CR_MASK;
  22:	f026 061c 	bic.w	r6, r6, #28
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:203
  /* Get hclk frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  hclk = rcc_clocks.HCLK_Frequency;
  /* Set CR bits depending on hclk value */
  if((hclk >= 20000000)&&(hclk < 35000000))
  26:	d802      	bhi.n	2e <ETH_Init+0x2e>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:206
  {
    /* CSR Clock Range between 20-35 MHz */
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
  28:	f046 0608 	orr.w	r6, r6, #8
  2c:	e006      	b.n	3c <ETH_Init+0x3c>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:208
  }
  else if((hclk >= 35000000)&&(hclk < 60000000))
  2e:	4b80      	ldr	r3, [pc, #512]	; (230 <ETH_Init+0x230>)
  30:	18d3      	adds	r3, r2, r3
  32:	4a80      	ldr	r2, [pc, #512]	; (234 <ETH_Init+0x234>)
  34:	4293      	cmp	r3, r2
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:211
  {
    /* CSR Clock Range between 35-60 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;    
  36:	bf98      	it	ls
  38:	f046 060c 	orrls.w	r6, r6, #12
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:219
  {
    /* CSR Clock Range between 60-72 MHz */   
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;    
  }
  /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
  ETH->MACMIIAR = (uint32_t)tmpreg;  
  3c:	4b79      	ldr	r3, [pc, #484]	; (224 <ETH_Init+0x224>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:222
  /*-------------------- PHY initialization and configuration ----------------*/
  /* Put the PHY in reset mode */
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
  3e:	4628      	mov	r0, r5
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:219
  {
    /* CSR Clock Range between 60-72 MHz */   
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;    
  }
  /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
  ETH->MACMIIAR = (uint32_t)tmpreg;  
  40:	611e      	str	r6, [r3, #16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:222
  /*-------------------- PHY initialization and configuration ----------------*/
  /* Put the PHY in reset mode */
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
  42:	2100      	movs	r1, #0
  44:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  48:	f7ff fffe 	bl	0 <ETH_Init>
  4c:	2800      	cmp	r0, #0
  4e:	f000 80e7 	beq.w	220 <ETH_Init+0x220>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:229
    /* Return ERROR in case of write timeout */
    return ETH_ERROR;
  }
  
  /* Delay to assure PHY reset */
  _eth_delay_(PHY_ResetDelay);
  52:	4879      	ldr	r0, [pc, #484]	; (1e8 <ETH_Init+0x1e8>)
  54:	f7ff fffe 	bl	0 <ETH_Init>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:232
  
    
  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
  58:	6821      	ldr	r1, [r4, #0]
  5a:	2900      	cmp	r1, #0
  5c:	d044      	beq.n	e8 <ETH_Init+0xe8>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:237
  {  
    /* We wait for linked satus... */
    do
    {
      timeout++;
  5e:	9b06      	ldr	r3, [sp, #24]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:238
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
  60:	2101      	movs	r1, #1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:237
  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
  {  
    /* We wait for linked satus... */
    do
    {
      timeout++;
  62:	3301      	adds	r3, #1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:238
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
  64:	4628      	mov	r0, r5
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:237
  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
  {  
    /* We wait for linked satus... */
    do
    {
      timeout++;
  66:	9306      	str	r3, [sp, #24]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:238
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
  68:	f7ff fffe 	bl	0 <ETH_Init>
  6c:	f010 0f04 	tst.w	r0, #4
  70:	d103      	bne.n	7a <ETH_Init+0x7a>
  72:	9a06      	ldr	r2, [sp, #24]
  74:	4b71      	ldr	r3, [pc, #452]	; (23c <ETH_Init+0x23c>)
  76:	429a      	cmp	r2, r3
  78:	d9f1      	bls.n	5e <ETH_Init+0x5e>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:240
    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
  7a:	9a06      	ldr	r2, [sp, #24]
  7c:	4b70      	ldr	r3, [pc, #448]	; (240 <ETH_Init+0x240>)
  7e:	2100      	movs	r1, #0
  80:	429a      	cmp	r2, r3
  82:	f000 80cc 	beq.w	21e <ETH_Init+0x21e>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:248
    }
    /* Reset Timeout counter */
    timeout = 0;
    
    /* Enable Auto-Negotiation */
    if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_AutoNegotiation)))
  86:	4628      	mov	r0, r5
  88:	f44f 5280 	mov.w	r2, #4096	; 0x1000
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:245
    if(timeout == PHY_READ_TO)
    {
      return ETH_ERROR;
    }
    /* Reset Timeout counter */
    timeout = 0;
  8c:	9106      	str	r1, [sp, #24]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:248
    
    /* Enable Auto-Negotiation */
    if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_AutoNegotiation)))
  8e:	f7ff fffe 	bl	0 <ETH_Init>
  92:	2800      	cmp	r0, #0
  94:	f000 80c4 	beq.w	220 <ETH_Init+0x220>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:257
    }
    
    /* Wait until the autonegotiation will be completed */
    do
    {
      timeout++;
  98:	9b06      	ldr	r3, [sp, #24]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:258
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
  9a:	2101      	movs	r1, #1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:257
    }
    
    /* Wait until the autonegotiation will be completed */
    do
    {
      timeout++;
  9c:	3301      	adds	r3, #1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:258
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
  9e:	4628      	mov	r0, r5
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:257
    }
    
    /* Wait until the autonegotiation will be completed */
    do
    {
      timeout++;
  a0:	9306      	str	r3, [sp, #24]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:258
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
  a2:	f7ff fffe 	bl	0 <ETH_Init>
  a6:	f010 0f20 	tst.w	r0, #32
  aa:	d103      	bne.n	b4 <ETH_Init+0xb4>
  ac:	9a06      	ldr	r2, [sp, #24]
  ae:	4b63      	ldr	r3, [pc, #396]	; (23c <ETH_Init+0x23c>)
  b0:	429a      	cmp	r2, r3
  b2:	d9f1      	bls.n	98 <ETH_Init+0x98>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:260
    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
  b4:	9a06      	ldr	r2, [sp, #24]
  b6:	4b62      	ldr	r3, [pc, #392]	; (240 <ETH_Init+0x240>)
  b8:	2000      	movs	r0, #0
  ba:	429a      	cmp	r2, r3
  bc:	f000 80b0 	beq.w	220 <ETH_Init+0x220>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:265
    {
      return ETH_ERROR;
    }
    /* Reset Timeout counter */
    timeout = 0;
  c0:	9006      	str	r0, [sp, #24]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:268
    
    /* Read the result of the autonegotiation */
    RegValue = ETH_ReadPHYRegister(PHYAddress, PHY_SR);
  c2:	2110      	movs	r1, #16
  c4:	4628      	mov	r0, r5
  c6:	f7ff fffe 	bl	0 <ETH_Init>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:271
  
    /* Configure the MAC with the Duplex Mode fixed by the autonegotiation process */
    if((RegValue & PHY_Duplex_Status) != (uint32_t)RESET)
  ca:	f010 0304 	ands.w	r3, r0, #4
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:274
    {
      /* Set Ethernet duplex mode to FullDuplex following the autonegotiation */
      ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;
  ce:	bf18      	it	ne
  d0:	f44f 6300 	movne.w	r3, #2048	; 0x800
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:283
    {
      /* Set Ethernet duplex mode to HalfDuplex following the autonegotiation */
      ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;           
    }
    /* Configure the MAC with the speed fixed by the autonegotiation process */
    if(RegValue & PHY_Speed_Status)
  d4:	f010 0f02 	tst.w	r0, #2
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:280
            
    }
    else
    {
      /* Set Ethernet duplex mode to HalfDuplex following the autonegotiation */
      ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;           
  d8:	6223      	str	r3, [r4, #32]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:283
    }
    /* Configure the MAC with the speed fixed by the autonegotiation process */
    if(RegValue & PHY_Speed_Status)
  da:	d001      	beq.n	e0 <ETH_Init+0xe0>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:286
    {  
      /* Set Ethernet speed to 10M following the autonegotiation */    
      ETH_InitStruct->ETH_Speed = ETH_Speed_10M; 
  dc:	2300      	movs	r3, #0
  de:	e001      	b.n	e4 <ETH_Init+0xe4>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:291
    }
    else
    {   
      /* Set Ethernet speed to 100M following the autonegotiation */ 
      ETH_InitStruct->ETH_Speed = ETH_Speed_100M;      
  e0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  e4:	6163      	str	r3, [r4, #20]
  e6:	e00f      	b.n	108 <ETH_Init+0x108>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:296
    }    
  }
  else
  {
    if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
  e8:	6a22      	ldr	r2, [r4, #32]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:297
                                                   (uint16_t)(ETH_InitStruct->ETH_Speed >> 1))))
  ea:	6963      	ldr	r3, [r4, #20]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:296
      ETH_InitStruct->ETH_Speed = ETH_Speed_100M;      
    }    
  }
  else
  {
    if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
  ec:	08d2      	lsrs	r2, r2, #3
  ee:	ea42 0253 	orr.w	r2, r2, r3, lsr #1
  f2:	4628      	mov	r0, r5
  f4:	b292      	uxth	r2, r2
  f6:	f7ff fffe 	bl	0 <ETH_Init>
  fa:	2800      	cmp	r0, #0
  fc:	f000 8090 	beq.w	220 <ETH_Init+0x220>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:303
    {
      /* Return ERROR in case of write timeout */
      return ETH_ERROR;
    }
    /* Delay to assure PHY configuration */
    _eth_delay_(PHY_ConfigDelay);
 100:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 104:	f7ff fffe 	bl	0 <ETH_Init>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:308
    
  }
  /*------------------------ ETHERNET MACCR Configuration --------------------*/
  /* Get the ETHERNET MACCR value */  
  tmpreg = ETH->MACCR;
 108:	4b46      	ldr	r3, [pc, #280]	; (224 <ETH_Init+0x224>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:310
  /* Clear WD, PCE, PS, TE and RE bits */
  tmpreg &= MACCR_CLEAR_MASK;
 10a:	4a4e      	ldr	r2, [pc, #312]	; (244 <ETH_Init+0x244>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:308
    _eth_delay_(PHY_ConfigDelay);
    
  }
  /*------------------------ ETHERNET MACCR Configuration --------------------*/
  /* Get the ETHERNET MACCR value */  
  tmpreg = ETH->MACCR;
 10c:	6819      	ldr	r1, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:324
  /* Set the IPC bit according to ETH_ChecksumOffload value */                   
  /* Set the DR bit according to ETH_RetryTransmission value */ 
  /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
  /* Set the BL bit according to ETH_BackOffLimit value */ 
  /* Set the DC bit according to ETH_DeferralCheck value */                          
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
 10e:	68a0      	ldr	r0, [r4, #8]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:310
  }
  /*------------------------ ETHERNET MACCR Configuration --------------------*/
  /* Get the ETHERNET MACCR value */  
  tmpreg = ETH->MACCR;
  /* Clear WD, PCE, PS, TE and RE bits */
  tmpreg &= MACCR_CLEAR_MASK;
 110:	ea01 0202 	and.w	r2, r1, r2
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:324
  /* Set the IPC bit according to ETH_ChecksumOffload value */                   
  /* Set the DR bit according to ETH_RetryTransmission value */ 
  /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
  /* Set the BL bit according to ETH_BackOffLimit value */ 
  /* Set the DC bit according to ETH_DeferralCheck value */                          
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
 114:	6861      	ldr	r1, [r4, #4]
 116:	ea40 0101 	orr.w	r1, r0, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:325
                  ETH_InitStruct->ETH_Jabber | 
 11a:	68e0      	ldr	r0, [r4, #12]
 11c:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:326
                  ETH_InitStruct->ETH_InterFrameGap |
 11e:	6920      	ldr	r0, [r4, #16]
 120:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:327
                  ETH_InitStruct->ETH_CarrierSense |
 122:	6960      	ldr	r0, [r4, #20]
 124:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:328
                  ETH_InitStruct->ETH_Speed | 
 126:	69a0      	ldr	r0, [r4, #24]
 128:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:329
                  ETH_InitStruct->ETH_ReceiveOwn |
 12a:	69e0      	ldr	r0, [r4, #28]
 12c:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:330
                  ETH_InitStruct->ETH_LoopbackMode |
 12e:	6a20      	ldr	r0, [r4, #32]
 130:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:331
                  ETH_InitStruct->ETH_Mode | 
 132:	6a60      	ldr	r0, [r4, #36]	; 0x24
 134:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:332
                  ETH_InitStruct->ETH_ChecksumOffload |    
 136:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 138:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:333
                  ETH_InitStruct->ETH_RetryTransmission | 
 13a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 13c:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:334
                  ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
 13e:	6b20      	ldr	r0, [r4, #48]	; 0x30
 140:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:324
  /* Set the IPC bit according to ETH_ChecksumOffload value */                   
  /* Set the DR bit according to ETH_RetryTransmission value */ 
  /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
  /* Set the BL bit according to ETH_BackOffLimit value */ 
  /* Set the DC bit according to ETH_DeferralCheck value */                          
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
 142:	6b60      	ldr	r0, [r4, #52]	; 0x34
 144:	4301      	orrs	r1, r0
 146:	ea41 0202 	orr.w	r2, r1, r2
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:338
                  ETH_InitStruct->ETH_RetryTransmission | 
                  ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
                  ETH_InitStruct->ETH_BackOffLimit | 
                  ETH_InitStruct->ETH_DeferralCheck);
  /* Write to ETHERNET MACCR */
  ETH->MACCR = (uint32_t)tmpreg;
 14a:	601a      	str	r2, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:350
  /* Set the DAIF bit according to ETH_DestinationAddrFilter value */
  /* Set the PR bit according to ETH_PromiscuousMode value */
  /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */  
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
 14c:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 14e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 150:	ea41 0202 	orr.w	r2, r1, r2
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:351
                          ETH_InitStruct->ETH_SourceAddrFilter |
 154:	6c21      	ldr	r1, [r4, #64]	; 0x40
 156:	430a      	orrs	r2, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:352
                          ETH_InitStruct->ETH_PassControlFrames |
 158:	6c61      	ldr	r1, [r4, #68]	; 0x44
 15a:	430a      	orrs	r2, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:353
                          ETH_InitStruct->ETH_BroadcastFramesReception | 
 15c:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 15e:	430a      	orrs	r2, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:354
                          ETH_InitStruct->ETH_DestinationAddrFilter |
 160:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 162:	430a      	orrs	r2, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:355
                          ETH_InitStruct->ETH_PromiscuousMode |
 164:	6d21      	ldr	r1, [r4, #80]	; 0x50
 166:	430a      	orrs	r2, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:350
  /* Set the DAIF bit according to ETH_DestinationAddrFilter value */
  /* Set the PR bit according to ETH_PromiscuousMode value */
  /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */  
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
 168:	6d61      	ldr	r1, [r4, #84]	; 0x54
 16a:	430a      	orrs	r2, r1
 16c:	605a      	str	r2, [r3, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:360
                          ETH_InitStruct->ETH_PromiscuousMode |
                          ETH_InitStruct->ETH_MulticastFramesFilter |
                          ETH_InitStruct->ETH_UnicastFramesFilter); 
  /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/
  /* Write to ETHERNET MACHTHR */
  ETH->MACHTHR = (uint32_t)ETH_InitStruct->ETH_HashTableHigh;
 16e:	6da2      	ldr	r2, [r4, #88]	; 0x58
 170:	609a      	str	r2, [r3, #8]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:362
  /* Write to ETHERNET MACHTLR */
  ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
 172:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 174:	60da      	str	r2, [r3, #12]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:375
  /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
  /* Set the PLT bit according to ETH_PauseLowThreshold value */
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
 176:	6e62      	ldr	r2, [r4, #100]	; 0x64
 178:	6ea1      	ldr	r1, [r4, #104]	; 0x68
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:365
  ETH->MACHTHR = (uint32_t)ETH_InitStruct->ETH_HashTableHigh;
  /* Write to ETHERNET MACHTLR */
  ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
  /*----------------------- ETHERNET MACFCR Configuration --------------------*/
  /* Get the ETHERNET MACFCR value */  
  tmpreg = ETH->MACFCR;
 17a:	6998      	ldr	r0, [r3, #24]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:375
  /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
  /* Set the PLT bit according to ETH_PauseLowThreshold value */
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
 17c:	4311      	orrs	r1, r2
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:376
                   ETH_InitStruct->ETH_ZeroQuantaPause |
 17e:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:378
                   ETH_InitStruct->ETH_PauseLowThreshold |
                   ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
 180:	6f65      	ldr	r5, [r4, #116]	; 0x74
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:376
  /* Set the PLT bit according to ETH_PauseLowThreshold value */
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
                   ETH_InitStruct->ETH_ZeroQuantaPause |
 182:	4311      	orrs	r1, r2
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:377
                   ETH_InitStruct->ETH_PauseLowThreshold |
 184:	6f22      	ldr	r2, [r4, #112]	; 0x70
 186:	4311      	orrs	r1, r2
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:367
  ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
  /*----------------------- ETHERNET MACFCR Configuration --------------------*/
  /* Get the ETHERNET MACFCR value */  
  tmpreg = ETH->MACFCR;
  /* Clear xx bits */
  tmpreg &= MACFCR_CLEAR_MASK;
 188:	f64f 7241 	movw	r2, #65345	; 0xff41
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:378
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
                   ETH_InitStruct->ETH_ZeroQuantaPause |
                   ETH_InitStruct->ETH_PauseLowThreshold |
                   ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
 18c:	4329      	orrs	r1, r5
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:367
  ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
  /*----------------------- ETHERNET MACFCR Configuration --------------------*/
  /* Get the ETHERNET MACFCR value */  
  tmpreg = ETH->MACFCR;
  /* Clear xx bits */
  tmpreg &= MACFCR_CLEAR_MASK;
 18e:	ea00 0202 	and.w	r2, r0, r2
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:375
  /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
  /* Set the PLT bit according to ETH_PauseLowThreshold value */
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
 192:	ea41 0202 	orr.w	r2, r1, r2
 196:	6e21      	ldr	r1, [r4, #96]	; 0x60
 198:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:382
                   ETH_InitStruct->ETH_PauseLowThreshold |
                   ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
                   ETH_InitStruct->ETH_ReceiveFlowControl |
                   ETH_InitStruct->ETH_TransmitFlowControl); 
  /* Write to ETHERNET MACFCR */
  ETH->MACFCR = (uint32_t)tmpreg;
 19c:	619a      	str	r2, [r3, #24]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:386
  /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
  /* Set the ETV bit according to ETH_VLANTagComparison value */
  /* Set the VL bit according to ETH_VLANTagIdentifier value */  
  ETH->MACVLANTR = (uint32_t)(ETH_InitStruct->ETH_VLANTagComparison | 
 19e:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 1a0:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 1a2:	ea41 0202 	orr.w	r2, r1, r2
 1a6:	61da      	str	r2, [r3, #28]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:392
                             ETH_InitStruct->ETH_VLANTagIdentifier); 
       
  /*-------------------------------- DMA Config ------------------------------*/
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
  /* Get the ETHERNET DMAOMR value */  
  tmpreg = ETH->DMAOMR;
 1a8:	4a27      	ldr	r2, [pc, #156]	; (248 <ETH_Init+0x248>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:394
  /* Clear xx bits */
  tmpreg &= DMAOMR_CLEAR_MASK;
 1aa:	4b28      	ldr	r3, [pc, #160]	; (24c <ETH_Init+0x24c>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:392
                             ETH_InitStruct->ETH_VLANTagIdentifier); 
       
  /*-------------------------------- DMA Config ------------------------------*/
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
  /* Get the ETHERNET DMAOMR value */  
  tmpreg = ETH->DMAOMR;
 1ac:	6811      	ldr	r1, [r2, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:405
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 1ae:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:394
  /*-------------------------------- DMA Config ------------------------------*/
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
  /* Get the ETHERNET DMAOMR value */  
  tmpreg = ETH->DMAOMR;
  /* Clear xx bits */
  tmpreg &= DMAOMR_CLEAR_MASK;
 1b2:	ea01 0303 	and.w	r3, r1, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:405
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 1b6:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
 1ba:	ea40 0101 	orr.w	r1, r0, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:406
                  ETH_InitStruct->ETH_ReceiveStoreForward |
 1be:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 1c2:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:407
                  ETH_InitStruct->ETH_FlushReceivedFrame |
 1c4:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 1c8:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:408
                  ETH_InitStruct->ETH_TransmitStoreForward | 
 1ca:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
 1ce:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:409
                  ETH_InitStruct->ETH_TransmitThresholdControl |
 1d0:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
 1d4:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:410
                  ETH_InitStruct->ETH_ForwardErrorFrames |
 1d6:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
 1da:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:411
                  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
 1dc:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
 1e0:	4301      	orrs	r1, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:405
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 1e2:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
 1e6:	4301      	orrs	r1, r0
 1e8:	ea41 0303 	orr.w	r3, r1, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:415
                  ETH_InitStruct->ETH_ForwardErrorFrames |
                  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
                  ETH_InitStruct->ETH_ReceiveThresholdControl |                                   
                  ETH_InitStruct->ETH_SecondFrameOperate); 
  /* Write to ETHERNET DMAOMR */
  ETH->DMAOMR = (uint32_t)tmpreg;
 1ec:	6013      	str	r3, [r2, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:424
  /* Set the FB bit according to ETH_FixedBurst value */
  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
 1ee:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 1f2:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:432
                          ETH_InitStruct->ETH_TxDMABurstLength | 
                         (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
                          ETH_InitStruct->ETH_DMAArbitration |
                          ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */  
  /* Return Ethernet configuration success */
  return ETH_SUCCESS;
 1f6:	2001      	movs	r0, #1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:424
  /* Set the FB bit according to ETH_FixedBurst value */
  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
 1f8:	431a      	orrs	r2, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:426
                          ETH_InitStruct->ETH_FixedBurst |
                          ETH_InitStruct->ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
 1fa:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:425
  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
                          ETH_InitStruct->ETH_FixedBurst |
 1fe:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:426
                          ETH_InitStruct->ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
 202:	431a      	orrs	r2, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:427
                          ETH_InitStruct->ETH_TxDMABurstLength | 
 204:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 208:	431a      	orrs	r2, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:428
                         (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
 20a:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
 20e:	431a      	orrs	r2, r3
 210:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:424
  /* Set the FB bit according to ETH_FixedBurst value */
  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
 214:	ea42 0283 	orr.w	r2, r2, r3, lsl #2
 218:	4b0d      	ldr	r3, [pc, #52]	; (250 <ETH_Init+0x250>)
 21a:	601a      	str	r2, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:432
                          ETH_InitStruct->ETH_TxDMABurstLength | 
                         (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
                          ETH_InitStruct->ETH_DMAArbitration |
                          ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */  
  /* Return Ethernet configuration success */
  return ETH_SUCCESS;
 21c:	e000      	b.n	220 <ETH_Init+0x220>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:242
      timeout++;
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
    {
      return ETH_ERROR;
 21e:	4608      	mov	r0, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:433
                         (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
                          ETH_InitStruct->ETH_DMAArbitration |
                          ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */  
  /* Return Ethernet configuration success */
  return ETH_SUCCESS;
}
 220:	b008      	add	sp, #32
 222:	bd70      	pop	{r4, r5, r6, pc}
 224:	40028000 	.word	0x40028000
 228:	feced300 	.word	0xfeced300
 22c:	00e4e1bf 	.word	0x00e4e1bf
 230:	fde9f140 	.word	0xfde9f140
 234:	017d783f 	.word	0x017d783f
 238:	000fffff 	.word	0x000fffff
 23c:	0004fffe 	.word	0x0004fffe
 240:	0004ffff 	.word	0x0004ffff
 244:	ff20810f 	.word	0xff20810f
 248:	40029018 	.word	0x40029018
 24c:	f8de3f23 	.word	0xf8de3f23
 250:	40029000 	.word	0x40029000

Disassembly of section .text.ETH_PHYLoopBackCmd:

00000000 <ETH_PHYLoopBackCmd>:
ETH_PHYLoopBackCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:809
  *   This parameter can be: ENABLE or DISABLE.    
  * @retval ETH_ERROR: in case of bad PHY configuration
  *         ETH_SUCCESS: for correct PHY configuration
  */
uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460d      	mov	r5, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:816
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  /* Get the PHY configuration to update it */
  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); 
   4:	2100      	movs	r1, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:809
  *   This parameter can be: ENABLE or DISABLE.    
  * @retval ETH_ERROR: in case of bad PHY configuration
  *         ETH_SUCCESS: for correct PHY configuration
  */
uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState)
{
   6:	4604      	mov	r4, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:816
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  /* Get the PHY configuration to update it */
  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); 
   8:	f7ff fffe 	bl	0 <ETH_PHYLoopBackCmd>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:818
  
  if (NewState != DISABLE)
   c:	b11d      	cbz	r5, 16 <ETH_PHYLoopBackCmd+0x16>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:821
  {
    /* Enable the PHY loopback mode */
    tmpreg |= PHY_Loopback;  
   e:	f440 4280 	orr.w	r2, r0, #16384	; 0x4000
  12:	b292      	uxth	r2, r2
  14:	e003      	b.n	1e <ETH_PHYLoopBackCmd+0x1e>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:826
  }
  else
  {
    /* Disable the PHY loopback mode: normal mode */
    tmpreg &= (uint16_t)(~(uint16_t)PHY_Loopback);
  16:	f64b 72ff 	movw	r2, #49151	; 0xbfff
  1a:	ea00 0202 	and.w	r2, r0, r2
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:829
  }
  /* Update the PHY control register with the new configuration */
  if(ETH_WritePHYRegister(PHYAddress, PHY_BCR, tmpreg) != (uint32_t)RESET)
  1e:	2100      	movs	r1, #0
  20:	4620      	mov	r0, r4
  22:	f7ff fffe 	bl	0 <ETH_PHYLoopBackCmd>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:838
  else
  {
    /* Return SUCCESS */
    return ETH_ERROR; 
  }   
}
  26:	3800      	subs	r0, #0
  28:	bf18      	it	ne
  2a:	2001      	movne	r0, #1
  2c:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.ETH_MACTransmissionCmd:

00000000 <ETH_MACTransmissionCmd>:
ETH_MACTransmissionCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:848
  * @param  NewState: new state of the MAC transmission.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACTransmissionCmd(FunctionalState NewState)
{ 
   0:	4b05      	ldr	r3, [pc, #20]	; (18 <ETH_MACTransmissionCmd+0x18>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:852
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b118      	cbz	r0, c <ETH_MACTransmissionCmd+0xc>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:855
  {
    /* Enable the MAC transmission */
    ETH->MACCR |= ETH_MACCR_TE;  
   4:	681a      	ldr	r2, [r3, #0]
   6:	f042 0208 	orr.w	r2, r2, #8
   a:	e002      	b.n	12 <ETH_MACTransmissionCmd+0x12>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:860
  }
  else
  {
    /* Disable the MAC transmission */
    ETH->MACCR &= ~ETH_MACCR_TE;
   c:	681a      	ldr	r2, [r3, #0]
   e:	f022 0208 	bic.w	r2, r2, #8
  12:	601a      	str	r2, [r3, #0]
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_MACReceptionCmd:

00000000 <ETH_MACReceptionCmd>:
ETH_MACReceptionCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:871
  * @param  NewState: new state of the MAC reception.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACReceptionCmd(FunctionalState NewState)
{ 
   0:	4b05      	ldr	r3, [pc, #20]	; (18 <ETH_MACReceptionCmd+0x18>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:875
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b118      	cbz	r0, c <ETH_MACReceptionCmd+0xc>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:878
  {
    /* Enable the MAC reception */
    ETH->MACCR |= ETH_MACCR_RE;  
   4:	681a      	ldr	r2, [r3, #0]
   6:	f042 0204 	orr.w	r2, r2, #4
   a:	e002      	b.n	12 <ETH_MACReceptionCmd+0x12>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:883
  }
  else
  {
    /* Disable the MAC reception */
    ETH->MACCR &= ~ETH_MACCR_RE;
   c:	681a      	ldr	r2, [r3, #0]
   e:	f022 0204 	bic.w	r2, r2, #4
  12:	601a      	str	r2, [r3, #0]
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_GetFlowControlBusyStatus:

00000000 <ETH_GetFlowControlBusyStatus>:
ETH_GetFlowControlBusyStatus():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:896
  */
FlagStatus ETH_GetFlowControlBusyStatus(void)
{
  FlagStatus bitstatus = RESET;
  /* The Flow Control register should not be written to until this bit is cleared */
  if ((ETH->MACFCR & ETH_MACFCR_FCBBPA) != (uint32_t)RESET)
   0:	69984b02 	.word	0x69984b02
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:905
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   4:	f000 0001 	and.w	r0, r0, #1
   8:	4770      	bx	lr
   a:	bf00      	nop
   c:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_InitiatePauseControlFrame:

00000000 <ETH_InitiatePauseControlFrame>:
ETH_InitiatePauseControlFrame():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:915
  * @retval None
  */
void ETH_InitiatePauseControlFrame(void)  
{ 
  /* When Set In full duplex MAC initiates pause control frame */
  ETH->MACFCR |= ETH_MACFCR_FCBBPA;  
   0:	4b02      	ldr	r3, [pc, #8]	; (c <ETH_InitiatePauseControlFrame+0xc>)
   2:	699a      	ldr	r2, [r3, #24]
   4:	f042 0201 	orr.w	r2, r2, #1
   8:	619a      	str	r2, [r3, #24]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:916
}
   a:	4770      	bx	lr
   c:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_BackPressureActivationCmd:

00000000 <ETH_BackPressureActivationCmd>:
ETH_BackPressureActivationCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:925
  * @param  NewState: new state of the MAC BackPressure operation activation.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_BackPressureActivationCmd(FunctionalState NewState)   
{ 
   0:	4b05      	ldr	r3, [pc, #20]	; (18 <ETH_BackPressureActivationCmd+0x18>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:929
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
   2:	b118      	cbz	r0, c <ETH_BackPressureActivationCmd+0xc>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:934
  {
    /* Activate the MAC BackPressure operation */
    /* In Half duplex: during backpressure, when the MAC receives a new frame,
    the transmitter starts sending a JAM pattern resulting in a collision */
    ETH->MACFCR |= ETH_MACFCR_FCBBPA; 
   4:	699a      	ldr	r2, [r3, #24]
   6:	f042 0201 	orr.w	r2, r2, #1
   a:	e002      	b.n	12 <ETH_BackPressureActivationCmd+0x12>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:939
  }
  else
  {
    /* Desactivate the MAC BackPressure operation */
    ETH->MACFCR &= ~ETH_MACFCR_FCBBPA; 
   c:	699a      	ldr	r2, [r3, #24]
   e:	f022 0201 	bic.w	r2, r2, #1
  12:	619a      	str	r2, [r3, #24]
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_GetMACFlagStatus:

00000000 <ETH_GetMACFlagStatus>:
ETH_GetMACFlagStatus():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:959
FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_GET_FLAG(ETH_MAC_FLAG)); 
  if ((ETH->MACSR & ETH_MAC_FLAG) != (uint32_t)RESET)
   0:	6b9b4b03 	.word	0x6b9b4b03
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:961
  {
    bitstatus = SET;
   4:	4218      	tst	r0, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:968
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   6:	bf0c      	ite	eq
   8:	2000      	moveq	r0, #0
   a:	2001      	movne	r0, #1
   c:	4770      	bx	lr
   e:	bf00      	nop
  10:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_GetMACITStatus:

00000000 <ETH_GetMACITStatus>:
ETH_GetMACITStatus():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:986
ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT)
{
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_GET_IT(ETH_MAC_IT)); 
  if ((ETH->MACSR & ETH_MAC_IT) != (uint32_t)RESET)
   0:	4b03      	ldr	r3, [pc, #12]	; (10 <ETH_GetMACITStatus+0x10>)
   2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:988
  {
    bitstatus = SET;
   4:	4218      	tst	r0, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:995
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   6:	bf0c      	ite	eq
   8:	2000      	moveq	r0, #0
   a:	2001      	movne	r0, #1
   c:	4770      	bx	lr
   e:	bf00      	nop
  10:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_MACITConfig:

00000000 <ETH_MACITConfig>:
ETH_MACITConfig():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1009
  * @param  NewState: new state of the specified ETHERNET MAC interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState)
{
   0:	4b04      	ldr	r3, [pc, #16]	; (14 <ETH_MACITConfig+0x14>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1014
  /* Check the parameters */
  assert_param(IS_ETH_MAC_IT(ETH_MAC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
   2:	b119      	cbz	r1, c <ETH_MACITConfig+0xc>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1017
  {
    /* Enable the selected ETHERNET MAC interrupts */
    ETH->MACIMR &= (~(uint32_t)ETH_MAC_IT);
   4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   6:	ea22 0000 	bic.w	r0, r2, r0
   a:	e001      	b.n	10 <ETH_MACITConfig+0x10>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1022
  }
  else
  {
    /* Disable the selected ETHERNET MAC interrupts */
    ETH->MACIMR |= ETH_MAC_IT;
   c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   e:	4310      	orrs	r0, r2
  10:	63d8      	str	r0, [r3, #60]	; 0x3c
  12:	4770      	bx	lr
  14:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_MACAddressConfig:

00000000 <ETH_MACAddressConfig>:
ETH_MACAddressConfig():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1044
  uint32_t tmpreg;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Calculate the selectecd MAC address high register */
  tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
   0:	790b      	ldrb	r3, [r1, #4]
   2:	794a      	ldrb	r2, [r1, #5]
   4:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1046
  /* Load the selectecd MAC address high register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
   8:	4b07      	ldr	r3, [pc, #28]	; (28 <ETH_MACAddressConfig+0x28>)
   a:	50c2      	str	r2, [r0, r3]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1048
  /* Calculate the selectecd MAC address low register */
  tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
   c:	788a      	ldrb	r2, [r1, #2]
   e:	78cb      	ldrb	r3, [r1, #3]
  10:	0412      	lsls	r2, r2, #16
  12:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
  16:	780b      	ldrb	r3, [r1, #0]
  18:	431a      	orrs	r2, r3
  1a:	784b      	ldrb	r3, [r1, #1]
  1c:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1051
 
  /* Load the selectecd MAC address low register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;
  20:	4b02      	ldr	r3, [pc, #8]	; (2c <ETH_MACAddressConfig+0x2c>)
  22:	50c2      	str	r2, [r0, r3]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1052
}
  24:	4770      	bx	lr
  26:	bf00      	nop
  28:	40028040 	.word	0x40028040
  2c:	40028044 	.word	0x40028044

Disassembly of section .text.ETH_GetMACAddress:

00000000 <ETH_GetMACAddress>:
ETH_GetMACAddress():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1072
  uint32_t tmpreg;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Get the selectecd MAC address high register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
   0:	58c34b07 	.word	0x58c34b07
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1075
 
  /* Calculate the selectecd MAC address buffer */
  Addr[5] = ((tmpreg >> 8) & (uint8_t)0xFF);
   4:	0a1a      	lsrs	r2, r3, #8
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1076
  Addr[4] = (tmpreg & (uint8_t)0xFF);
   6:	710b      	strb	r3, [r1, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1078
  /* Load the selectecd MAC address low register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
   8:	4b06      	ldr	r3, [pc, #24]	; (24 <ETH_GetMACAddress+0x24>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1075
  
  /* Get the selectecd MAC address high register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
 
  /* Calculate the selectecd MAC address buffer */
  Addr[5] = ((tmpreg >> 8) & (uint8_t)0xFF);
   a:	714a      	strb	r2, [r1, #5]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1078
  Addr[4] = (tmpreg & (uint8_t)0xFF);
  /* Load the selectecd MAC address low register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
   c:	58c3      	ldr	r3, [r0, r3]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1080
  /* Calculate the selectecd MAC address buffer */
  Addr[3] = ((tmpreg >> 24) & (uint8_t)0xFF);
   e:	0e1a      	lsrs	r2, r3, #24
  10:	70ca      	strb	r2, [r1, #3]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1081
  Addr[2] = ((tmpreg >> 16) & (uint8_t)0xFF);
  12:	0c1a      	lsrs	r2, r3, #16
  14:	708a      	strb	r2, [r1, #2]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1082
  Addr[1] = ((tmpreg >> 8 ) & (uint8_t)0xFF);
  16:	0a1a      	lsrs	r2, r3, #8
  18:	704a      	strb	r2, [r1, #1]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1083
  Addr[0] = (tmpreg & (uint8_t)0xFF);
  1a:	700b      	strb	r3, [r1, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1084
}
  1c:	4770      	bx	lr
  1e:	bf00      	nop
  20:	40028040 	.word	0x40028040
  24:	40028044 	.word	0x40028044

Disassembly of section .text.ETH_MACAddressPerfectFilterCmd:

00000000 <ETH_MACAddressPerfectFilterCmd>:
ETH_MACAddressPerfectFilterCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1099
  * @param  NewState: new state of the specified ETHERNET MAC address use.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState)
{
   0:	b1194b05 	.word	0xb1194b05
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1107
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
  {
    /* Enable the selected ETHERNET MAC address for perfect filtering */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE;
   4:	58c2      	ldr	r2, [r0, r3]
   6:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
   a:	e002      	b.n	12 <ETH_MACAddressPerfectFilterCmd+0x12>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1112
  }
  else
  {
    /* Disable the selected ETHERNET MAC address for perfect filtering */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_AE);
   c:	58c2      	ldr	r2, [r0, r3]
   e:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
  12:	50c2      	str	r2, [r0, r3]
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	40028040 	.word	0x40028040

Disassembly of section .text.ETH_MACAddressFilterConfig:

00000000 <ETH_MACAddressFilterConfig>:
ETH_MACAddressFilterConfig():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1132
  *     @arg ETH_MAC_AddressFilter_DA : MAC Address is used to compare with the
  *                                     DA fields of the received frame.
  * @retval None
  */
void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter)
{
   0:	29084b04 	.word	0x29084b04
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1141
  
  if (Filter != ETH_MAC_AddressFilter_DA)
  {
    /* The selected ETHERNET MAC address is used to compare with the SA fields of the
       received frame. */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA;
   4:	58c2      	ldr	r2, [r0, r3]
   6:	bf14      	ite	ne
   8:	f042 4280 	orrne.w	r2, r2, #1073741824	; 0x40000000
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1147
  }
  else
  {
    /* The selected ETHERNET MAC address is used to compare with the DA fields of the
       received frame. */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_SA);
   c:	f022 4280 	biceq.w	r2, r2, #1073741824	; 0x40000000
  10:	50c2      	str	r2, [r0, r3]
  12:	4770      	bx	lr
  14:	40028040 	.word	0x40028040

Disassembly of section .text.ETH_MACAddressMaskBytesFilterConfig:

00000000 <ETH_MACAddressMaskBytesFilterConfig>:
ETH_MACAddressMaskBytesFilterConfig():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1175
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
  assert_param(IS_ETH_MAC_ADDRESS_MASK(MaskByte));
  
  /* Clear MBC bits in the selected MAC address  high register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_MBC);
   0:	4b04      	ldr	r3, [pc, #16]	; (14 <ETH_MACAddressMaskBytesFilterConfig+0x14>)
   2:	58c2      	ldr	r2, [r0, r3]
   4:	f022 527c 	bic.w	r2, r2, #1056964608	; 0x3f000000
   8:	50c2      	str	r2, [r0, r3]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1177
  /* Set the selected Filetr mask bytes */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= MaskByte;
   a:	58c2      	ldr	r2, [r0, r3]
   c:	430a      	orrs	r2, r1
   e:	50c2      	str	r2, [r0, r3]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1178
}
  10:	4770      	bx	lr
  12:	bf00      	nop
  14:	40028040 	.word	0x40028040

Disassembly of section .text.ETH_DMATxDescChainInit:

00000000 <ETH_DMATxDescChainInit>:
ETH_DMATxDescChainInit():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1194
{
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
   0:	4b0e      	ldr	r3, [pc, #56]	; (3c <ETH_DMATxDescChainInit+0x3c>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1189
  * @param  TxBuff: Pointer on the first TxBuffer list
  * @param  TxBuffCount: Number of the used Tx desc in the list
  * @retval None
  */
void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount)
{
   2:	b530      	push	{r4, r5, lr}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1194
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
   4:	6018      	str	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1196
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
   6:	2400      	movs	r4, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1188
  * @param  DMATxDescTab: Pointer on the first Tx desc list 
  * @param  TxBuff: Pointer on the first TxBuffer list
  * @param  TxBuffCount: Number of the used Tx desc in the list
  * @retval None
  */
void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount)
   8:	f100 0310 	add.w	r3, r0, #16
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1196
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
   c:	e010      	b.n	30 <ETH_DMATxDescChainInit+0x30>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1201
  {
    /* Get the pointer on the ith member of the Tx Desc list */
    DMATxDesc = DMATxDescTab + i;
    /* Set Second Address Chained bit */
    DMATxDesc->Status = ETH_DMATxDesc_TCH;  
   e:	f44f 1580 	mov.w	r5, #1048576	; 0x100000
  12:	f843 5c10 	str.w	r5, [r3, #-16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1207
       
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_MAX_PACKET_SIZE]);
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (TxBuffCount-1))
  16:	1e55      	subs	r5, r2, #1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1210
    {
      /* Set next descriptor address register with next descriptor base address */
      DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
  18:	42ac      	cmp	r4, r5
  1a:	bf2c      	ite	cs
  1c:	4605      	movcs	r5, r0
  1e:	461d      	movcc	r5, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1204
    DMATxDesc = DMATxDescTab + i;
    /* Set Second Address Chained bit */
    DMATxDesc->Status = ETH_DMATxDesc_TCH;  
       
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_MAX_PACKET_SIZE]);
  20:	f843 1c08 	str.w	r1, [r3, #-8]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1210
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (TxBuffCount-1))
    {
      /* Set next descriptor address register with next descriptor base address */
      DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
  24:	f843 5c04 	str.w	r5, [r3, #-4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1196
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
  28:	3401      	adds	r4, #1
  2a:	3310      	adds	r3, #16
  2c:	f501 61be 	add.w	r1, r1, #1520	; 0x5f0
  30:	4294      	cmp	r4, r2
  32:	d3ec      	bcc.n	e <ETH_DMATxDescChainInit+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1220
      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
    }
  }
   
  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR = (uint32_t) DMATxDescTab;
  34:	4b02      	ldr	r3, [pc, #8]	; (40 <ETH_DMATxDescChainInit+0x40>)
  36:	6018      	str	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1221
}
  38:	bd30      	pop	{r4, r5, pc}
  3a:	bf00      	nop
  3c:	00000000 	.word	0x00000000
  40:	40029010 	.word	0x40029010

Disassembly of section .text.ETH_DMATxDescRingInit:

00000000 <ETH_DMATxDescRingInit>:
ETH_DMATxDescRingInit():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1234
  *   Note: see decriptor skip length defined in ETH_DMA_InitStruct
  *   for the number of Words to skip between two unchained descriptors.  
  * @retval None
  */
void ETH_DMATxDescRingInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t *TxBuff1, uint8_t *TxBuff2, uint32_t TxBuffCount)
{
   0:	4c0cb570 	.word	0x4c0cb570
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1241
  ETH_DMADESCTypeDef *DMATxDesc;
 
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */  
  for(i=0; i < TxBuffCount; i++)
   4:	2500      	movs	r5, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1239
{
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
 
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
   6:	6020      	str	r0, [r4, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1241
  /* Fill each DMATxDesc descriptor with the right values */  
  for(i=0; i < TxBuffCount; i++)
   8:	4604      	mov	r4, r0
   a:	e00e      	b.n	2a <ETH_DMATxDescRingInit+0x2a>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1253
    /* Set Buffer2 address pointer */
    DMATxDesc->Buffer2NextDescAddr = (uint32_t)(&TxBuff2[i*ETH_MAX_PACKET_SIZE]);
    
    /* Set Transmit End of Ring bit for last descriptor: The DMA returns to the base
       address of the list, creating a Desciptor Ring */
    if(i == (TxBuffCount-1))
   c:	1e5e      	subs	r6, r3, #1
   e:	42b5      	cmp	r5, r6
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1256
    {
      /* Set Transmit End of Ring bit */
      DMATxDesc->Status = ETH_DMATxDesc_TER;
  10:	bf08      	it	eq
  12:	f44f 1600 	moveq.w	r6, #2097152	; 0x200000
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1246
  for(i=0; i < TxBuffCount; i++)
  {
    /* Get the pointer on the ith member of the Tx Desc list */
    DMATxDesc = DMATxDescTab + i;
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff1[i*ETH_MAX_PACKET_SIZE]);
  16:	60a1      	str	r1, [r4, #8]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1249
    
    /* Set Buffer2 address pointer */
    DMATxDesc->Buffer2NextDescAddr = (uint32_t)(&TxBuff2[i*ETH_MAX_PACKET_SIZE]);
  18:	60e2      	str	r2, [r4, #12]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1256
    /* Set Transmit End of Ring bit for last descriptor: The DMA returns to the base
       address of the list, creating a Desciptor Ring */
    if(i == (TxBuffCount-1))
    {
      /* Set Transmit End of Ring bit */
      DMATxDesc->Status = ETH_DMATxDesc_TER;
  1a:	bf08      	it	eq
  1c:	6026      	streq	r6, [r4, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1241
  ETH_DMADESCTypeDef *DMATxDesc;
 
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */  
  for(i=0; i < TxBuffCount; i++)
  1e:	f501 61be 	add.w	r1, r1, #1520	; 0x5f0
  22:	3501      	adds	r5, #1
  24:	3410      	adds	r4, #16
  26:	f502 62be 	add.w	r2, r2, #1520	; 0x5f0
  2a:	429d      	cmp	r5, r3
  2c:	d3ee      	bcc.n	c <ETH_DMATxDescRingInit+0xc>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1261
      DMATxDesc->Status = ETH_DMATxDesc_TER;
    }
  }
   
  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR =  (uint32_t) DMATxDescTab;
  2e:	4b02      	ldr	r3, [pc, #8]	; (38 <ETH_DMATxDescRingInit+0x38>)
  30:	6018      	str	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1262
}
  32:	bd70      	pop	{r4, r5, r6, pc}
  34:	00000000 	.word	0x00000000
  38:	40029010 	.word	0x40029010

Disassembly of section .text.ETH_GetDMATxDescFlagStatus:

00000000 <ETH_GetDMATxDescFlagStatus>:
ETH_GetDMATxDescFlagStatus():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1301
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_DMATxDESC_GET_FLAG(ETH_DMATxDescFlag));
  
  if ((DMATxDesc->Status & ETH_DMATxDescFlag) != (uint32_t)RESET)
   0:	6803      	ldr	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1303
  {
    bitstatus = SET;
   2:	4219      	tst	r1, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1310
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   4:	bf0c      	ite	eq
   6:	2000      	moveq	r0, #0
   8:	2001      	movne	r0, #1
   a:	4770      	bx	lr

Disassembly of section .text.ETH_GetDMATxDescCollisionCount:

00000000 <ETH_GetDMATxDescCollisionCount>:
ETH_GetDMATxDescCollisionCount():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1320
  * @retval The Transmit descriptor collision counter value.
  */
uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc)
{
  /* Return the Receive descriptor frame length */
  return ((DMATxDesc->Status & ETH_DMATxDesc_CC) >> ETH_DMATXDESC_COLLISION_COUNTSHIFT);
   0:	6800      	ldr	r0, [r0, #0]
   2:	f000 0078 	and.w	r0, r0, #120	; 0x78
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1321
}
   6:	08c0      	lsrs	r0, r0, #3
   8:	4770      	bx	lr

Disassembly of section .text.ETH_SetDMATxDescOwnBit:

00000000 <ETH_SetDMATxDescOwnBit>:
ETH_SetDMATxDescOwnBit():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1331
  * @retval None
  */
void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc)
{
  /* Set the DMA Tx Desc Own bit */
  DMATxDesc->Status |= ETH_DMATxDesc_OWN;
   0:	6803      	ldr	r3, [r0, #0]
   2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   6:	6003      	str	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1332
}
   8:	4770      	bx	lr

Disassembly of section .text.ETH_DMATxDescTransmitITConfig:

00000000 <ETH_DMATxDescTransmitITConfig>:
ETH_DMATxDescTransmitITConfig():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1342
  * @param  NewState: new state of the DMA Tx Desc transmit interrupt.
  *   This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
   0:	6803      	ldr	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1346
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, a <ETH_DMATxDescTransmitITConfig+0xa>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1349
  {
    /* Enable the DMA Tx Desc Transmit interrupt */
    DMATxDesc->Status |= ETH_DMATxDesc_IC;
   4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   8:	e001      	b.n	e <ETH_DMATxDescTransmitITConfig+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1354
  }
  else
  {
    /* Disable the DMA Tx Desc Transmit interrupt */
    DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_IC);
   a:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
   e:	6003      	str	r3, [r0, #0]
  10:	4770      	bx	lr

Disassembly of section .text.ETH_DMATxDescFrameSegmentConfig:

00000000 <ETH_DMATxDescFrameSegmentConfig>:
ETH_DMATxDescFrameSegmentConfig():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1373
{
  /* Check the parameters */
  assert_param(IS_ETH_DMA_TXDESC_SEGMENT(DMATxDesc_FrameSegment));
  
  /* Selects the DMA Tx Desc Frame segment */
  DMATxDesc->Status |= DMATxDesc_FrameSegment;
   0:	6803      	ldr	r3, [r0, #0]
   2:	430b      	orrs	r3, r1
   4:	6003      	str	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1374
}
   6:	4770      	bx	lr

Disassembly of section .text.ETH_DMATxDescChecksumInsertionConfig:

00000000 <ETH_DMATxDescChecksumInsertionConfig>:
ETH_DMATxDescChecksumInsertionConfig():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1393
{
  /* Check the parameters */
  assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum));
  
  /* Set the selected DMA Tx desc checksum insertion control */
  DMATxDesc->Status |= DMATxDesc_Checksum;
   0:	6803      	ldr	r3, [r0, #0]
   2:	430b      	orrs	r3, r1
   4:	6003      	str	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1394
}
   6:	4770      	bx	lr

Disassembly of section .text.ETH_DMATxDescCRCCmd:

00000000 <ETH_DMATxDescCRCCmd>:
ETH_DMATxDescCRCCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1404
  * @param  NewState: new state of the specified DMA Tx Desc CRC.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
   0:	6803      	ldr	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1408
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, a <ETH_DMATxDescCRCCmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1411
  {
    /* Enable the selected DMA Tx Desc CRC */
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DC);
   4:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
   8:	e001      	b.n	e <ETH_DMATxDescCRCCmd+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1416
  }
  else
  {
    /* Disable the selected DMA Tx Desc CRC */
    DMATxDesc->Status |= ETH_DMATxDesc_DC; 
   a:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   e:	6003      	str	r3, [r0, #0]
  10:	4770      	bx	lr

Disassembly of section .text.ETH_DMATxDescEndOfRingCmd:

00000000 <ETH_DMATxDescEndOfRingCmd>:
ETH_DMATxDescEndOfRingCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1428
  * @param  NewState: new state of the specified DMA Tx Desc end of ring.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
   0:	6803      	ldr	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1432
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, a <ETH_DMATxDescEndOfRingCmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1435
  {
    /* Enable the selected DMA Tx Desc end of ring */
    DMATxDesc->Status |= ETH_DMATxDesc_TER;  
   4:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
   8:	e001      	b.n	e <ETH_DMATxDescEndOfRingCmd+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1440
  }
  else
  {
    /* Disable the selected DMA Tx Desc end of ring */
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_TER); 
   a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   e:	6003      	str	r3, [r0, #0]
  10:	4770      	bx	lr

Disassembly of section .text.ETH_DMATxDescSecondAddressChainedCmd:

00000000 <ETH_DMATxDescSecondAddressChainedCmd>:
ETH_DMATxDescSecondAddressChainedCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1452
  * @param  NewState: new state of the specified DMA Tx Desc second address chained.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
   0:	6803      	ldr	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1456
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, a <ETH_DMATxDescSecondAddressChainedCmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1459
  {
    /* Enable the selected DMA Tx Desc second address chained */
    DMATxDesc->Status |= ETH_DMATxDesc_TCH;  
   4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   8:	e001      	b.n	e <ETH_DMATxDescSecondAddressChainedCmd+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1464
  }
  else
  {
    /* Disable the selected DMA Tx Desc second address chained */
    DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_TCH); 
   a:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   e:	6003      	str	r3, [r0, #0]
  10:	4770      	bx	lr

Disassembly of section .text.ETH_DMATxDescShortFramePaddingCmd:

00000000 <ETH_DMATxDescShortFramePaddingCmd>:
ETH_DMATxDescShortFramePaddingCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1476
  * @param  NewState: new state of the specified DMA Tx Desc padding for frame shorter than 64 bytes.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
   0:	6803      	ldr	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1480
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, a <ETH_DMATxDescShortFramePaddingCmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1483
  {
    /* Enable the selected DMA Tx Desc padding for frame shorter than 64 bytes */
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DP);
   4:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   8:	e001      	b.n	e <ETH_DMATxDescShortFramePaddingCmd+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1488
  }
  else
  {
    /* Disable the selected DMA Tx Desc padding for frame shorter than 64 bytes*/
    DMATxDesc->Status |= ETH_DMATxDesc_DP; 
   a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   e:	6003      	str	r3, [r0, #0]
  10:	4770      	bx	lr

Disassembly of section .text.ETH_DMATxDescTimeStampCmd:

00000000 <ETH_DMATxDescTimeStampCmd>:
ETH_DMATxDescTimeStampCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1500
  * @param  NewState: new state of the specified DMA Tx Desc time stamp.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescTimeStampCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
   0:	6803      	ldr	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1504
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, a <ETH_DMATxDescTimeStampCmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1507
  {
    /* Enable the selected DMA Tx Desc time stamp */
    DMATxDesc->Status |= ETH_DMATxDesc_TTSE;  
   4:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   8:	e001      	b.n	e <ETH_DMATxDescTimeStampCmd+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1512
  }
  else
  {
    /* Disable the selected DMA Tx Desc time stamp */
    DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_TTSE); 
   a:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
   e:	6003      	str	r3, [r0, #0]
  10:	4770      	bx	lr

Disassembly of section .text.ETH_DMATxDescBufferSizeConfig:

00000000 <ETH_DMATxDescBufferSizeConfig>:
ETH_DMATxDescBufferSizeConfig():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1530
  /* Check the parameters */
  assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize1));
  assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize2));
  
  /* Set the DMA Tx Desc buffer1 and buffer2 sizes values */
  DMATxDesc->ControlBufferSize |= (BufferSize1 | (BufferSize2 << ETH_DMATXDESC_BUFFER2_SIZESHIFT));
   0:	6843      	ldr	r3, [r0, #4]
   2:	ea41 0303 	orr.w	r3, r1, r3
   6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   a:	6043      	str	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1531
}
   c:	4770      	bx	lr

Disassembly of section .text.ETH_DMARxDescChainInit:

00000000 <ETH_DMARxDescChainInit>:
ETH_DMARxDescChainInit():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1546
{
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
   0:	4b10      	ldr	r3, [pc, #64]	; (44 <ETH_DMARxDescChainInit+0x44>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1541
  * @param  RxBuff: Pointer on the first RxBuffer list
  * @param  RxBuffCount: Number of the used Rx desc in the list
  * @retval None
  */
void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
{
   2:	b530      	push	{r4, r5, lr}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1546
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
   4:	6018      	str	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1548
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
   6:	2400      	movs	r4, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1540
  * @param  DMARxDescTab: Pointer on the first Rx desc list 
  * @param  RxBuff: Pointer on the first RxBuffer list
  * @param  RxBuffCount: Number of the used Rx desc in the list
  * @retval None
  */
void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
   8:	f100 0310 	add.w	r3, r0, #16
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1548
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
   c:	e014      	b.n	38 <ETH_DMARxDescChainInit+0x38>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1553
  {
    /* Get the pointer on the ith member of the Rx Desc list */
    DMARxDesc = DMARxDescTab+i;
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN;
   e:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
  12:	f843 5c10 	str.w	r5, [r3, #-16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1556

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE;  
  16:	f244 55f0 	movw	r5, #17904	; 0x45f0
  1a:	f843 5c0c 	str.w	r5, [r3, #-12]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1561
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_MAX_PACKET_SIZE]);
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (RxBuffCount-1))
  1e:	1e55      	subs	r5, r2, #1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1564
    {
      /* Set next descriptor address register with next descriptor base address */
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
  20:	42ac      	cmp	r4, r5
  22:	bf2c      	ite	cs
  24:	4605      	movcs	r5, r0
  26:	461d      	movcc	r5, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1558
    DMARxDesc->Status = ETH_DMARxDesc_OWN;

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE;  
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_MAX_PACKET_SIZE]);
  28:	f843 1c08 	str.w	r1, [r3, #-8]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1564
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (RxBuffCount-1))
    {
      /* Set next descriptor address register with next descriptor base address */
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
  2c:	f843 5c04 	str.w	r5, [r3, #-4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1548
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
  30:	3401      	adds	r4, #1
  32:	3310      	adds	r3, #16
  34:	f501 61be 	add.w	r1, r1, #1520	; 0x5f0
  38:	4294      	cmp	r4, r2
  3a:	d3e8      	bcc.n	e <ETH_DMARxDescChainInit+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1574
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
    }
  }
   
  /* Set Receive Desciptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab;  
  3c:	4b02      	ldr	r3, [pc, #8]	; (48 <ETH_DMARxDescChainInit+0x48>)
  3e:	6018      	str	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1575
}
  40:	bd30      	pop	{r4, r5, pc}
  42:	bf00      	nop
  44:	00000000 	.word	0x00000000
  48:	4002900c 	.word	0x4002900c

Disassembly of section .text.ETH_DMARxDescRingInit:

00000000 <ETH_DMARxDescRingInit>:
ETH_DMARxDescRingInit():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1588
  *   Note: see decriptor skip length defined in ETH_DMA_InitStruct
  *   for the number of Words to skip between two unchained descriptors.  
  * @retval None
  */
void ETH_DMARxDescRingInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff1, uint8_t *RxBuff2, uint32_t RxBuffCount)
{
   0:	4c0fb570 	.word	0x4c0fb570
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1594
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  /* Fill each DMARxDesc descriptor with the right values */  
  for(i=0; i < RxBuffCount; i++)
   4:	2500      	movs	r5, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1592
void ETH_DMARxDescRingInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff1, uint8_t *RxBuff2, uint32_t RxBuffCount)
{
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
   6:	6020      	str	r0, [r4, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1594
  /* Fill each DMARxDesc descriptor with the right values */  
  for(i=0; i < RxBuffCount; i++)
   8:	4604      	mov	r4, r0
   a:	e014      	b.n	36 <ETH_DMARxDescRingInit+0x36>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1599
  {
    /* Get the pointer on the ith member of the Rx Desc list */
    DMARxDesc = DMARxDescTab+i; 
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN; 
   c:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
  10:	6026      	str	r6, [r4, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1601
    /* Set Buffer1 size */
    DMARxDesc->ControlBufferSize = ETH_MAX_PACKET_SIZE;  
  12:	f44f 66be 	mov.w	r6, #1520	; 0x5f0
  16:	6066      	str	r6, [r4, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1610
    /* Set Buffer2 address pointer */
    DMARxDesc->Buffer2NextDescAddr = (uint32_t)(&RxBuff2[i*ETH_MAX_PACKET_SIZE]); 
    
    /* Set Receive End of Ring bit for last descriptor: The DMA returns to the base
       address of the list, creating a Desciptor Ring */
    if(i == (RxBuffCount-1))
  18:	1e5e      	subs	r6, r3, #1
  1a:	42b5      	cmp	r5, r6
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1613
    {
      /* Set Receive End of Ring bit */
      DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_RER;
  1c:	bf08      	it	eq
  1e:	f248 56f0 	movweq	r6, #34288	; 0x85f0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1603
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN; 
    /* Set Buffer1 size */
    DMARxDesc->ControlBufferSize = ETH_MAX_PACKET_SIZE;  
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff1[i*ETH_MAX_PACKET_SIZE]); 
  22:	60a1      	str	r1, [r4, #8]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1606
    
    /* Set Buffer2 address pointer */
    DMARxDesc->Buffer2NextDescAddr = (uint32_t)(&RxBuff2[i*ETH_MAX_PACKET_SIZE]); 
  24:	60e2      	str	r2, [r4, #12]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1613
    /* Set Receive End of Ring bit for last descriptor: The DMA returns to the base
       address of the list, creating a Desciptor Ring */
    if(i == (RxBuffCount-1))
    {
      /* Set Receive End of Ring bit */
      DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_RER;
  26:	bf08      	it	eq
  28:	6066      	streq	r6, [r4, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1594
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  /* Fill each DMARxDesc descriptor with the right values */  
  for(i=0; i < RxBuffCount; i++)
  2a:	f501 61be 	add.w	r1, r1, #1520	; 0x5f0
  2e:	3501      	adds	r5, #1
  30:	3410      	adds	r4, #16
  32:	f502 62be 	add.w	r2, r2, #1520	; 0x5f0
  36:	429d      	cmp	r5, r3
  38:	d3e8      	bcc.n	c <ETH_DMARxDescRingInit+0xc>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1618
      DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_RER;
    }
  }
   
  /* Set Receive Desciptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab;  
  3a:	4b02      	ldr	r3, [pc, #8]	; (44 <ETH_DMARxDescRingInit+0x44>)
  3c:	6018      	str	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1619
}
  3e:	bd70      	pop	{r4, r5, r6, pc}
  40:	00000000 	.word	0x00000000
  44:	4002900c 	.word	0x4002900c

Disassembly of section .text.ETH_GetDMARxDescFlagStatus:

00000000 <ETH_GetDMARxDescFlagStatus>:
ETH_GetDMARxDescFlagStatus():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1651
FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_DMARxDESC_GET_FLAG(ETH_DMARxDescFlag));
  if ((DMARxDesc->Status & ETH_DMARxDescFlag) != (uint32_t)RESET)
   0:	6803      	ldr	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1653
  {
    bitstatus = SET;
   2:	4219      	tst	r1, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1660
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   4:	bf0c      	ite	eq
   6:	2000      	moveq	r0, #0
   8:	2001      	movne	r0, #1
   a:	4770      	bx	lr

Disassembly of section .text.ETH_SetDMARxDescOwnBit:

00000000 <ETH_SetDMARxDescOwnBit>:
ETH_SetDMARxDescOwnBit():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1670
  * @retval None
  */
void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc)
{
  /* Set the DMA Rx Desc Own bit */
  DMARxDesc->Status |= ETH_DMARxDesc_OWN;
   0:	6803      	ldr	r3, [r0, #0]
   2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   6:	6003      	str	r3, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1671
}
   8:	4770      	bx	lr

Disassembly of section .text.ETH_GetDMARxDescFrameLength:

00000000 <ETH_GetDMARxDescFrameLength>:
ETH_GetDMARxDescFrameLength():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1681
  * @retval The Rx descriptor received frame length.
  */
uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc)
{
  /* Return the Receive descriptor frame length */
  return ((DMARxDesc->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT);
   0:	8840      	ldrh	r0, [r0, #2]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1682
}
   2:	0480      	lsls	r0, r0, #18
   4:	0c80      	lsrs	r0, r0, #18
   6:	4770      	bx	lr

Disassembly of section .text.ETH_GetRxPktSize:

00000000 <ETH_GetRxPktSize>:
ETH_GetRxPktSize():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:655
  * @retval framelength: received packet size 
  */
uint32_t ETH_GetRxPktSize(void)
{
  uint32_t frameLength = 0;
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
   0:	4b06      	ldr	r3, [pc, #24]	; (1c <ETH_GetRxPktSize+0x1c>)
   2:	6818      	ldr	r0, [r3, #0]
   4:	6803      	ldr	r3, [r0, #0]
   6:	2b00      	cmp	r3, #0
   8:	db06      	blt.n	18 <ETH_GetRxPktSize+0x18>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:657
     ((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&
   a:	f403 4303 	and.w	r3, r3, #33536	; 0x8300
   e:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
  12:	d101      	bne.n	6 <ETH_GetRxPktSize+0x6>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:661
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))
  {
    /* Get the size of the packet: including 4 bytes of the CRC */
    frameLength = ETH_GetDMARxDescFrameLength(DMARxDescToGet);
  14:	f7ff bffe 	b.w	0 <ETH_GetRxPktSize>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:666
  }
 
 /* Return Frame Length */ 
 return frameLength;
}
  18:	2000      	movs	r0, #0
  1a:	4770      	bx	lr
  1c:	00000000 	.word	0x00000000

Disassembly of section .text.ETH_DMARxDescReceiveITConfig:

00000000 <ETH_DMARxDescReceiveITConfig>:
ETH_DMARxDescReceiveITConfig():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1692
  * @param  NewState: new state of the specified DMA Rx Desc interrupt.
  *   This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
{
   0:	6843      	ldr	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1696
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, a <ETH_DMARxDescReceiveITConfig+0xa>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1699
  {
    /* Enable the DMA Rx Desc receive interrupt */
    DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_DIC);
   4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   8:	e001      	b.n	e <ETH_DMARxDescReceiveITConfig+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1704
  }
  else
  {
    /* Disable the DMA Rx Desc receive interrupt */
    DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_DIC;
   a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   e:	6043      	str	r3, [r0, #4]
  10:	4770      	bx	lr

Disassembly of section .text.ETH_DMARxDescEndOfRingCmd:

00000000 <ETH_DMARxDescEndOfRingCmd>:
ETH_DMARxDescEndOfRingCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1716
  * @param  NewState: new state of the specified DMA Rx Desc end of ring.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMARxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
{
   0:	6843      	ldr	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1720
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, a <ETH_DMARxDescEndOfRingCmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1723
  {
    /* Enable the selected DMA Rx Desc end of ring */
    DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_RER;  
   4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   8:	e001      	b.n	e <ETH_DMARxDescEndOfRingCmd+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1728
  }
  else
  {
    /* Disable the selected DMA Rx Desc end of ring */
    DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_RER); 
   a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   e:	6043      	str	r3, [r0, #4]
  10:	4770      	bx	lr

Disassembly of section .text.ETH_DMARxDescSecondAddressChainedCmd:

00000000 <ETH_DMARxDescSecondAddressChainedCmd>:
ETH_DMARxDescSecondAddressChainedCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1740
  * @param  NewState: new state of the specified DMA Rx Desc second address chained.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMARxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
{
   0:	6843      	ldr	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1744
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, a <ETH_DMARxDescSecondAddressChainedCmd+0xa>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1747
  {
    /* Enable the selected DMA Rx Desc second address chained */
    DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_RCH;  
   4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   8:	e001      	b.n	e <ETH_DMARxDescSecondAddressChainedCmd+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1752
  }
  else
  {
    /* Disable the selected DMA Rx Desc second address chained */
    DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_RCH); 
   a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
   e:	6043      	str	r3, [r0, #4]
  10:	4770      	bx	lr

Disassembly of section .text.ETH_GetDMARxDescBufferSize:

00000000 <ETH_GetDMARxDescBufferSize>:
ETH_GetDMARxDescBufferSize():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1766
  *     @arg ETH_DMARxDesc_Buffer1 : DMA Rx Desc Buffer1
  *     @arg ETH_DMARxDesc_Buffer2 : DMA Rx Desc Buffer2                     
  * @retval The Receive descriptor frame length.
  */
uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer)
{
   0:	6843      	ldr	r3, [r0, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1770
  /* Check the parameters */
  assert_param(IS_ETH_DMA_RXDESC_BUFFER(DMARxDesc_Buffer));
  
  if(DMARxDesc_Buffer != ETH_DMARxDesc_Buffer1)
   2:	b121      	cbz	r1, e <ETH_GetDMARxDescBufferSize+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1773
  {
    /* Return the DMA Rx Desc buffer2 size */
    return ((DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS2) >> ETH_DMARXDESC_BUFFER2_SIZESHIFT); 
   4:	4803      	ldr	r0, [pc, #12]	; (14 <ETH_GetDMARxDescBufferSize+0x14>)
   6:	ea03 0000 	and.w	r0, r3, r0
   a:	0c00      	lsrs	r0, r0, #16
   c:	4770      	bx	lr
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1778
  }
  else
  {
    /* Return the DMA Rx Desc buffer1 size */
    return (DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS1); 
   e:	04d8      	lsls	r0, r3, #19
  10:	0cc0      	lsrs	r0, r0, #19
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1780
  }
}
  12:	4770      	bx	lr
  14:	1fff0000 	.word	0x1fff0000

Disassembly of section .text.ETH_SoftwareReset:

00000000 <ETH_SoftwareReset>:
ETH_SoftwareReset():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1792
  */
void ETH_SoftwareReset(void)
{
  /* Set the SWR bit: resets all MAC subsystem internal registers and logic */
  /* After reset all the registers holds their respective reset values */
  ETH->DMABMR |= ETH_DMABMR_SR;
   0:	681a4b02 	.word	0x681a4b02
   4:	f042 0201 	orr.w	r2, r2, #1
   8:	601a      	str	r2, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1793
}
   a:	4770      	bx	lr
   c:	40029000 	.word	0x40029000

Disassembly of section .text.ETH_GetSoftwareResetStatus:

00000000 <ETH_GetSoftwareResetStatus>:
ETH_GetSoftwareResetStatus():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1803
  * @retval The new state of DMA Bus Mode register SR bit (SET or RESET).
  */
FlagStatus ETH_GetSoftwareResetStatus(void)
{
  FlagStatus bitstatus = RESET;
  if((ETH->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
   0:	4b02      	ldr	r3, [pc, #8]	; (c <ETH_GetSoftwareResetStatus+0xc>)
   2:	6818      	ldr	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1812
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   4:	f000 0001 	and.w	r0, r0, #1
   8:	4770      	bx	lr
   a:	bf00      	nop
   c:	40029000 	.word	0x40029000

Disassembly of section .text.ETH_GetDMAFlagStatus:

00000000 <ETH_GetDMAFlagStatus>:
ETH_GetDMAFlagStatus():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1846
FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG)
{  
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_FLAG));
  if ((ETH->DMASR & ETH_DMA_FLAG) != (uint32_t)RESET)
   0:	4b03      	ldr	r3, [pc, #12]	; (10 <ETH_GetDMAFlagStatus+0x10>)
   2:	681b      	ldr	r3, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1848
  {
    bitstatus = SET;
   4:	4218      	tst	r0, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1855
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   6:	bf0c      	ite	eq
   8:	2000      	moveq	r0, #0
   a:	2001      	movne	r0, #1
   c:	4770      	bx	lr
   e:	bf00      	nop
  10:	40029014 	.word	0x40029014

Disassembly of section .text.ETH_DMAClearFlag:

00000000 <ETH_DMAClearFlag>:
ETH_DMAClearFlag():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1884
{
  /* Check the parameters */
  assert_param(IS_ETH_DMA_FLAG(ETH_DMA_FLAG));
  
  /* Clear the selected ETHERNET DMA FLAG */
  ETH->DMASR = (uint32_t) ETH_DMA_FLAG;
   0:	60184b01 	.word	0x60184b01
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1885
}
   4:	4770      	bx	lr
   6:	bf00      	nop
   8:	40029014 	.word	0x40029014

Disassembly of section .text.ETH_GetDMAITStatus:

00000000 <ETH_GetDMAITStatus>:
ETH_GetDMAITStatus():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1916
ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT)
{  
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_IT));
  if ((ETH->DMASR & ETH_DMA_IT) != (uint32_t)RESET)
   0:	4b03      	ldr	r3, [pc, #12]	; (10 <ETH_GetDMAITStatus+0x10>)
   2:	681b      	ldr	r3, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1918
  {
    bitstatus = SET;
   4:	4218      	tst	r0, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1925
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   6:	bf0c      	ite	eq
   8:	2000      	moveq	r0, #0
   a:	2001      	movne	r0, #1
   c:	4770      	bx	lr
   e:	bf00      	nop
  10:	40029014 	.word	0x40029014

Disassembly of section .text.ETH_DMAClearITPendingBit:

00000000 <ETH_DMAClearITPendingBit>:
ETH_DMAClearITPendingBit():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1954
{
  /* Check the parameters */
  assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
  
  /* Clear the selected ETHERNET DMA IT */
  ETH->DMASR = (uint32_t) ETH_DMA_IT;
   0:	60184b01 	.word	0x60184b01
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1955
}
   4:	4770      	bx	lr
   6:	bf00      	nop
   8:	40029014 	.word	0x40029014

Disassembly of section .text.ETH_GetTransmitProcessState:

00000000 <ETH_GetTransmitProcessState>:
ETH_GetTransmitProcessState():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1971
  *     - ETH_DMA_TransmitProcess_Suspended : Suspended - Tx Desciptor unavailabe
  *     - ETH_DMA_TransmitProcess_Closing   : Running - closing Rx descriptor  
  */
uint32_t ETH_GetTransmitProcessState(void)
{
  return ((uint32_t)(ETH->DMASR & ETH_DMASR_TS)); 
   0:	4b02      	ldr	r3, [pc, #8]	; (c <ETH_GetTransmitProcessState+0xc>)
   2:	6818      	ldr	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1972
}
   4:	f000 0001 	and.w	r0, r0, #1
   8:	4770      	bx	lr
   a:	bf00      	nop
   c:	40029014 	.word	0x40029014

Disassembly of section .text.ETH_GetReceiveProcessState:

00000000 <ETH_GetReceiveProcessState>:
ETH_GetReceiveProcessState():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1988
  *     - ETH_DMA_ReceiveProcess_Closing   : Running - closing descriptor
  *     - ETH_DMA_ReceiveProcess_Queuing   : Running - queuing the recieve frame into host memory  
  */
uint32_t ETH_GetReceiveProcessState(void)
{
  return ((uint32_t)(ETH->DMASR & ETH_DMASR_RS)); 
   0:	4b02      	ldr	r3, [pc, #8]	; (c <ETH_GetReceiveProcessState+0xc>)
   2:	6818      	ldr	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1989
}
   4:	f000 0040 	and.w	r0, r0, #64	; 0x40
   8:	4770      	bx	lr
   a:	bf00      	nop
   c:	40029014 	.word	0x40029014

Disassembly of section .text.ETH_FlushTransmitFIFO:

00000000 <ETH_FlushTransmitFIFO>:
ETH_FlushTransmitFIFO():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1999
  * @retval None
  */
void ETH_FlushTransmitFIFO(void)
{
  /* Set the Flush Transmit FIFO bit */
  ETH->DMAOMR |= ETH_DMAOMR_FTF;  
   0:	4b02      	ldr	r3, [pc, #8]	; (c <ETH_FlushTransmitFIFO+0xc>)
   2:	681a      	ldr	r2, [r3, #0]
   4:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
   8:	601a      	str	r2, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2000
}
   a:	4770      	bx	lr
   c:	40029018 	.word	0x40029018

Disassembly of section .text.ETH_GetFlushTransmitFIFOStatus:

00000000 <ETH_GetFlushTransmitFIFOStatus>:
ETH_GetFlushTransmitFIFOStatus():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2010
  * @retval The new state of ETHERNET flush transmit FIFO bit (SET or RESET).
  */
FlagStatus ETH_GetFlushTransmitFIFOStatus(void)
{   
  FlagStatus bitstatus = RESET;
  if ((ETH->DMAOMR & ETH_DMAOMR_FTF) != (uint32_t)RESET)
   0:	4b02      	ldr	r3, [pc, #8]	; (c <ETH_GetFlushTransmitFIFOStatus+0xc>)
   2:	6818      	ldr	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2019
  else
  {
    bitstatus = RESET;
  }
  return bitstatus; 
}
   4:	f3c0 5000 	ubfx	r0, r0, #20, #1
   8:	4770      	bx	lr
   a:	bf00      	nop
   c:	40029018 	.word	0x40029018

Disassembly of section .text.ETH_DMATransmissionCmd:

00000000 <ETH_DMATransmissionCmd>:
ETH_DMATransmissionCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2028
  * @param  NewState: new state of the DMA transmission.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATransmissionCmd(FunctionalState NewState)
{ 
   0:	4b05      	ldr	r3, [pc, #20]	; (18 <ETH_DMATransmissionCmd+0x18>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2032
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b118      	cbz	r0, c <ETH_DMATransmissionCmd+0xc>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2035
  {
    /* Enable the DMA transmission */
    ETH->DMAOMR |= ETH_DMAOMR_ST;  
   4:	681a      	ldr	r2, [r3, #0]
   6:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
   a:	e002      	b.n	12 <ETH_DMATransmissionCmd+0x12>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2040
  }
  else
  {
    /* Disable the DMA transmission */
    ETH->DMAOMR &= ~ETH_DMAOMR_ST;
   c:	681a      	ldr	r2, [r3, #0]
   e:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  12:	601a      	str	r2, [r3, #0]
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	40029018 	.word	0x40029018

Disassembly of section .text.ETH_DMAReceptionCmd:

00000000 <ETH_DMAReceptionCmd>:
ETH_DMAReceptionCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2051
  * @param  NewState: new state of the DMA reception.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMAReceptionCmd(FunctionalState NewState)
{ 
   0:	4b05      	ldr	r3, [pc, #20]	; (18 <ETH_DMAReceptionCmd+0x18>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2055
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b118      	cbz	r0, c <ETH_DMAReceptionCmd+0xc>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2058
  {
    /* Enable the DMA reception */
    ETH->DMAOMR |= ETH_DMAOMR_SR;  
   4:	681a      	ldr	r2, [r3, #0]
   6:	f042 0202 	orr.w	r2, r2, #2
   a:	e002      	b.n	12 <ETH_DMAReceptionCmd+0x12>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2063
  }
  else
  {
    /* Disable the DMA reception */
    ETH->DMAOMR &= ~ETH_DMAOMR_SR;
   c:	681a      	ldr	r2, [r3, #0]
   e:	f022 0202 	bic.w	r2, r2, #2
  12:	601a      	str	r2, [r3, #0]
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	40029018 	.word	0x40029018

Disassembly of section .text.ETH_Start:

00000000 <ETH_Start>:
ETH_Start():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:500
  * @brief  Enables ENET MAC and DMA reception/transmission 
  * @param  None
  * @retval None
  */
void ETH_Start(void)
{
   0:	b510      	push	{r4, lr}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:502
  /* Enable transmit state machine of the MAC for transmission on the MII */  
  ETH_MACTransmissionCmd(ENABLE);
   2:	2001      	movs	r0, #1
   4:	f7ff fffe 	bl	0 <ETH_Start>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:504
  /* Flush Transmit FIFO */
  ETH_FlushTransmitFIFO();
   8:	f7ff fffe 	bl	0 <ETH_Start>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:506
  /* Enable receive state machine of the MAC for reception from the MII */  
  ETH_MACReceptionCmd(ENABLE);
   c:	2001      	movs	r0, #1
   e:	f7ff fffe 	bl	0 <ETH_Start>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:509
 
  /* Start DMA transmission */
  ETH_DMATransmissionCmd(ENABLE); 
  12:	2001      	movs	r0, #1
  14:	f7ff fffe 	bl	0 <ETH_Start>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:511
  /* Start DMA reception */
  ETH_DMAReceptionCmd(ENABLE);   
  18:	2001      	movs	r0, #1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:512
}
  1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:511
  ETH_MACReceptionCmd(ENABLE);
 
  /* Start DMA transmission */
  ETH_DMATransmissionCmd(ENABLE); 
  /* Start DMA reception */
  ETH_DMAReceptionCmd(ENABLE);   
  1e:	f7ff bffe 	b.w	0 <ETH_Start>

Disassembly of section .text.ETH_DMAITConfig:

00000000 <ETH_DMAITConfig>:
ETH_DMAITConfig():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2092
  * @param  NewState: new state of the specified ETHERNET DMA interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState)
{
   0:	4b04      	ldr	r3, [pc, #16]	; (14 <ETH_DMAITConfig+0x14>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2097
  /* Check the parameters */
  assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, a <ETH_DMAITConfig+0xa>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2100
  {
    /* Enable the selected ETHERNET DMA interrupts */
    ETH->DMAIER |= ETH_DMA_IT;
   4:	681a      	ldr	r2, [r3, #0]
   6:	4310      	orrs	r0, r2
   8:	e002      	b.n	10 <ETH_DMAITConfig+0x10>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2105
  }
  else
  {
    /* Disable the selected ETHERNET DMA interrupts */
    ETH->DMAIER &=(~(uint32_t)ETH_DMA_IT);
   a:	681a      	ldr	r2, [r3, #0]
   c:	ea22 0000 	bic.w	r0, r2, r0
  10:	6018      	str	r0, [r3, #0]
  12:	4770      	bx	lr
  14:	4002901c 	.word	0x4002901c

Disassembly of section .text.ETH_GetDMAOverflowStatus:

00000000 <ETH_GetDMAOverflowStatus>:
ETH_GetDMAOverflowStatus():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2123
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_DMA_GET_OVERFLOW(ETH_DMA_Overflow));
  
  if ((ETH->DMAMFBOCR & ETH_DMA_Overflow) != (uint32_t)RESET)
   0:	681b4b03 	.word	0x681b4b03
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2125
  {
    bitstatus = SET;
   4:	4218      	tst	r0, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2132
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   6:	bf0c      	ite	eq
   8:	2000      	moveq	r0, #0
   a:	2001      	movne	r0, #1
   c:	4770      	bx	lr
   e:	bf00      	nop
  10:	40029020 	.word	0x40029020

Disassembly of section .text.ETH_GetRxOverflowMissedFrameCounter:

00000000 <ETH_GetRxOverflowMissedFrameCounter>:
ETH_GetRxOverflowMissedFrameCounter():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2141
  * @param  None
  * @retval The value of Rx overflow Missed Frame Counter.
  */
uint32_t ETH_GetRxOverflowMissedFrameCounter(void)
{
  return ((uint32_t)((ETH->DMAMFBOCR & ETH_DMAMFBOCR_MFA)>>ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT));
   0:	4b03      	ldr	r3, [pc, #12]	; (10 <ETH_GetRxOverflowMissedFrameCounter+0x10>)
   2:	4804      	ldr	r0, [pc, #16]	; (14 <ETH_GetRxOverflowMissedFrameCounter+0x14>)
   4:	681b      	ldr	r3, [r3, #0]
   6:	ea03 0000 	and.w	r0, r3, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2142
}
   a:	0c40      	lsrs	r0, r0, #17
   c:	4770      	bx	lr
   e:	bf00      	nop
  10:	40029020 	.word	0x40029020
  14:	0ffe0000 	.word	0x0ffe0000

Disassembly of section .text.ETH_GetBufferUnavailableMissedFrameCounter:

00000000 <ETH_GetBufferUnavailableMissedFrameCounter>:
ETH_GetBufferUnavailableMissedFrameCounter():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2151
  * @param  None
  * @retval The value of Buffer unavailable Missed Frame Counter.
  */
uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void)
{
  return ((uint32_t)(ETH->DMAMFBOCR) & ETH_DMAMFBOCR_MFC);
   0:	68184b01 	.word	0x68184b01
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2152
}
   4:	b280      	uxth	r0, r0
   6:	4770      	bx	lr
   8:	40029020 	.word	0x40029020

Disassembly of section .text.ETH_GetCurrentTxDescStartAddress:

00000000 <ETH_GetCurrentTxDescStartAddress>:
ETH_GetCurrentTxDescStartAddress():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2161
  * @param  None
  * @retval The value of the current Tx desc start address.
  */
uint32_t ETH_GetCurrentTxDescStartAddress(void)
{
  return ((uint32_t)(ETH->DMACHTDR));
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <ETH_GetCurrentTxDescStartAddress+0x8>)
   2:	6818      	ldr	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2162
}
   4:	4770      	bx	lr
   6:	bf00      	nop
   8:	40029048 	.word	0x40029048

Disassembly of section .text.ETH_GetCurrentRxDescStartAddress:

00000000 <ETH_GetCurrentRxDescStartAddress>:
ETH_GetCurrentRxDescStartAddress():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2171
  * @param  None
  * @retval The value of the current Rx desc start address.
  */
uint32_t ETH_GetCurrentRxDescStartAddress(void)
{
  return ((uint32_t)(ETH->DMACHRDR));
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <ETH_GetCurrentRxDescStartAddress+0x8>)
   2:	6818      	ldr	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2172
}
   4:	4770      	bx	lr
   6:	bf00      	nop
   8:	4002904c 	.word	0x4002904c

Disassembly of section .text.ETH_GetCurrentTxBufferAddress:

00000000 <ETH_GetCurrentTxBufferAddress>:
ETH_GetCurrentTxBufferAddress():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2181
  * @param  None
  * @retval The value of the current Tx buffer address.
  */
uint32_t ETH_GetCurrentTxBufferAddress(void)
{
  return ((uint32_t)(ETH->DMACHTBAR));
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <ETH_GetCurrentTxBufferAddress+0x8>)
   2:	6818      	ldr	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2182
}
   4:	4770      	bx	lr
   6:	bf00      	nop
   8:	40029050 	.word	0x40029050

Disassembly of section .text.ETH_GetCurrentRxBufferAddress:

00000000 <ETH_GetCurrentRxBufferAddress>:
ETH_GetCurrentRxBufferAddress():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2191
  * @param  None
  * @retval The value of the current Rx buffer address.
  */
uint32_t ETH_GetCurrentRxBufferAddress(void)
{
  return ((uint32_t)(ETH->DMACHRBAR));
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <ETH_GetCurrentRxBufferAddress+0x8>)
   2:	6818      	ldr	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2192
}
   4:	4770      	bx	lr
   6:	bf00      	nop
   8:	40029054 	.word	0x40029054

Disassembly of section .text.ETH_ResumeDMATransmission:

00000000 <ETH_ResumeDMATransmission>:
ETH_ResumeDMATransmission():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2202
  * @param  None
  * @retval None.
  */
void ETH_ResumeDMATransmission(void)
{
  ETH->DMATPDR = 0;
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <ETH_ResumeDMATransmission+0x8>)
   2:	2200      	movs	r2, #0
   4:	601a      	str	r2, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2203
}
   6:	4770      	bx	lr
   8:	40029004 	.word	0x40029004

Disassembly of section .text.ETH_ResumeDMAReception:

00000000 <ETH_ResumeDMAReception>:
ETH_ResumeDMAReception():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2213
  * @param  None
  * @retval None.
  */
void ETH_ResumeDMAReception(void)
{
  ETH->DMARPDR = 0;
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <ETH_ResumeDMAReception+0x8>)
   2:	2200      	movs	r2, #0
   4:	601a      	str	r2, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2214
}
   6:	4770      	bx	lr
   8:	40029008 	.word	0x40029008

Disassembly of section .text.ETH_ResetWakeUpFrameFilterRegisterPointer:

00000000 <ETH_ResetWakeUpFrameFilterRegisterPointer>:
ETH_ResetWakeUpFrameFilterRegisterPointer():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2225
  * @retval None
  */
void ETH_ResetWakeUpFrameFilterRegisterPointer(void)
{  
  /* Resets the Remote Wake-up Frame Filter register pointer to 0x0000 */
  ETH->MACPMTCSR |= ETH_MACPMTCSR_WFFRPR;  
   0:	4b02      	ldr	r3, [pc, #8]	; (c <ETH_ResetWakeUpFrameFilterRegisterPointer+0xc>)
   2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   4:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
   8:	62da      	str	r2, [r3, #44]	; 0x2c
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2226
}
   a:	4770      	bx	lr
   c:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_SetWakeUpFrameFilterRegister:

00000000 <ETH_SetWakeUpFrameFilterRegister>:
ETH_SetWakeUpFrameFilterRegister():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2234
  * @brief  Populates the remote wakeup frame registers.
  * @param  Buffer: Pointer on remote WakeUp Frame Filter Register buffer data (8 words).
  * @retval None
  */
void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
{
   0:	2300      	movs	r3, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2241
  
  /* Fill Remote Wake-up Frame Filter register with Buffer data */
  for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
  {
    /* Write each time to the same register */ 
    ETH->MACRWUFFR = Buffer[i];
   2:	58c1      	ldr	r1, [r0, r3]
   4:	4a02      	ldr	r2, [pc, #8]	; (10 <ETH_SetWakeUpFrameFilterRegister+0x10>)
   6:	3304      	adds	r3, #4
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2238
void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
{
  uint32_t i = 0;
  
  /* Fill Remote Wake-up Frame Filter register with Buffer data */
  for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
   8:	2b20      	cmp	r3, #32
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2241
  {
    /* Write each time to the same register */ 
    ETH->MACRWUFFR = Buffer[i];
   a:	6291      	str	r1, [r2, #40]	; 0x28
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2238
void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
{
  uint32_t i = 0;
  
  /* Fill Remote Wake-up Frame Filter register with Buffer data */
  for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
   c:	d1f9      	bne.n	2 <ETH_SetWakeUpFrameFilterRegister+0x2>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2243
  {
    /* Write each time to the same register */ 
    ETH->MACRWUFFR = Buffer[i];
  }
}
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_GlobalUnicastWakeUpCmd:

00000000 <ETH_GlobalUnicastWakeUpCmd>:
ETH_GlobalUnicastWakeUpCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2253
  * @param  NewState: new state of the MAC Global Unicast Wake-Up.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState)
{ 
   0:	4b05      	ldr	r3, [pc, #20]	; (18 <ETH_GlobalUnicastWakeUpCmd+0x18>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2257
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b118      	cbz	r0, c <ETH_GlobalUnicastWakeUpCmd+0xc>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2260
  {
    /* Enable the MAC Global Unicast Wake-Up */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_GU;  
   4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
   a:	e002      	b.n	12 <ETH_GlobalUnicastWakeUpCmd+0x12>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2265
  }
  else
  {
    /* Disable the MAC Global Unicast Wake-Up */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_GU;
   c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   e:	f422 7200 	bic.w	r2, r2, #512	; 0x200
  12:	62da      	str	r2, [r3, #44]	; 0x2c
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_GetPMTFlagStatus:

00000000 <ETH_GetPMTFlagStatus>:
ETH_GetPMTFlagStatus():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2284
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_PMT_GET_FLAG(ETH_PMT_FLAG));
  
  if ((ETH->MACPMTCSR & ETH_PMT_FLAG) != (uint32_t)RESET)
   0:	6adb4b03 	.word	0x6adb4b03
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2286
  {
    bitstatus = SET;
   4:	4218      	tst	r0, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2293
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   6:	bf0c      	ite	eq
   8:	2000      	moveq	r0, #0
   a:	2001      	movne	r0, #1
   c:	4770      	bx	lr
   e:	bf00      	nop
  10:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_WakeUpFrameDetectionCmd:

00000000 <ETH_WakeUpFrameDetectionCmd>:
ETH_WakeUpFrameDetectionCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2302
  * @param  NewState: new state of the MAC Wake-Up Frame Detection.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState)
{ 
   0:	4b05      	ldr	r3, [pc, #20]	; (18 <ETH_WakeUpFrameDetectionCmd+0x18>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2306
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b118      	cbz	r0, c <ETH_WakeUpFrameDetectionCmd+0xc>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2309
  {
    /* Enable the MAC Wake-Up Frame Detection */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_WFE;  
   4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   6:	f042 0204 	orr.w	r2, r2, #4
   a:	e002      	b.n	12 <ETH_WakeUpFrameDetectionCmd+0x12>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2314
  }
  else
  {
    /* Disable the MAC Wake-Up Frame Detection */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_WFE;
   c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   e:	f022 0204 	bic.w	r2, r2, #4
  12:	62da      	str	r2, [r3, #44]	; 0x2c
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_MagicPacketDetectionCmd:

00000000 <ETH_MagicPacketDetectionCmd>:
ETH_MagicPacketDetectionCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2325
  * @param  NewState: new state of the MAC Magic Packet Detection.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MagicPacketDetectionCmd(FunctionalState NewState)
{ 
   0:	4b05      	ldr	r3, [pc, #20]	; (18 <ETH_MagicPacketDetectionCmd+0x18>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2329
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b118      	cbz	r0, c <ETH_MagicPacketDetectionCmd+0xc>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2332
  {
    /* Enable the MAC Magic Packet Detection */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_MPE;  
   4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   6:	f042 0202 	orr.w	r2, r2, #2
   a:	e002      	b.n	12 <ETH_MagicPacketDetectionCmd+0x12>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2337
  }
  else
  {
    /* Disable the MAC Magic Packet Detection */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_MPE;
   c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   e:	f022 0202 	bic.w	r2, r2, #2
  12:	62da      	str	r2, [r3, #44]	; 0x2c
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_PowerDownCmd:

00000000 <ETH_PowerDownCmd>:
ETH_PowerDownCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2348
  * @param  NewState: new state of the MAC Power Down.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_PowerDownCmd(FunctionalState NewState)
{ 
   0:	4b05      	ldr	r3, [pc, #20]	; (18 <ETH_PowerDownCmd+0x18>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2352
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b118      	cbz	r0, c <ETH_PowerDownCmd+0xc>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2356
  {
    /* Enable the MAC Power Down */
    /* This puts the MAC in power down mode */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_PD;  
   4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   6:	f042 0201 	orr.w	r2, r2, #1
   a:	e002      	b.n	12 <ETH_PowerDownCmd+0x12>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2361
  }
  else
  {
    /* Disable the MAC Power Down */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_PD;
   c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   e:	f022 0201 	bic.w	r2, r2, #1
  12:	62da      	str	r2, [r3, #44]	; 0x2c
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_MMCCounterFreezeCmd:

00000000 <ETH_MMCCounterFreezeCmd>:
ETH_MMCCounterFreezeCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2373
  * @param  NewState: new state of the MMC Counter Freeze.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MMCCounterFreezeCmd(FunctionalState NewState)
{
   0:	4b06      	ldr	r3, [pc, #24]	; (1c <ETH_MMCCounterFreezeCmd+0x1c>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2377
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b120      	cbz	r0, e <ETH_MMCCounterFreezeCmd+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2380
  {
    /* Enable the MMC Counter Freeze */
    ETH->MMCCR |= ETH_MMCCR_MCF;
   4:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
   8:	f042 0208 	orr.w	r2, r2, #8
   c:	e003      	b.n	16 <ETH_MMCCounterFreezeCmd+0x16>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2385
  }
  else
  {
    /* Disable the MMC Counter Freeze */
    ETH->MMCCR &= ~ETH_MMCCR_MCF;
   e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
  12:	f022 0208 	bic.w	r2, r2, #8
  16:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  1a:	4770      	bx	lr
  1c:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_MMCResetOnReadCmd:

00000000 <ETH_MMCResetOnReadCmd>:
ETH_MMCResetOnReadCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2396
  * @param  NewState: new state of the MMC Reset On Read.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MMCResetOnReadCmd(FunctionalState NewState)
{
   0:	4b06      	ldr	r3, [pc, #24]	; (1c <ETH_MMCResetOnReadCmd+0x1c>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2400
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b120      	cbz	r0, e <ETH_MMCResetOnReadCmd+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2403
  {
    /* Enable the MMC Counter reset on read */
    ETH->MMCCR |= ETH_MMCCR_ROR; 
   4:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
   8:	f042 0204 	orr.w	r2, r2, #4
   c:	e003      	b.n	16 <ETH_MMCResetOnReadCmd+0x16>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2408
  }
  else
  {
    /* Disable the MMC Counter reset on read */
    ETH->MMCCR &= ~ETH_MMCCR_ROR;
   e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
  12:	f022 0204 	bic.w	r2, r2, #4
  16:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  1a:	4770      	bx	lr
  1c:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_MMCCounterRolloverCmd:

00000000 <ETH_MMCCounterRolloverCmd>:
ETH_MMCCounterRolloverCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2419
  * @param  NewState: new state of the MMC Counter Stop Rollover.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MMCCounterRolloverCmd(FunctionalState NewState)
{
   0:	4b06      	ldr	r3, [pc, #24]	; (1c <ETH_MMCCounterRolloverCmd+0x1c>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2423
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b120      	cbz	r0, e <ETH_MMCCounterRolloverCmd+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2426
  {
    /* Disable the MMC Counter Stop Rollover  */
    ETH->MMCCR &= ~ETH_MMCCR_CSR;
   4:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
   8:	f022 0202 	bic.w	r2, r2, #2
   c:	e003      	b.n	16 <ETH_MMCCounterRolloverCmd+0x16>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2431
  }
  else
  {
    /* Enable the MMC Counter Stop Rollover */
    ETH->MMCCR |= ETH_MMCCR_CSR; 
   e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
  12:	f042 0202 	orr.w	r2, r2, #2
  16:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  1a:	4770      	bx	lr
  1c:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_MMCCountersReset:

00000000 <ETH_MMCCountersReset>:
ETH_MMCCountersReset():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2443
  * @retval None
  */
void ETH_MMCCountersReset(void)
{
  /* Resets the MMC Counters */
  ETH->MMCCR |= ETH_MMCCR_CR; 
   0:	f8d34b03 	.word	0xf8d34b03
   4:	2100      	movs	r1, #0
   6:	f042 0201 	orr.w	r2, r2, #1
   a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2444
}
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_MMCITConfig:

00000000 <ETH_MMCITConfig>:
ETH_MMCITConfig():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2467
{ 
  /* Check the parameters */
  assert_param(IS_ETH_MMC_IT(ETH_MMC_IT));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
   0:	f010 5f80 	tst.w	r0, #268435456	; 0x10000000
   4:	4b0d      	ldr	r3, [pc, #52]	; (3c <ETH_MMCITConfig+0x3c>)
   6:	d00d      	beq.n	24 <ETH_MMCITConfig+0x24>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2470
  {
    /* Remove egister mak from IT */
    ETH_MMC_IT &= 0xEFFFFFFF;
   8:	f020 5080 	bic.w	r0, r0, #268435456	; 0x10000000
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2473
  
    /* ETHERNET MMC Rx interrupts selected */
    if (NewState != DISABLE)
   c:	b121      	cbz	r1, 18 <ETH_MMCITConfig+0x18>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2476
    {
      /* Enable the selected ETHERNET MMC interrupts */
      ETH->MMCRIMR &=(~(uint32_t)ETH_MMC_IT);
   e:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
  12:	ea22 0000 	bic.w	r0, r2, r0
  16:	e002      	b.n	1e <ETH_MMCITConfig+0x1e>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2481
    }
    else
    {
      /* Disable the selected ETHERNET MMC interrupts */
      ETH->MMCRIMR |= ETH_MMC_IT;    
  18:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
  1c:	4310      	orrs	r0, r2
  1e:	f8c3 010c 	str.w	r0, [r3, #268]	; 0x10c
  22:	4770      	bx	lr
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2487
    }
  }
  else
  {
    /* ETHERNET MMC Tx interrupts selected */
    if (NewState != DISABLE)
  24:	b121      	cbz	r1, 30 <ETH_MMCITConfig+0x30>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2490
    {
      /* Enable the selected ETHERNET MMC interrupts */
      ETH->MMCTIMR &=(~(uint32_t)ETH_MMC_IT);
  26:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
  2a:	ea22 0000 	bic.w	r0, r2, r0
  2e:	e002      	b.n	36 <ETH_MMCITConfig+0x36>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2495
    }
    else
    {
      /* Disable the selected ETHERNET MMC interrupts */
      ETH->MMCTIMR |= ETH_MMC_IT;    
  30:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
  34:	4310      	orrs	r0, r2
  36:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
  3a:	4770      	bx	lr
  3c:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_GetMMCITStatus:

00000000 <ETH_GetMMCITStatus>:
ETH_GetMMCITStatus():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2518
{
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_MMC_GET_IT(ETH_MMC_IT)); 
  
  if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
   0:	5f80f010 	.word	0x5f80f010
   4:	4b0a      	ldr	r3, [pc, #40]	; (30 <ETH_GetMMCITStatus+0x30>)
   6:	d004      	beq.n	12 <ETH_GetMMCITStatus+0x12>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2522
  {
    /* ETHERNET MMC Rx interrupts selected */
    /* Check if the ETHERNET MMC Rx selected interrupt is enabled and occured */ 
    if ((((ETH->MMCRIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) != (uint32_t)RESET))
   8:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
   c:	4002      	ands	r2, r0
   e:	d104      	bne.n	1a <ETH_GetMMCITStatus+0x1a>
  10:	e00a      	b.n	28 <ETH_GetMMCITStatus+0x28>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2535
  }
  else
  {
    /* ETHERNET MMC Tx interrupts selected */
    /* Check if the ETHERNET MMC Tx selected interrupt is enabled and occured */  
    if ((((ETH->MMCTIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) != (uint32_t)RESET))
  12:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  16:	4002      	ands	r2, r0
  18:	d008      	beq.n	2c <ETH_GetMMCITStatus+0x2c>
  1a:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2528
    {
      bitstatus = SET;
    }
    else
    {
      bitstatus = RESET;
  1e:	4218      	tst	r0, r3
  20:	bf0c      	ite	eq
  22:	2000      	moveq	r0, #0
  24:	2001      	movne	r0, #1
  26:	4770      	bx	lr
  28:	4610      	mov	r0, r2
  2a:	4770      	bx	lr
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2541
    {
      bitstatus = SET;
    }
    else
    {
      bitstatus = RESET;
  2c:	4610      	mov	r0, r2
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2546
    }  
  }    
    
  return bitstatus;
}
  2e:	4770      	bx	lr
  30:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_GetMMCRegister:

00000000 <ETH_GetMMCRegister>:
ETH_GetMMCRegister():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2571
{
  /* Check the parameters */
  assert_param(IS_ETH_MMC_REGISTER(ETH_MMCReg));
  
  /* Return the selected register value */
  return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_MMCReg));
   0:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
   4:	f500 3020 	add.w	r0, r0, #163840	; 0x28000
   8:	6800      	ldr	r0, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2572
}
   a:	4770      	bx	lr

Disassembly of section .text.ETH_EnablePTPTimeStampAddend:

00000000 <ETH_EnablePTPTimeStampAddend>:
ETH_EnablePTPTimeStampAddend():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2583
  * @retval None
  */
void ETH_EnablePTPTimeStampAddend(void)
{
  /* Enable the PTP block update with the Time Stamp Addend register value */
  ETH->PTPTSCR |= ETH_PTPTSCR_TSARU;    
   0:	4b03      	ldr	r3, [pc, #12]	; (10 <ETH_EnablePTPTimeStampAddend+0x10>)
   2:	f8d3 2700 	ldr.w	r2, [r3, #1792]	; 0x700
   6:	f042 0220 	orr.w	r2, r2, #32
   a:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2584
}
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_EnablePTPTimeStampInterruptTrigger:

00000000 <ETH_EnablePTPTimeStampInterruptTrigger>:
ETH_EnablePTPTimeStampInterruptTrigger():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2594
  * @retval None
  */
void ETH_EnablePTPTimeStampInterruptTrigger(void)
{
  /* Enable the PTP target time interrupt */
  ETH->PTPTSCR |= ETH_PTPTSCR_TSITE;    
   0:	4b03      	ldr	r3, [pc, #12]	; (10 <ETH_EnablePTPTimeStampInterruptTrigger+0x10>)
   2:	f8d3 2700 	ldr.w	r2, [r3, #1792]	; 0x700
   6:	f042 0210 	orr.w	r2, r2, #16
   a:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2595
}
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_EnablePTPTimeStampUpdate:

00000000 <ETH_EnablePTPTimeStampUpdate>:
ETH_EnablePTPTimeStampUpdate():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2605
  * @retval None
  */
void ETH_EnablePTPTimeStampUpdate(void)
{
  /* Enable the PTP system time update with the Time Stamp Update register value */
  ETH->PTPTSCR |= ETH_PTPTSCR_TSSTU;    
   0:	4b03      	ldr	r3, [pc, #12]	; (10 <ETH_EnablePTPTimeStampUpdate+0x10>)
   2:	f8d3 2700 	ldr.w	r2, [r3, #1792]	; 0x700
   6:	f042 0208 	orr.w	r2, r2, #8
   a:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2606
}
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_InitializePTPTimeStamp:

00000000 <ETH_InitializePTPTimeStamp>:
ETH_InitializePTPTimeStamp():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2616
  * @retval None
  */
void ETH_InitializePTPTimeStamp(void)
{
  /* Initialize the PTP Time Stamp */
  ETH->PTPTSCR |= ETH_PTPTSCR_TSSTI;    
   0:	4b03      	ldr	r3, [pc, #12]	; (10 <ETH_InitializePTPTimeStamp+0x10>)
   2:	f8d3 2700 	ldr.w	r2, [r3, #1792]	; 0x700
   6:	f042 0204 	orr.w	r2, r2, #4
   a:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2617
}
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_PTPUpdateMethodConfig:

00000000 <ETH_PTPUpdateMethodConfig>:
ETH_PTPUpdateMethodConfig():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2628
  *     @arg ETH_PTP_FineUpdate   : Fine Update method 
  *     @arg ETH_PTP_CoarseUpdate : Coarse Update method 
  * @retval None
  */
void ETH_PTPUpdateMethodConfig(uint32_t UpdateMethod)
{
   0:	4b06      	ldr	r3, [pc, #24]	; (1c <ETH_PTPUpdateMethodConfig+0x1c>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2632
  /* Check the parameters */
  assert_param(IS_ETH_PTP_UPDATE(UpdateMethod));
  
  if (UpdateMethod != ETH_PTP_CoarseUpdate)
   2:	b120      	cbz	r0, e <ETH_PTPUpdateMethodConfig+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2635
  {
    /* Enable the PTP Fine Update method */
    ETH->PTPTSCR |= ETH_PTPTSCR_TSFCU;
   4:	f8d3 2700 	ldr.w	r2, [r3, #1792]	; 0x700
   8:	f042 0202 	orr.w	r2, r2, #2
   c:	e003      	b.n	16 <ETH_PTPUpdateMethodConfig+0x16>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2640
  }
  else
  {
    /* Disable the PTP Coarse Update method */
    ETH->PTPTSCR &= (~(uint32_t)ETH_PTPTSCR_TSFCU);
   e:	f8d3 2700 	ldr.w	r2, [r3, #1792]	; 0x700
  12:	f022 0202 	bic.w	r2, r2, #2
  16:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
  1a:	4770      	bx	lr
  1c:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_PTPTimeStampCmd:

00000000 <ETH_PTPTimeStampCmd>:
ETH_PTPTimeStampCmd():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2651
  * @param  NewState: new state of the PTP time stamp for transmit and receive frames
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_PTPTimeStampCmd(FunctionalState NewState)
{
   0:	4b06      	ldr	r3, [pc, #24]	; (1c <ETH_PTPTimeStampCmd+0x1c>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2655
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b120      	cbz	r0, e <ETH_PTPTimeStampCmd+0xe>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2658
  {
    /* Enable the PTP time stamp for transmit and receive frames */
    ETH->PTPTSCR |= ETH_PTPTSCR_TSE;
   4:	f8d3 2700 	ldr.w	r2, [r3, #1792]	; 0x700
   8:	f042 0201 	orr.w	r2, r2, #1
   c:	e003      	b.n	16 <ETH_PTPTimeStampCmd+0x16>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2663
  }
  else
  {
    /* Disable the PTP time stamp for transmit and receive frames */
    ETH->PTPTSCR &= (~(uint32_t)ETH_PTPTSCR_TSE);
   e:	f8d3 2700 	ldr.w	r2, [r3, #1792]	; 0x700
  12:	f022 0201 	bic.w	r2, r2, #1
  16:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
  1a:	4770      	bx	lr
  1c:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_GetPTPFlagStatus:

00000000 <ETH_GetPTPFlagStatus>:
ETH_GetPTPFlagStatus():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2683
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_PTP_GET_FLAG(ETH_PTP_FLAG));
  
  if ((ETH->PTPTSCR & ETH_PTP_FLAG) != (uint32_t)RESET)
   0:	f8d34b03 	.word	0xf8d34b03
   4:	3700      	adds	r7, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2685
  {
    bitstatus = SET;
   6:	4218      	tst	r0, r3
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2692
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   8:	bf0c      	ite	eq
   a:	2000      	moveq	r0, #0
   c:	2001      	movne	r0, #1
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_SetPTPSubSecondIncrement:

00000000 <ETH_SetPTPSubSecondIncrement>:
ETH_SetPTPSubSecondIncrement():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2704
void ETH_SetPTPSubSecondIncrement(uint32_t SubSecondValue)
{
  /* Check the parameters */
  assert_param(IS_ETH_PTP_SUBSECOND_INCREMENT(SubSecondValue));
  /* Set the PTP Sub-Second Increment Register */
  ETH->PTPSSIR = SubSecondValue;    
   0:	f8c34b01 	.word	0xf8c34b01
   4:	0704      	lsls	r4, r0, #28
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2705
}
   6:	4770      	bx	lr
   8:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_SetPTPTimeStampUpdate:

00000000 <ETH_SetPTPTimeStampUpdate>:
ETH_SetPTPTimeStampUpdate():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2724
{
  /* Check the parameters */
  assert_param(IS_ETH_PTP_TIME_SIGN(Sign));  
  assert_param(IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SubSecondValue)); 
  /* Set the PTP Time Update High Register */
  ETH->PTPTSHUR = SecondValue;
   0:	4b03      	ldr	r3, [pc, #12]	; (10 <ETH_SetPTPTimeStampUpdate+0x10>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2727
  
  /* Set the PTP Time Update Low Register with sign */
  ETH->PTPTSLUR = Sign | SubSecondValue;   
   2:	4302      	orrs	r2, r0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2724
{
  /* Check the parameters */
  assert_param(IS_ETH_PTP_TIME_SIGN(Sign));  
  assert_param(IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SubSecondValue)); 
  /* Set the PTP Time Update High Register */
  ETH->PTPTSHUR = SecondValue;
   4:	f8c3 1710 	str.w	r1, [r3, #1808]	; 0x710
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2727
  
  /* Set the PTP Time Update Low Register with sign */
  ETH->PTPTSLUR = Sign | SubSecondValue;   
   8:	f8c3 2714 	str.w	r2, [r3, #1812]	; 0x714
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2728
}
   c:	4770      	bx	lr
   e:	bf00      	nop
  10:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_SetPTPTimeStampAddend:

00000000 <ETH_SetPTPTimeStampAddend>:
ETH_SetPTPTimeStampAddend():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2738
  * @retval None
  */
void ETH_SetPTPTimeStampAddend(uint32_t Value)
{
  /* Set the PTP Time Stamp Addend Register */
  ETH->PTPTSAR = Value;    
   0:	f8c34b01 	.word	0xf8c34b01
   4:	0718      	lsls	r0, r3, #28
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2739
}
   6:	4770      	bx	lr
   8:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_SetPTPTargetTime:

00000000 <ETH_SetPTPTargetTime>:
ETH_SetPTPTargetTime():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2750
  * @retval None
  */
void ETH_SetPTPTargetTime(uint32_t HighValue, uint32_t LowValue)
{
  /* Set the PTP Target Time High Register */
  ETH->PTPTTHR = HighValue;
   0:	4b02      	ldr	r3, [pc, #8]	; (c <ETH_SetPTPTargetTime+0xc>)
   2:	f8c3 071c 	str.w	r0, [r3, #1820]	; 0x71c
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2752
  /* Set the PTP Target Time Low Register */
  ETH->PTPTTLR = LowValue;    
   6:	f8c3 1720 	str.w	r1, [r3, #1824]	; 0x720
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2753
}
   a:	4770      	bx	lr
   c:	40028000 	.word	0x40028000

Disassembly of section .text.ETH_GetPTPRegister:

00000000 <ETH_GetPTPRegister>:
ETH_GetPTPRegister():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2776
{
  /* Check the parameters */
  assert_param(IS_ETH_PTP_REGISTER(ETH_PTPReg));
  
  /* Return the selected register value */
  return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_PTPReg));
   0:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
   4:	f500 3020 	add.w	r0, r0, #163840	; 0x28000
   8:	6800      	ldr	r0, [r0, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2777
}
   a:	4770      	bx	lr

Disassembly of section .text.ETH_DMAPTPTxDescChainInit:

00000000 <ETH_DMAPTPTxDescChainInit>:
ETH_DMAPTPTxDescChainInit():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2789
  * @param  TxBuffCount: Number of the used Tx desc in the list
  * @retval None
  */
void ETH_DMAPTPTxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, ETH_DMADESCTypeDef *DMAPTPTxDescTab,
                               uint8_t* TxBuff, uint32_t TxBuffCount)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2794
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
   2:	4c13      	ldr	r4, [pc, #76]	; (50 <ETH_DMAPTPTxDescChainInit+0x50>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2797
  DMAPTPTxDescToSet = DMAPTPTxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
   4:	460e      	mov	r6, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2794
{
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
   6:	6020      	str	r0, [r4, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2795
  DMAPTPTxDescToSet = DMAPTPTxDescTab;
   8:	4c12      	ldr	r4, [pc, #72]	; (54 <ETH_DMAPTPTxDescChainInit+0x54>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2797
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
   a:	2500      	movs	r5, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2795
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  DMAPTPTxDescToSet = DMAPTPTxDescTab;
   c:	6021      	str	r1, [r4, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2787
  * @param  DMAPTPTxDescTab: Pointer on the first PTP Tx desc list
  * @param  TxBuff: Pointer on the first TxBuffer list
  * @param  TxBuffCount: Number of the used Tx desc in the list
  * @retval None
  */
void ETH_DMAPTPTxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, ETH_DMADESCTypeDef *DMAPTPTxDescTab,
   e:	f100 0410 	add.w	r4, r0, #16
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2797
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  DMAPTPTxDescToSet = DMAPTPTxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
  12:	e013      	b.n	3c <ETH_DMAPTPTxDescChainInit+0x3c>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2802
  {
    /* Get the pointer on the ith member of the Tx Desc list */
    DMATxDesc = DMATxDescTab+i;
    /* Set Second Address Chained bit and enable PTP */
    DMATxDesc->Status = ETH_DMATxDesc_TCH | ETH_DMATxDesc_TTSE;  
  14:	f04f 7704 	mov.w	r7, #34603008	; 0x2100000
  18:	f844 7c10 	str.w	r7, [r4, #-16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2808
       
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr =(uint32_t)(&TxBuff[i*ETH_MAX_PACKET_SIZE]);
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (TxBuffCount-1))
  1c:	1e5f      	subs	r7, r3, #1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2811
    {
      /* Set next descriptor address register with next descriptor base address */
      DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
  1e:	42bd      	cmp	r5, r7
  20:	bf2c      	ite	cs
  22:	4607      	movcs	r7, r0
  24:	4627      	movcc	r7, r4
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2805
    DMATxDesc = DMATxDescTab+i;
    /* Set Second Address Chained bit and enable PTP */
    DMATxDesc->Status = ETH_DMATxDesc_TCH | ETH_DMATxDesc_TTSE;  
       
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr =(uint32_t)(&TxBuff[i*ETH_MAX_PACKET_SIZE]);
  26:	f844 2c08 	str.w	r2, [r4, #-8]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2811
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (TxBuffCount-1))
    {
      /* Set next descriptor address register with next descriptor base address */
      DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
  2a:	f844 7c04 	str.w	r7, [r4, #-4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2819
    {
      /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
    }
    /* make DMAPTPTxDescTab points to the same addresses as DMATxDescTab */
    (&DMAPTPTxDescTab[i])->Buffer1Addr = DMATxDesc->Buffer1Addr;
  2e:	60b2      	str	r2, [r6, #8]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2820
    (&DMAPTPTxDescTab[i])->Buffer2NextDescAddr = DMATxDesc->Buffer2NextDescAddr;
  30:	60f7      	str	r7, [r6, #12]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2797
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  DMAPTPTxDescToSet = DMAPTPTxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
  32:	3501      	adds	r5, #1
  34:	f502 62be 	add.w	r2, r2, #1520	; 0x5f0
  38:	3610      	adds	r6, #16
  3a:	3410      	adds	r4, #16
  3c:	429d      	cmp	r5, r3
  3e:	d3e9      	bcc.n	14 <ETH_DMAPTPTxDescChainInit+0x14>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2823
    /* make DMAPTPTxDescTab points to the same addresses as DMATxDescTab */
    (&DMAPTPTxDescTab[i])->Buffer1Addr = DMATxDesc->Buffer1Addr;
    (&DMAPTPTxDescTab[i])->Buffer2NextDescAddr = DMATxDesc->Buffer2NextDescAddr;
  }
  /* Store on the last DMAPTPTxDescTab desc status record the first list address */
  (&DMAPTPTxDescTab[i-1])->Status = (uint32_t) DMAPTPTxDescTab;
  40:	eb01 1303 	add.w	r3, r1, r3, lsl #4
  44:	f843 1c10 	str.w	r1, [r3, #-16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2826

  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR = (uint32_t) DMATxDescTab;
  48:	4b03      	ldr	r3, [pc, #12]	; (58 <ETH_DMAPTPTxDescChainInit+0x58>)
  4a:	6018      	str	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2827
}
  4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4e:	bf00      	nop
	...
  58:	40029010 	.word	0x40029010

Disassembly of section .text.ETH_DMAPTPRxDescChainInit:

00000000 <ETH_DMAPTPRxDescChainInit>:
ETH_DMAPTPRxDescChainInit():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2839
  * @param  RxBuffCount: Number of the used Rx desc in the list
  * @retval None
  */
void ETH_DMAPTPRxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, ETH_DMADESCTypeDef *DMAPTPRxDescTab,
                               uint8_t *RxBuff, uint32_t RxBuffCount)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2844
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
   2:	4c15      	ldr	r4, [pc, #84]	; (58 <ETH_DMAPTPRxDescChainInit+0x58>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2847
  DMAPTPRxDescToGet = DMAPTPRxDescTab;
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
   4:	460e      	mov	r6, r1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2844
{
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
   6:	6020      	str	r0, [r4, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2845
  DMAPTPRxDescToGet = DMAPTPRxDescTab;
   8:	4c14      	ldr	r4, [pc, #80]	; (5c <ETH_DMAPTPRxDescChainInit+0x5c>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2847
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
   a:	2500      	movs	r5, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2845
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  DMAPTPRxDescToGet = DMAPTPRxDescTab;
   c:	6021      	str	r1, [r4, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2837
  * @param  DMAPTPRxDescTab: Pointer on the first PTP Rx desc list
  * @param  RxBuff: Pointer on the first RxBuffer list
  * @param  RxBuffCount: Number of the used Rx desc in the list
  * @retval None
  */
void ETH_DMAPTPRxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, ETH_DMADESCTypeDef *DMAPTPRxDescTab,
   e:	f100 0410 	add.w	r4, r0, #16
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2847
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  DMAPTPRxDescToGet = DMAPTPRxDescTab;
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
  12:	e017      	b.n	44 <ETH_DMAPTPRxDescChainInit+0x44>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2852
  {
    /* Get the pointer on the ith member of the Rx Desc list */
    DMARxDesc = DMARxDescTab+i;
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN;
  14:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
  18:	f844 7c10 	str.w	r7, [r4, #-16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2855

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE;  
  1c:	f244 57f0 	movw	r7, #17904	; 0x45f0
  20:	f844 7c0c 	str.w	r7, [r4, #-12]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2860
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_MAX_PACKET_SIZE]);
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (RxBuffCount-1))
  24:	1e5f      	subs	r7, r3, #1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2863
    {
      /* Set next descriptor address register with next descriptor base address */
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
  26:	42bd      	cmp	r5, r7
  28:	bf2c      	ite	cs
  2a:	4607      	movcs	r7, r0
  2c:	4627      	movcc	r7, r4
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2857
    DMARxDesc->Status = ETH_DMARxDesc_OWN;

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE;  
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_MAX_PACKET_SIZE]);
  2e:	f844 2c08 	str.w	r2, [r4, #-8]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2863
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (RxBuffCount-1))
    {
      /* Set next descriptor address register with next descriptor base address */
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
  32:	f844 7c04 	str.w	r7, [r4, #-4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2871
    {
      /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
    }
    /* Make DMAPTPRxDescTab points to the same addresses as DMARxDescTab */
    (&DMAPTPRxDescTab[i])->Buffer1Addr = DMARxDesc->Buffer1Addr;
  36:	60b2      	str	r2, [r6, #8]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2872
    (&DMAPTPRxDescTab[i])->Buffer2NextDescAddr = DMARxDesc->Buffer2NextDescAddr;
  38:	60f7      	str	r7, [r6, #12]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2847
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  DMAPTPRxDescToGet = DMAPTPRxDescTab;
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
  3a:	3501      	adds	r5, #1
  3c:	f502 62be 	add.w	r2, r2, #1520	; 0x5f0
  40:	3610      	adds	r6, #16
  42:	3410      	adds	r4, #16
  44:	429d      	cmp	r5, r3
  46:	d3e5      	bcc.n	14 <ETH_DMAPTPRxDescChainInit+0x14>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2875
    /* Make DMAPTPRxDescTab points to the same addresses as DMARxDescTab */
    (&DMAPTPRxDescTab[i])->Buffer1Addr = DMARxDesc->Buffer1Addr;
    (&DMAPTPRxDescTab[i])->Buffer2NextDescAddr = DMARxDesc->Buffer2NextDescAddr;
  }
  /* Store on the last DMAPTPRxDescTab desc status record the first list address */
  (&DMAPTPRxDescTab[i-1])->Status = (uint32_t) DMAPTPRxDescTab;
  48:	eb01 1303 	add.w	r3, r1, r3, lsl #4
  4c:	f843 1c10 	str.w	r1, [r3, #-16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2878

  /* Set Receive Desciptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab;  
  50:	4b03      	ldr	r3, [pc, #12]	; (60 <ETH_DMAPTPRxDescChainInit+0x60>)
  52:	6018      	str	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2879
}
  54:	bdf0      	pop	{r4, r5, r6, r7, pc}
  56:	bf00      	nop
	...
  60:	4002900c 	.word	0x4002900c

Disassembly of section .text.ETH_HandlePTPTxPkt:

00000000 <ETH_HandlePTPTxPkt>:
ETH_HandlePTPTxPkt():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2890
  * @param  PTPTxTab: Pointer on the first PTP Tx table to store Time stamp values.
  * @retval ETH_ERROR: in case of Tx desc owned by DMA
  *         ETH_SUCCESS: for correct transmission
  */
uint32_t ETH_HandlePTPTxPkt(uint8_t *ppkt, uint16_t FrameLength, uint32_t *PTPTxTab)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2893
  uint32_t offset = 0, timeout = 0;
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (uint32_t)RESET)
   2:	4c30      	ldr	r4, [pc, #192]	; (c4 <ETH_HandlePTPTxPkt+0xc4>)
   4:	6823      	ldr	r3, [r4, #0]
   6:	681b      	ldr	r3, [r3, #0]
   8:	2b00      	cmp	r3, #0
   a:	db57      	blt.n	bc <ETH_HandlePTPTxPkt+0xbc>
   c:	2300      	movs	r3, #0
   e:	e005      	b.n	1c <ETH_HandlePTPTxPkt+0x1c>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2901
    return ETH_ERROR;
  }
  /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */      
  for(offset=0; offset<FrameLength; offset++)
  {
    (*(__IO uint8_t *)((DMAPTPTxDescToSet->Buffer1Addr) + offset)) = (*(ppkt + offset));
  10:	4d2d      	ldr	r5, [pc, #180]	; (c8 <ETH_HandlePTPTxPkt+0xc8>)
  12:	5cc6      	ldrb	r6, [r0, r3]
  14:	682d      	ldr	r5, [r5, #0]
  16:	68ad      	ldr	r5, [r5, #8]
  18:	555e      	strb	r6, [r3, r5]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2899
  {
    /* Return ERROR: OWN bit set */
    return ETH_ERROR;
  }
  /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */      
  for(offset=0; offset<FrameLength; offset++)
  1a:	3301      	adds	r3, #1
  1c:	428b      	cmp	r3, r1
  1e:	d3f7      	bcc.n	10 <ETH_HandlePTPTxPkt+0x10>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2904
  {
    (*(__IO uint8_t *)((DMAPTPTxDescToSet->Buffer1Addr) + offset)) = (*(ppkt + offset));
  }
  /* Setting the Frame Length: bits[12:0] */
  DMATxDescToSet->ControlBufferSize = (FrameLength & (uint32_t)0x1FFF);
  20:	6823      	ldr	r3, [r4, #0]
  22:	04c9      	lsls	r1, r1, #19
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2908
  /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */    
  DMATxDescToSet->Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
  /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
  24:	6818      	ldr	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2904
  for(offset=0; offset<FrameLength; offset++)
  {
    (*(__IO uint8_t *)((DMAPTPTxDescToSet->Buffer1Addr) + offset)) = (*(ppkt + offset));
  }
  /* Setting the Frame Length: bits[12:0] */
  DMATxDescToSet->ControlBufferSize = (FrameLength & (uint32_t)0x1FFF);
  26:	0cc9      	lsrs	r1, r1, #19
  28:	6059      	str	r1, [r3, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2908
  /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */    
  DMATxDescToSet->Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
  /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
  2a:	f040 4030 	orr.w	r0, r0, #2952790016	; 0xb0000000
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2910
  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
  2e:	4927      	ldr	r1, [pc, #156]	; (cc <ETH_HandlePTPTxPkt+0xcc>)
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2908
  /* Setting the Frame Length: bits[12:0] */
  DMATxDescToSet->ControlBufferSize = (FrameLength & (uint32_t)0x1FFF);
  /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */    
  DMATxDescToSet->Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
  /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
  30:	6018      	str	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2910
  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
  32:	680d      	ldr	r5, [r1, #0]
  34:	f015 0f04 	tst.w	r5, #4
  38:	d004      	beq.n	44 <ETH_HandlePTPTxPkt+0x44>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2913
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
  3a:	2504      	movs	r5, #4
  3c:	600d      	str	r5, [r1, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2915
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
  3e:	3d04      	subs	r5, #4
  40:	f841 5c10 	str.w	r5, [r1, #-16]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2893
  */
uint32_t ETH_HandlePTPTxPkt(uint8_t *ppkt, uint16_t FrameLength, uint32_t *PTPTxTab)
{
  uint32_t offset = 0, timeout = 0;
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (uint32_t)RESET)
  44:	2100      	movs	r1, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2920
    ETH->DMATPDR = 0;
  }
  /* Wait for ETH_DMATxDesc_TTSS flag to be set */
  do
  {
    timeout++;
  46:	3101      	adds	r1, #1
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2921
  } while (!(DMATxDescToSet->Status & ETH_DMATxDesc_TTSS) && (timeout < 0xFFFF));
  48:	f410 3f00 	tst.w	r0, #131072	; 0x20000
  4c:	d003      	beq.n	56 <ETH_HandlePTPTxPkt+0x56>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2923
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
  4e:	4d20      	ldr	r5, [pc, #128]	; (d0 <ETH_HandlePTPTxPkt+0xd0>)
  50:	42a9      	cmp	r1, r5
  52:	d104      	bne.n	5e <ETH_HandlePTPTxPkt+0x5e>
  54:	e034      	b.n	c0 <ETH_HandlePTPTxPkt+0xc0>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2921
  }
  /* Wait for ETH_DMATxDesc_TTSS flag to be set */
  do
  {
    timeout++;
  } while (!(DMATxDescToSet->Status & ETH_DMATxDesc_TTSS) && (timeout < 0xFFFF));
  56:	f64f 75ff 	movw	r5, #65535	; 0xffff
  5a:	42a9      	cmp	r1, r5
  5c:	d1f3      	bne.n	46 <ETH_HandlePTPTxPkt+0x46>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2929
  {
    return ETH_ERROR;
  }
  /* Clear the DMATxDescToSet status register TTSS flag */
  DMATxDescToSet->Status &= ~ETH_DMATxDesc_TTSS;
  *PTPTxTab++ = DMATxDescToSet->Buffer1Addr;
  5e:	6899      	ldr	r1, [r3, #8]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2928
  if(timeout == PHY_READ_TO)
  {
    return ETH_ERROR;
  }
  /* Clear the DMATxDescToSet status register TTSS flag */
  DMATxDescToSet->Status &= ~ETH_DMATxDesc_TTSS;
  60:	f420 3000 	bic.w	r0, r0, #131072	; 0x20000
  64:	6018      	str	r0, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2929
  *PTPTxTab++ = DMATxDescToSet->Buffer1Addr;
  66:	6011      	str	r1, [r2, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2930
  *PTPTxTab = DMATxDescToSet->Buffer2NextDescAddr;
  68:	68d9      	ldr	r1, [r3, #12]
  6a:	6051      	str	r1, [r2, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2933
  /* Update the ENET DMA current descriptor */
  /* Chained Mode */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_TCH) != (uint32_t)RESET)
  6c:	6819      	ldr	r1, [r3, #0]
  6e:	4a16      	ldr	r2, [pc, #88]	; (c8 <ETH_HandlePTPTxPkt+0xc8>)
  70:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  74:	d008      	beq.n	88 <ETH_HandlePTPTxPkt+0x88>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2936
  {  
    /* Selects the next DMA Tx descriptor list for next buffer read */ 
    DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMAPTPTxDescToSet->Buffer2NextDescAddr);
  76:	6813      	ldr	r3, [r2, #0]
  78:	68d9      	ldr	r1, [r3, #12]
  7a:	6021      	str	r1, [r4, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2937
    if(DMAPTPTxDescToSet->Status != 0)
  7c:	6819      	ldr	r1, [r3, #0]
  7e:	b109      	cbz	r1, 84 <ETH_HandlePTPTxPkt+0x84>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2939
    { 
      DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (DMAPTPTxDescToSet->Status);
  80:	6011      	str	r1, [r2, #0]
  82:	e019      	b.n	b8 <ETH_HandlePTPTxPkt+0xb8>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2943
    }
    else
    {
      DMAPTPTxDescToSet++;
  84:	3310      	adds	r3, #16
  86:	e016      	b.n	b6 <ETH_HandlePTPTxPkt+0xb6>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2948
    }
  }
  else /* Ring Mode */
  {  
    if((DMATxDescToSet->Status & ETH_DMATxDesc_TER) != (uint32_t)RESET)
  88:	f411 1f00 	tst.w	r1, #2097152	; 0x200000
  8c:	d004      	beq.n	98 <ETH_HandlePTPTxPkt+0x98>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2952
    {
      /* Selects the next DMA Tx descriptor list for next buffer read: this will
         be the first Tx descriptor in this case */
      DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH->DMATDLAR); 
  8e:	4b11      	ldr	r3, [pc, #68]	; (d4 <ETH_HandlePTPTxPkt+0xd4>)
  90:	6819      	ldr	r1, [r3, #0]
  92:	6021      	str	r1, [r4, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2953
      DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (ETH->DMATDLAR);
  94:	681b      	ldr	r3, [r3, #0]
  96:	e00e      	b.n	b6 <ETH_HandlePTPTxPkt+0xb6>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2958
    }
    else
    {
      /* Selects the next DMA Tx descriptor list for next buffer read */
      DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
  98:	490f      	ldr	r1, [pc, #60]	; (d8 <ETH_HandlePTPTxPkt+0xd8>)
  9a:	3310      	adds	r3, #16
  9c:	6808      	ldr	r0, [r1, #0]
  9e:	f000 007c 	and.w	r0, r0, #124	; 0x7c
  a2:	eb03 0390 	add.w	r3, r3, r0, lsr #2
  a6:	6023      	str	r3, [r4, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2959
      DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMAPTPTxDescToSet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
  a8:	680b      	ldr	r3, [r1, #0]
  aa:	6811      	ldr	r1, [r2, #0]
  ac:	f003 037c 	and.w	r3, r3, #124	; 0x7c
  b0:	3110      	adds	r1, #16
  b2:	eb01 0393 	add.w	r3, r1, r3, lsr #2
  b6:	6013      	str	r3, [r2, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2963
    }
  }
  /* Return SUCCESS */
  return ETH_SUCCESS;
  b8:	2001      	movs	r0, #1
  ba:	bd70      	pop	{r4, r5, r6, pc}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2896
  uint32_t offset = 0, timeout = 0;
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (uint32_t)RESET)
  {
    /* Return ERROR: OWN bit set */
    return ETH_ERROR;
  bc:	2000      	movs	r0, #0
  be:	bd70      	pop	{r4, r5, r6, pc}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2925
    timeout++;
  } while (!(DMATxDescToSet->Status & ETH_DMATxDesc_TTSS) && (timeout < 0xFFFF));
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
  {
    return ETH_ERROR;
  c0:	2000      	movs	r0, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2964
      DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMAPTPTxDescToSet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
    }
  }
  /* Return SUCCESS */
  return ETH_SUCCESS;
}
  c2:	bd70      	pop	{r4, r5, r6, pc}
	...
  cc:	40029014 	.word	0x40029014
  d0:	0004ffff 	.word	0x0004ffff
  d4:	40029010 	.word	0x40029010
  d8:	40029000 	.word	0x40029000

Disassembly of section .text.ETH_HandlePTPRxPkt:

00000000 <ETH_HandlePTPRxPkt>:
ETH_HandlePTPRxPkt():
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2974
  * @param  PTPRxTab: Pointer on the first PTP Rx table to store Time stamp values.
  * @retval ETH_ERROR: if there is error in reception
  *         framelength: received packet size if packet reception is correct
  */
uint32_t ETH_HandlePTPRxPkt(uint8_t *ppkt, uint32_t *PTPRxTab)
{
   0:	48284603 	.word	0x48284603
   4:	b530      	push	{r4, r5, lr}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2977
  uint32_t offset = 0, framelength = 0;
  /* Check if the descriptor is owned by the ENET or CPU */
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (uint32_t)RESET)
   6:	6802      	ldr	r2, [r0, #0]
   8:	4604      	mov	r4, r0
   a:	6812      	ldr	r2, [r2, #0]
   c:	2a00      	cmp	r2, #0
   e:	db47      	blt.n	a0 <ETH_HandlePTPRxPkt+0xa0>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2983
  {
    /* Return error: OWN bit set */
    return ETH_ERROR;
  }
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&
  10:	f402 4003 	and.w	r0, r2, #33536	; 0x8300
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2982
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (uint32_t)RESET)
  {
    /* Return error: OWN bit set */
    return ETH_ERROR;
  }
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
  14:	f5b0 7f40 	cmp.w	r0, #768	; 0x300
  18:	d10f      	bne.n	3a <ETH_HandlePTPRxPkt+0x3a>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2987
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))
  {
    /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
    framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4;
  1a:	4823      	ldr	r0, [pc, #140]	; (a8 <ETH_HandlePTPRxPkt+0xa8>)
  1c:	ea02 0000 	and.w	r0, r2, r0
  20:	0c00      	lsrs	r0, r0, #16
  22:	3804      	subs	r0, #4
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2989
    /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */ 
    for(offset=0; offset<framelength; offset++)
  24:	2200      	movs	r2, #0
  26:	e005      	b.n	34 <ETH_HandlePTPRxPkt+0x34>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2991
    {
      (*(ppkt + offset)) = (*(__IO uint8_t *)((DMAPTPRxDescToGet->Buffer1Addr) + offset));
  28:	4d20      	ldr	r5, [pc, #128]	; (ac <ETH_HandlePTPRxPkt+0xac>)
  2a:	682d      	ldr	r5, [r5, #0]
  2c:	68ad      	ldr	r5, [r5, #8]
  2e:	5d55      	ldrb	r5, [r2, r5]
  30:	549d      	strb	r5, [r3, r2]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2989
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))
  {
    /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
    framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4;
    /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */ 
    for(offset=0; offset<framelength; offset++)
  32:	3201      	adds	r2, #1
  34:	4282      	cmp	r2, r0
  36:	d3f7      	bcc.n	28 <ETH_HandlePTPRxPkt+0x28>
  38:	e000      	b.n	3c <ETH_HandlePTPRxPkt+0x3c>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2997
    }
  }
  else
  {
    /* Return ERROR */
    framelength = ETH_ERROR;
  3a:	2000      	movs	r0, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3000
  }
  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
  if ((ETH->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)
  3c:	4b1c      	ldr	r3, [pc, #112]	; (b0 <ETH_HandlePTPRxPkt+0xb0>)
  3e:	681a      	ldr	r2, [r3, #0]
  40:	f012 0f80 	tst.w	r2, #128	; 0x80
  44:	d004      	beq.n	50 <ETH_HandlePTPRxPkt+0x50>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3003
  {
    /* Clear RBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_RBUS;
  46:	2280      	movs	r2, #128	; 0x80
  48:	601a      	str	r2, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3005
    /* Resume DMA reception */
    ETH->DMARPDR = 0;
  4a:	3a80      	subs	r2, #128	; 0x80
  4c:	f843 2c0c 	str.w	r2, [r3, #-12]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3007
  }
  *PTPRxTab++ = DMARxDescToGet->Buffer1Addr;
  50:	6823      	ldr	r3, [r4, #0]
  52:	4a14      	ldr	r2, [pc, #80]	; (a4 <ETH_HandlePTPRxPkt+0xa4>)
  54:	689c      	ldr	r4, [r3, #8]
  56:	600c      	str	r4, [r1, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3008
  *PTPRxTab = DMARxDescToGet->Buffer2NextDescAddr;
  58:	68dc      	ldr	r4, [r3, #12]
  5a:	604c      	str	r4, [r1, #4]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3010
  /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMARxDescToGet->Status |= ETH_DMARxDesc_OWN;
  5c:	6819      	ldr	r1, [r3, #0]
  5e:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
  62:	6019      	str	r1, [r3, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3013
  /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */
  /* Chained Mode */
  if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RCH) != (uint32_t)RESET)
  64:	6859      	ldr	r1, [r3, #4]
  66:	f411 4f80 	tst.w	r1, #16384	; 0x4000
  6a:	d00a      	beq.n	82 <ETH_HandlePTPRxPkt+0x82>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3016
  {
    /* Selects the next DMA Rx descriptor list for next buffer read */
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMAPTPRxDescToGet->Buffer2NextDescAddr);
  6c:	4b0f      	ldr	r3, [pc, #60]	; (ac <ETH_HandlePTPRxPkt+0xac>)
  6e:	6819      	ldr	r1, [r3, #0]
  70:	68cc      	ldr	r4, [r1, #12]
  72:	6014      	str	r4, [r2, #0]
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3017
    if(DMAPTPRxDescToGet->Status != 0)
  74:	680a      	ldr	r2, [r1, #0]
  76:	b10a      	cbz	r2, 7c <ETH_HandlePTPRxPkt+0x7c>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3019
    {
      DMAPTPRxDescToGet = (ETH_DMADESCTypeDef*) (DMAPTPRxDescToGet->Status);
  78:	601a      	str	r2, [r3, #0]
  7a:	bd30      	pop	{r4, r5, pc}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3023
    }
    else
    {
      DMAPTPRxDescToGet++;
  7c:	3110      	adds	r1, #16
  7e:	6019      	str	r1, [r3, #0]
  80:	bd30      	pop	{r4, r5, pc}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3028
    }
  }
  else /* Ring Mode */
  {
    if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RER) != (uint32_t)RESET)
  82:	f411 4f00 	tst.w	r1, #32768	; 0x8000
  86:	d002      	beq.n	8e <ETH_HandlePTPRxPkt+0x8e>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3031
    {
      /* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH->DMARDLAR);
  88:	4b0a      	ldr	r3, [pc, #40]	; (b4 <ETH_HandlePTPRxPkt+0xb4>)
  8a:	681b      	ldr	r3, [r3, #0]
  8c:	e006      	b.n	9c <ETH_HandlePTPRxPkt+0x9c>
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3036
    }
    else
    {
      /* Selects the next DMA Rx descriptor list for next buffer to read */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
  8e:	490a      	ldr	r1, [pc, #40]	; (b8 <ETH_HandlePTPRxPkt+0xb8>)
  90:	3310      	adds	r3, #16
  92:	6809      	ldr	r1, [r1, #0]
  94:	f001 017c 	and.w	r1, r1, #124	; 0x7c
  98:	eb03 0391 	add.w	r3, r3, r1, lsr #2
  9c:	6013      	str	r3, [r2, #0]
  9e:	bd30      	pop	{r4, r5, pc}
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2980
  uint32_t offset = 0, framelength = 0;
  /* Check if the descriptor is owned by the ENET or CPU */
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (uint32_t)RESET)
  {
    /* Return error: OWN bit set */
    return ETH_ERROR;
  a0:	2000      	movs	r0, #0
D:\sunny\stm32\therme\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3041
      DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
    }
  }
  /* Return Frame Length/ERROR */
  return (framelength);
}
  a2:	bd30      	pop	{r4, r5, pc}
  a4:	00000000 	.word	0x00000000
  a8:	3fff0000 	.word	0x3fff0000
  ac:	00000000 	.word	0x00000000
  b0:	40029014 	.word	0x40029014
  b4:	4002900c 	.word	0x4002900c
  b8:	40029000 	.word	0x40029000
