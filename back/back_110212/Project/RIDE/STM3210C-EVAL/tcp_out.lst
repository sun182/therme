
D:\sunny\stm32\therme\Project\RIDE\STM3210C-EVAL\tcp_out.o:     file format elf32-littlearm
D:\sunny\stm32\therme\Project\RIDE\STM3210C-EVAL\tcp_out.o


Disassembly of section .text.tcp_pbuf_prealloc:

00000000 <tcp_pbuf_prealloc>:
tcp_pbuf_prealloc():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:219
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460c      	mov	r4, r1
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:231
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = TCP_MSS;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
   4:	4294      	cmp	r4, r2
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:219
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
   6:	461d      	mov	r5, r3
   8:	f89d 6014 	ldrb.w	r6, [sp, #20]
   c:	9b04      	ldr	r3, [sp, #16]
   e:	f89d 1018 	ldrb.w	r1, [sp, #24]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:231
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = TCP_MSS;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
  12:	d216      	bcs.n	42 <tcp_pbuf_prealloc+0x42>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:243
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
  14:	f016 0f02 	tst.w	r6, #2
  18:	d109      	bne.n	2e <tcp_pbuf_prealloc+0x2e>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:244
        (!(pcb->flags & TF_NODELAY) &&
  1a:	f893 6020 	ldrb.w	r6, [r3, #32]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:243
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
  1e:	f016 0f40 	tst.w	r6, #64	; 0x40
  22:	d10e      	bne.n	42 <tcp_pbuf_prealloc+0x42>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:244
        (!(pcb->flags & TF_NODELAY) &&
  24:	b119      	cbz	r1, 2e <tcp_pbuf_prealloc+0x2e>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:245
         (!first_seg ||
  26:	6f59      	ldr	r1, [r3, #116]	; 0x74
  28:	b909      	cbnz	r1, 2e <tcp_pbuf_prealloc+0x2e>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:246
          pcb->unsent != NULL ||
  2a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  2c:	b14b      	cbz	r3, 42 <tcp_pbuf_prealloc+0x42>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:248
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
  2e:	f504 61b6 	add.w	r1, r4, #1456	; 0x5b0
  32:	3107      	adds	r1, #7
  34:	f021 0103 	bic.w	r1, r1, #3
  38:	4291      	cmp	r1, r2
  3a:	bfa8      	it	ge
  3c:	4611      	movge	r1, r2
  3e:	b289      	uxth	r1, r1
  40:	e000      	b.n	44 <tcp_pbuf_prealloc+0x44>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:246
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
          pcb->unsent != NULL ||
  42:	4621      	mov	r1, r4
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:252
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
  44:	2200      	movs	r2, #0
  46:	f7ff fffe 	bl	0 <pbuf_alloc>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:253
  if (p == NULL) {
  4a:	b120      	cbz	r0, 56 <tcp_pbuf_prealloc+0x56>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:257
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
  4c:	8943      	ldrh	r3, [r0, #10]
  4e:	1b1b      	subs	r3, r3, r4
  50:	802b      	strh	r3, [r5, #0]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:259
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
  52:	8104      	strh	r4, [r0, #8]
  54:	8144      	strh	r4, [r0, #10]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:261
  return p;
}
  56:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.tcp_create_segment:

00000000 <tcp_create_segment>:
tcp_create_segment():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:157
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
   0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	f89d 9028 	ldrb.w	r9, [sp, #40]	; 0x28
   8:	4604      	mov	r4, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:159
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
   a:	f019 0b01 	ands.w	fp, r9, #1
   e:	bf18      	it	ne
  10:	f04f 0b04 	movne.w	fp, #4
  14:	f019 0802 	ands.w	r8, r9, #2
  18:	bf18      	it	ne
  1a:	f04f 080c 	movne.w	r8, #12
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:161

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
  1e:	2004      	movs	r0, #4
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:157
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  20:	460d      	mov	r5, r1
  22:	4616      	mov	r6, r2
  24:	469a      	mov	sl, r3
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:161
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
  26:	f7ff fffe 	bl	0 <memp_malloc>
  2a:	4607      	mov	r7, r0
  2c:	b918      	cbnz	r0, 36 <tcp_create_segment+0x36>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:163
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
  2e:	4628      	mov	r0, r5
  30:	f7ff fffe 	bl	0 <pbuf_free>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:164
    return NULL;
  34:	e047      	b.n	c6 <tcp_create_segment+0xc6>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:166
  }
  seg->flags = optflags;
  36:	f880 900a 	strb.w	r9, [r0, #10]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:169
  seg->next = NULL;
  seg->p = p;
  seg->len = p->tot_len - optlen;
  3a:	892b      	ldrh	r3, [r5, #8]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:159
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
  3c:	44d8      	add	r8, fp
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:169
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
  seg->p = p;
  seg->len = p->tot_len - optlen;
  3e:	ebc8 0303 	rsb	r3, r8, r3
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:167
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
  42:	f04f 0900 	mov.w	r9, #0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:168
  seg->p = p;
  46:	6045      	str	r5, [r0, #4]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:167
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
  48:	f8c0 9000 	str.w	r9, [r0]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:169
  seg->p = p;
  seg->len = p->tot_len - optlen;
  4c:	8103      	strh	r3, [r0, #8]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:182
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
  4e:	2114      	movs	r1, #20
  50:	4628      	mov	r0, r5
  52:	f7ff fffe 	bl	0 <pbuf_header>
  56:	4605      	mov	r5, r0
  58:	b120      	cbz	r0, 64 <tcp_create_segment+0x64>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:185
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
  5a:	4638      	mov	r0, r7
  5c:	f7ff fffe 	bl	0 <tcp_seg_free>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:186
    return NULL;
  60:	464f      	mov	r7, r9
  62:	e030      	b.n	c6 <tcp_create_segment+0xc6>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:188
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  64:	687b      	ldr	r3, [r7, #4]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:189
  seg->tcphdr->src = htons(pcb->local_port);
  66:	8ba0      	ldrh	r0, [r4, #28]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:188
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  68:	f8d3 9004 	ldr.w	r9, [r3, #4]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:193
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
  6c:	ea4f 0898 	mov.w	r8, r8, lsr #2
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:188
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  70:	f8c7 900c 	str.w	r9, [r7, #12]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:189
  seg->tcphdr->src = htons(pcb->local_port);
  74:	f7ff fffe 	bl	0 <lwip_htons>
  78:	f889 0000 	strb.w	r0, [r9]
  7c:	0a00      	lsrs	r0, r0, #8
  7e:	f889 0001 	strb.w	r0, [r9, #1]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:190
  seg->tcphdr->dest = htons(pcb->remote_port);
  82:	8be0      	ldrh	r0, [r4, #30]
  84:	f8d7 900c 	ldr.w	r9, [r7, #12]
  88:	f7ff fffe 	bl	0 <lwip_htons>
  8c:	f889 0002 	strb.w	r0, [r9, #2]
  90:	0a00      	lsrs	r0, r0, #8
  92:	f889 0003 	strb.w	r0, [r9, #3]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:191
  seg->tcphdr->seqno = htonl(seqno);
  96:	4650      	mov	r0, sl
  98:	68fc      	ldr	r4, [r7, #12]
  9a:	f7ff fffe 	bl	0 <lwip_htonl>
  9e:	0a03      	lsrs	r3, r0, #8
  a0:	7120      	strb	r0, [r4, #4]
  a2:	7163      	strb	r3, [r4, #5]
  a4:	0c03      	lsrs	r3, r0, #16
  a6:	0e00      	lsrs	r0, r0, #24
  a8:	71e0      	strb	r0, [r4, #7]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:193
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
  aa:	f108 0005 	add.w	r0, r8, #5
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:191
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
  ae:	71a3      	strb	r3, [r4, #6]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:193
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
  b0:	ea46 3000 	orr.w	r0, r6, r0, lsl #12
  b4:	68fc      	ldr	r4, [r7, #12]
  b6:	f7ff fffe 	bl	0 <lwip_htons>
  ba:	7320      	strb	r0, [r4, #12]
  bc:	0a00      	lsrs	r0, r0, #8
  be:	7360      	strb	r0, [r4, #13]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:195
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
  c0:	68fb      	ldr	r3, [r7, #12]
  c2:	749d      	strb	r5, [r3, #18]
  c4:	74dd      	strb	r5, [r3, #19]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:197
  return seg;
} 
  c6:	4638      	mov	r0, r7
  c8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text.tcp_output_alloc_header.clone.0:

00000000 <tcp_output_alloc_header.clone.0>:
tcp_output_alloc_header():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:96
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
   0:	3114      	adds	r1, #20
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:92
 * @param datalen length of tcp data to reserve in pbuf
 * @param seqno_be seqno in network byte order (big-endian)
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
   2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:96
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
   6:	b289      	uxth	r1, r1
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:92
 * @param datalen length of tcp data to reserve in pbuf
 * @param seqno_be seqno in network byte order (big-endian)
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
   8:	4604      	mov	r4, r0
   a:	4615      	mov	r5, r2
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:96
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
   c:	2001      	movs	r0, #1
   e:	2200      	movs	r2, #0
  10:	f7ff fffe 	bl	0 <pbuf_alloc>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:97
  if (p != NULL) {
  14:	4680      	mov	r8, r0
  16:	2800      	cmp	r0, #0
  18:	d033      	beq.n	82 <tcp_output_alloc_header.clone.0+0x82>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:100
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
  1a:	6846      	ldr	r6, [r0, #4]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:101
    tcphdr->src = htons(pcb->local_port);
  1c:	8ba0      	ldrh	r0, [r4, #28]
  1e:	f7ff fffe 	bl	0 <lwip_htons>
  22:	7030      	strb	r0, [r6, #0]
  24:	0a00      	lsrs	r0, r0, #8
  26:	7070      	strb	r0, [r6, #1]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:102
    tcphdr->dest = htons(pcb->remote_port);
  28:	8be0      	ldrh	r0, [r4, #30]
  2a:	f7ff fffe 	bl	0 <lwip_htons>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:103
    tcphdr->seqno = seqno_be;
  2e:	0a2b      	lsrs	r3, r5, #8
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:102
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
  30:	70b0      	strb	r0, [r6, #2]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:103
    tcphdr->seqno = seqno_be;
  32:	7135      	strb	r5, [r6, #4]
  34:	7173      	strb	r3, [r6, #5]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:102
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
  36:	0a00      	lsrs	r0, r0, #8
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:103
    tcphdr->seqno = seqno_be;
  38:	0c2b      	lsrs	r3, r5, #16
  3a:	0e2d      	lsrs	r5, r5, #24
  3c:	71b3      	strb	r3, [r6, #6]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:102
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
  3e:	70f0      	strb	r0, [r6, #3]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:103
    tcphdr->seqno = seqno_be;
  40:	71f5      	strb	r5, [r6, #7]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:104
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  42:	6a60      	ldr	r0, [r4, #36]	; 0x24
  44:	f7ff fffe 	bl	0 <lwip_htonl>
  48:	0a03      	lsrs	r3, r0, #8
  4a:	7230      	strb	r0, [r6, #8]
  4c:	7273      	strb	r3, [r6, #9]
  4e:	0c03      	lsrs	r3, r0, #16
  50:	0e00      	lsrs	r0, r0, #24
  52:	72b3      	strb	r3, [r6, #10]
  54:	72f0      	strb	r0, [r6, #11]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:105
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
  56:	f245 0010 	movw	r0, #20496	; 0x5010
  5a:	f7ff fffe 	bl	0 <lwip_htons>
  5e:	7330      	strb	r0, [r6, #12]
  60:	0a00      	lsrs	r0, r0, #8
  62:	7370      	strb	r0, [r6, #13]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:106
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  64:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
  66:	f7ff fffe 	bl	0 <lwip_htons>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:101
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
  6a:	2700      	movs	r7, #0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:106
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  6c:	73b0      	strb	r0, [r6, #14]
  6e:	0a00      	lsrs	r0, r0, #8
  70:	73f0      	strb	r0, [r6, #15]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:107
    tcphdr->chksum = 0;
  72:	7437      	strb	r7, [r6, #16]
  74:	7477      	strb	r7, [r6, #17]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:108
    tcphdr->urgp = 0;
  76:	74b7      	strb	r7, [r6, #18]
  78:	74f7      	strb	r7, [r6, #19]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:111

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
  7a:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
  7c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  7e:	18d3      	adds	r3, r2, r3
  80:	62e3      	str	r3, [r4, #44]	; 0x2c
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:114
  }
  return p;
}
  82:	4640      	mov	r0, r8
  84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.tcp_write:

00000000 <tcp_write>:
tcp_write():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:352
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4692      	mov	sl, r2
   6:	b08d      	sub	sp, #52	; 0x34
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:360
  u16_t pos = 0; /* position in 'arg' data */
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
   8:	2200      	movs	r2, #0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:352
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
   a:	4604      	mov	r4, r0
   c:	9304      	str	r3, [sp, #16]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:360
  u16_t pos = 0; /* position in 'arg' data */
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
   e:	f8ad 202e 	strh.w	r2, [sp, #46]	; 0x2e
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:377
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
  12:	9106      	str	r1, [sp, #24]
  14:	2900      	cmp	r1, #0
  16:	f000 8161 	beq.w	2dc <tcp_write+0x2dc>
tcp_write_checks():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:294
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
  1a:	7c03      	ldrb	r3, [r0, #16]
  1c:	2b04      	cmp	r3, #4
  1e:	d005      	beq.n	2c <tcp_write+0x2c>
  20:	2b07      	cmp	r3, #7
  22:	d003      	beq.n	2c <tcp_write+0x2c>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:295
      (pcb->state != CLOSE_WAIT) &&
  24:	2b02      	cmp	r3, #2
  26:	d001      	beq.n	2c <tcp_write+0x2c>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:296
      (pcb->state != SYN_SENT) &&
  28:	2b03      	cmp	r3, #3
  2a:	d113      	bne.n	54 <tcp_write+0x54>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:300
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  } else if (len == 0) {
  2c:	f1ba 0f00 	cmp.w	sl, #0
  30:	f000 8163 	beq.w	2fa <tcp_write+0x2fa>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:305
    return ERR_OK;
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
  34:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
  38:	4553      	cmp	r3, sl
  3a:	d304      	bcc.n	46 <tcp_write+0x46>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:317
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  3c:	f8b4 3070 	ldrh.w	r3, [r4, #112]	; 0x70
  40:	2b0b      	cmp	r3, #11
  42:	f240 815a 	bls.w	2fa <tcp_write+0x2fa>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:321
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
      pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  46:	f894 3020 	ldrb.w	r3, [r4, #32]
  4a:	f063 037f 	orn	r3, r3, #127	; 0x7f
  4e:	f884 3020 	strb.w	r3, [r4, #32]
  52:	e14b      	b.n	2ec <tcp_write+0x2ec>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:299
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  54:	f04f 09f3 	mov.w	r9, #243	; 0xf3
  58:	e14a      	b.n	2f0 <tcp_write+0x2f0>
tcp_write():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:422
  if (pcb->unsent != NULL) {
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
  5a:	461e      	mov	r6, r3
  5c:	6833      	ldr	r3, [r6, #0]
  5e:	2b00      	cmp	r3, #0
  60:	d1fb      	bne.n	5a <tcp_write+0x5a>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:426
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
  62:	7ab3      	ldrb	r3, [r6, #10]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:427
    space = pcb->mss - (last_unsent->len + unsent_optlen);
  64:	8937      	ldrh	r7, [r6, #8]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:426
    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
  66:	8f22      	ldrh	r2, [r4, #56]	; 0x38
  68:	f013 0101 	ands.w	r1, r3, #1
  6c:	bf18      	it	ne
  6e:	2104      	movne	r1, #4
  70:	1bd2      	subs	r2, r2, r7
  72:	f013 0302 	ands.w	r3, r3, #2
  76:	bf18      	it	ne
  78:	230c      	movne	r3, #12
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:427
    space = pcb->mss - (last_unsent->len + unsent_optlen);
  7a:	1a52      	subs	r2, r2, r1
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:442
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
  7c:	f8b4 5072 	ldrh.w	r5, [r4, #114]	; 0x72
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:427
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    space = pcb->mss - (last_unsent->len + unsent_optlen);
  80:	1ad2      	subs	r2, r2, r3
  82:	b292      	uxth	r2, r2
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:442
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
  84:	f8ad 502e 	strh.w	r5, [sp, #46]	; 0x2e
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:443
    if (oversize > 0) {
  88:	b15d      	cbz	r5, a2 <tcp_write+0xa2>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:446
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
      oversize_used = oversize < len ? oversize : len;
  8a:	45aa      	cmp	sl, r5
  8c:	bf34      	ite	cc
  8e:	4653      	movcc	r3, sl
  90:	462b      	movcs	r3, r5
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:448
      pos += oversize_used;
      oversize -= oversize_used;
  92:	1aed      	subs	r5, r5, r3
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:449
      space -= oversize_used;
  94:	1ad2      	subs	r2, r2, r3
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:448
    if (oversize > 0) {
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
      oversize_used = oversize < len ? oversize : len;
      pos += oversize_used;
      oversize -= oversize_used;
  96:	f8ad 502e 	strh.w	r5, [sp, #46]	; 0x2e
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:449
      space -= oversize_used;
  9a:	b292      	uxth	r2, r2
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:447
    oversize = pcb->unsent_oversize;
    if (oversize > 0) {
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
      oversize_used = oversize < len ? oversize : len;
      pos += oversize_used;
  9c:	461d      	mov	r5, r3
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:449
      oversize -= oversize_used;
      space -= oversize_used;
  9e:	46b1      	mov	r9, r6
  a0:	e000      	b.n	a4 <tcp_write+0xa4>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:354
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
  a2:	46a9      	mov	r9, r5
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:462
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
  a4:	4555      	cmp	r5, sl
  a6:	d23d      	bcs.n	124 <tcp_write+0x124>
  a8:	2a00      	cmp	r2, #0
  aa:	d03e      	beq.n	12a <tcp_write+0x12a>
  ac:	2f00      	cmp	r7, #0
  ae:	d03f      	beq.n	130 <tcp_write+0x130>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:469
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
  b0:	9b04      	ldr	r3, [sp, #16]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:463
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
      u16_t seglen = space < len - pos ? space : len - pos;
  b2:	ebc5 080a 	rsb	r8, r5, sl
  b6:	4590      	cmp	r8, r2
  b8:	bfa8      	it	ge
  ba:	4690      	movge	r8, r2
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:469
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
  bc:	f013 0f01 	tst.w	r3, #1
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:463
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
      u16_t seglen = space < len - pos ? space : len - pos;
  c0:	fa1f f888 	uxth.w	r8, r8
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:469
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
  c4:	d014      	beq.n	f0 <tcp_write+0xf0>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:471
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
  c6:	9301      	str	r3, [sp, #4]
  c8:	2301      	movs	r3, #1
  ca:	9302      	str	r3, [sp, #8]
  cc:	2003      	movs	r0, #3
  ce:	4641      	mov	r1, r8
  d0:	f10d 032e 	add.w	r3, sp, #46	; 0x2e
  d4:	9400      	str	r4, [sp, #0]
  d6:	f7ff fffe 	bl	0 <tcp_write>
  da:	4607      	mov	r7, r0
  dc:	2800      	cmp	r0, #0
  de:	f000 80e9 	beq.w	2b4 <tcp_write+0x2b4>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:480
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        last_unsent->oversize_left = oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
  e2:	9a06      	ldr	r2, [sp, #24]
  e4:	6840      	ldr	r0, [r0, #4]
  e6:	1951      	adds	r1, r2, r5
  e8:	4642      	mov	r2, r8
  ea:	f7ff fffe 	bl	0 <memcpy>
  ee:	e00b      	b.n	108 <tcp_write+0x108>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:486
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
  f0:	2003      	movs	r0, #3
  f2:	4641      	mov	r1, r8
  f4:	2201      	movs	r2, #1
  f6:	f7ff fffe 	bl	0 <pbuf_alloc>
  fa:	4607      	mov	r7, r0
  fc:	2800      	cmp	r0, #0
  fe:	f000 80d9 	beq.w	2b4 <tcp_write+0x2b4>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:498
        tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
          &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
 102:	9a06      	ldr	r2, [sp, #24]
 104:	1953      	adds	r3, r2, r5
 106:	6043      	str	r3, [r0, #4]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:502
      }

      pos += seglen;
      queuelen += pbuf_clen(concat_p);
 108:	4638      	mov	r0, r7
 10a:	f7ff fffe 	bl	0 <pbuf_clen>
 10e:	9b05      	ldr	r3, [sp, #20]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:501
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
      }

      pos += seglen;
 110:	44a8      	add	r8, r5
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:502
      queuelen += pbuf_clen(concat_p);
 112:	18c0      	adds	r0, r0, r3
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:501
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
      }

      pos += seglen;
 114:	fa1f f888 	uxth.w	r8, r8
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:502
      queuelen += pbuf_clen(concat_p);
 118:	b280      	uxth	r0, r0
 11a:	46ab      	mov	fp, r5
 11c:	9005      	str	r0, [sp, #20]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:501
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
      }

      pos += seglen;
 11e:	4645      	mov	r5, r8
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:502
      queuelen += pbuf_clen(concat_p);
 120:	46b1      	mov	r9, r6
 122:	e006      	b.n	132 <tcp_write+0x132>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:462
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 124:	46ab      	mov	fp, r5
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:353
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
 126:	2700      	movs	r7, #0
 128:	e003      	b.n	132 <tcp_write+0x132>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:462
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 12a:	46ab      	mov	fp, r5
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:353
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
 12c:	4617      	mov	r7, r2
 12e:	e000      	b.n	132 <tcp_write+0x132>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:462
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 130:	46ab      	mov	fp, r5
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:594
    seg->chksum_swapped = chksum_swapped;
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 132:	f04f 0800 	mov.w	r8, #0
 136:	4648      	mov	r0, r9
 138:	f8cd 8020 	str.w	r8, [sp, #32]
 13c:	9707      	str	r7, [sp, #28]
 13e:	9609      	str	r6, [sp, #36]	; 0x24
 140:	46d9      	mov	r9, fp
 142:	e05f      	b.n	204 <tcp_write+0x204>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:520
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
    struct pbuf *p;
    u16_t left = len - pos;
    u16_t max_len = pcb->mss - optlen;
 144:	8f22      	ldrh	r2, [r4, #56]	; 0x38
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:519
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
    struct pbuf *p;
    u16_t left = len - pos;
 146:	ebc5 0b0a 	rsb	fp, r5, sl
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:527
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
    u8_t chksum_swapped = 0;
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
 14a:	9b04      	ldr	r3, [sp, #16]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:521
   */
  while (pos < len) {
    struct pbuf *p;
    u16_t left = len - pos;
    u16_t max_len = pcb->mss - optlen;
    u16_t seglen = left > max_len ? max_len : left;
 14c:	fa1f fb8b 	uxth.w	fp, fp
 150:	4593      	cmp	fp, r2
 152:	bf28      	it	cs
 154:	4693      	movcs	fp, r2
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:527
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
    u8_t chksum_swapped = 0;
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
 156:	f013 0601 	ands.w	r6, r3, #1
 15a:	d017      	beq.n	18c <tcp_write+0x18c>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:530
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, pcb->mss, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 15c:	9301      	str	r3, [sp, #4]
 15e:	f1d8 0301 	rsbs	r3, r8, #1
 162:	bf38      	it	cc
 164:	2300      	movcc	r3, #0
 166:	9302      	str	r3, [sp, #8]
 168:	2000      	movs	r0, #0
 16a:	4659      	mov	r1, fp
 16c:	f10d 032e 	add.w	r3, sp, #46	; 0x2e
 170:	9400      	str	r4, [sp, #0]
 172:	f7ff fffe 	bl	0 <tcp_write>
 176:	4606      	mov	r6, r0
 178:	2800      	cmp	r0, #0
 17a:	f000 809d 	beq.w	2b8 <tcp_write+0x2b8>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:536
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
 17e:	9a06      	ldr	r2, [sp, #24]
 180:	6840      	ldr	r0, [r0, #4]
 182:	1951      	adds	r1, r2, r5
 184:	465a      	mov	r2, fp
 186:	f7ff fffe 	bl	0 <memcpy>
 18a:	e019      	b.n	1c0 <tcp_write+0x1c0>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:547
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 18c:	4630      	mov	r0, r6
 18e:	4659      	mov	r1, fp
 190:	2201      	movs	r2, #1
 192:	f7ff fffe 	bl	0 <pbuf_alloc>
 196:	4607      	mov	r7, r0
 198:	2800      	cmp	r0, #0
 19a:	f000 808d 	beq.w	2b8 <tcp_write+0x2b8>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:556
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      p2->payload = (u8_t*)arg + pos;
 19e:	9a06      	ldr	r2, [sp, #24]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:559

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 1a0:	4631      	mov	r1, r6
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:556
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      p2->payload = (u8_t*)arg + pos;
 1a2:	1953      	adds	r3, r2, r5
 1a4:	6043      	str	r3, [r0, #4]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:559

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 1a6:	4632      	mov	r2, r6
 1a8:	4630      	mov	r0, r6
 1aa:	f7ff fffe 	bl	0 <pbuf_alloc>
 1ae:	4606      	mov	r6, r0
 1b0:	b918      	cbnz	r0, 1ba <tcp_write+0x1ba>
 1b2:	463b      	mov	r3, r7
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:562
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
 1b4:	4618      	mov	r0, r3
 1b6:	9f07      	ldr	r7, [sp, #28]
 1b8:	e00d      	b.n	1d6 <tcp_write+0x1d6>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:567
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
 1ba:	4639      	mov	r1, r7
 1bc:	f7ff fffe 	bl	0 <pbuf_cat>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:570
    }

    queuelen += pbuf_clen(p);
 1c0:	4630      	mov	r0, r6
 1c2:	f7ff fffe 	bl	0 <pbuf_clen>
 1c6:	9b05      	ldr	r3, [sp, #20]
 1c8:	18c0      	adds	r0, r0, r3
 1ca:	b280      	uxth	r0, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:575

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 1cc:	280c      	cmp	r0, #12
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:570
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
    }

    queuelen += pbuf_clen(p);
 1ce:	9005      	str	r0, [sp, #20]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:575

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 1d0:	d904      	bls.n	1dc <tcp_write+0x1dc>
 1d2:	9f07      	ldr	r7, [sp, #28]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:577
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
 1d4:	4630      	mov	r0, r6
 1d6:	f7ff fffe 	bl	0 <pbuf_free>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:578
      goto memerr;
 1da:	e06e      	b.n	2ba <tcp_write+0x2ba>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:581
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 1dc:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 1de:	2200      	movs	r2, #0
 1e0:	4620      	mov	r0, r4
 1e2:	4631      	mov	r1, r6
 1e4:	18eb      	adds	r3, r5, r3
 1e6:	9200      	str	r2, [sp, #0]
 1e8:	f7ff fffe 	bl	0 <tcp_write>
 1ec:	2800      	cmp	r0, #0
 1ee:	d063      	beq.n	2b8 <tcp_write+0x2b8>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:594
    seg->chksum_swapped = chksum_swapped;
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 1f0:	f1b8 0f00 	cmp.w	r8, #0
 1f4:	d002      	beq.n	1fc <tcp_write+0x1fc>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:599
      queue = seg;
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
      prev_seg->next = seg;
 1f6:	9a08      	ldr	r2, [sp, #32]
 1f8:	6010      	str	r0, [r2, #0]
 1fa:	e000      	b.n	1fe <tcp_write+0x1fe>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:594
    seg->chksum_swapped = chksum_swapped;
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 1fc:	4680      	mov	r8, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:608

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
 1fe:	445d      	add	r5, fp
 200:	b2ad      	uxth	r5, r5
 202:	9008      	str	r0, [sp, #32]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:517
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 204:	4555      	cmp	r5, sl
 206:	d39d      	bcc.n	144 <tcp_write+0x144>
 208:	46cb      	mov	fp, r9
 20a:	9f07      	ldr	r7, [sp, #28]
 20c:	9e09      	ldr	r6, [sp, #36]	; 0x24
 20e:	4681      	mov	r9, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:621
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 210:	f1bb 0f00 	cmp.w	fp, #0
 214:	d017      	beq.n	246 <tcp_write+0x246>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:624
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 216:	6875      	ldr	r5, [r6, #4]
 218:	e00f      	b.n	23a <tcp_write+0x23a>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:625
      p->tot_len += oversize_used;
 21a:	892b      	ldrh	r3, [r5, #8]
 21c:	445b      	add	r3, fp
 21e:	812b      	strh	r3, [r5, #8]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:626
      if (p->next == NULL) {
 220:	682b      	ldr	r3, [r5, #0]
 222:	b94b      	cbnz	r3, 238 <tcp_write+0x238>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:627
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 224:	896b      	ldrh	r3, [r5, #10]
 226:	6868      	ldr	r0, [r5, #4]
 228:	9906      	ldr	r1, [sp, #24]
 22a:	18c0      	adds	r0, r0, r3
 22c:	465a      	mov	r2, fp
 22e:	f7ff fffe 	bl	0 <memcpy>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:628
        p->len += oversize_used;
 232:	896b      	ldrh	r3, [r5, #10]
 234:	445b      	add	r3, fp
 236:	816b      	strh	r3, [r5, #10]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:624
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 238:	682d      	ldr	r5, [r5, #0]
 23a:	2d00      	cmp	r5, #0
 23c:	d1ed      	bne.n	21a <tcp_write+0x21a>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:631
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
      }
    }
    last_unsent->len += oversize_used;
 23e:	8933      	ldrh	r3, [r6, #8]
 240:	449b      	add	fp, r3
 242:	f8a6 b008 	strh.w	fp, [r6, #8]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:636
#if TCP_OVERSIZE_DBGCHECK
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 246:	f8bd 302e 	ldrh.w	r3, [sp, #46]	; 0x2e
 24a:	f8a4 3072 	strh.w	r3, [r4, #114]	; 0x72
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:642
#endif /* TCP_OVERSIZE */

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
 24e:	b13f      	cbz	r7, 260 <tcp_write+0x260>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:645
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
      (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
 250:	6870      	ldr	r0, [r6, #4]
 252:	4639      	mov	r1, r7
 254:	f7ff fffe 	bl	0 <pbuf_cat>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:646
    last_unsent->len += concat_p->tot_len;
 258:	893a      	ldrh	r2, [r7, #8]
 25a:	8933      	ldrh	r3, [r6, #8]
 25c:	18d3      	adds	r3, r2, r3
 25e:	8133      	strh	r3, [r6, #8]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:660

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
 260:	b916      	cbnz	r6, 268 <tcp_write+0x268>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:661
    pcb->unsent = queue;
 262:	f8c4 8074 	str.w	r8, [r4, #116]	; 0x74
 266:	e001      	b.n	26c <tcp_write+0x26c>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:663
  } else {
    last_unsent->next = queue;
 268:	f8c6 8000 	str.w	r8, [r6]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:669
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 26c:	6ea3      	ldr	r3, [r4, #104]	; 0x68
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:671
  pcb->snd_buf -= len;
  pcb->snd_queuelen = queuelen;
 26e:	9a05      	ldr	r2, [sp, #20]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:669
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 270:	4453      	add	r3, sl
 272:	66a3      	str	r3, [r4, #104]	; 0x68
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:670
  pcb->snd_buf -= len;
 274:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:671
  pcb->snd_queuelen = queuelen;
 278:	f8a4 2070 	strh.w	r2, [r4, #112]	; 0x70
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:670

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
  pcb->snd_buf -= len;
 27c:	ebca 0a03 	rsb	sl, sl, r3
 280:	f8a4 a06e 	strh.w	sl, [r4, #110]	; 0x6e
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:681
    LWIP_ASSERT("tcp_write: valid queue length",
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
 284:	f1b9 0f00 	cmp.w	r9, #0
 288:	d032      	beq.n	2f0 <tcp_write+0x2f0>
 28a:	f8d9 400c 	ldr.w	r4, [r9, #12]
 28e:	b344      	cbz	r4, 2e2 <tcp_write+0x2e2>
 290:	9b04      	ldr	r3, [sp, #16]
 292:	f013 0902 	ands.w	r9, r3, #2
 296:	d126      	bne.n	2e6 <tcp_write+0x2e6>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:682
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 298:	7b23      	ldrb	r3, [r4, #12]
 29a:	7b65      	ldrb	r5, [r4, #13]
 29c:	2008      	movs	r0, #8
 29e:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
 2a2:	f7ff fffe 	bl	0 <lwip_htons>
 2a6:	ea40 0505 	orr.w	r5, r0, r5
 2aa:	b2ad      	uxth	r5, r5
 2ac:	7325      	strb	r5, [r4, #12]
 2ae:	0a2d      	lsrs	r5, r5, #8
 2b0:	7365      	strb	r5, [r4, #13]
 2b2:	e01d      	b.n	2f0 <tcp_write+0x2f0>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:354
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 2b4:	46b8      	mov	r8, r7
 2b6:	e000      	b.n	2ba <tcp_write+0x2ba>
 2b8:	9f07      	ldr	r7, [sp, #28]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:687
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
 2ba:	f894 3020 	ldrb.w	r3, [r4, #32]
 2be:	f063 037f 	orn	r3, r3, #127	; 0x7f
 2c2:	f884 3020 	strb.w	r3, [r4, #32]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:690
  TCP_STATS_INC(tcp.memerr);

  if (concat_p != NULL) {
 2c6:	b117      	cbz	r7, 2ce <tcp_write+0x2ce>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:691
    pbuf_free(concat_p);
 2c8:	4638      	mov	r0, r7
 2ca:	f7ff fffe 	bl	0 <pbuf_free>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:693
  }
  if (queue != NULL) {
 2ce:	f1b8 0f00 	cmp.w	r8, #0
 2d2:	d00b      	beq.n	2ec <tcp_write+0x2ec>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:694
    tcp_segs_free(queue);
 2d4:	4640      	mov	r0, r8
 2d6:	f7ff fffe 	bl	0 <tcp_segs_free>
 2da:	e007      	b.n	2ec <tcp_write+0x2ec>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:377
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
 2dc:	f04f 09f2 	mov.w	r9, #242	; 0xf2
 2e0:	e006      	b.n	2f0 <tcp_write+0x2f0>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:685
  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
 2e2:	46a1      	mov	r9, r4
 2e4:	e004      	b.n	2f0 <tcp_write+0x2f0>
 2e6:	f04f 0900 	mov.w	r9, #0
 2ea:	e001      	b.n	2f0 <tcp_write+0x2f0>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:701
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 2ec:	f04f 09ff 	mov.w	r9, #255	; 0xff
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:702
}
 2f0:	fa4f f089 	sxtb.w	r0, r9
 2f4:	b00d      	add	sp, #52	; 0x34
 2f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:384

  err = tcp_write_checks(pcb, len);
  if (err != ERR_OK) {
    return err;
  }
  queuelen = pcb->snd_queuelen;
 2fa:	f8b4 2070 	ldrh.w	r2, [r4, #112]	; 0x70
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:417
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 2fe:	6f66      	ldr	r6, [r4, #116]	; 0x74
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:384

  err = tcp_write_checks(pcb, len);
  if (err != ERR_OK) {
    return err;
  }
  queuelen = pcb->snd_queuelen;
 300:	9205      	str	r2, [sp, #20]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:417
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 302:	2e00      	cmp	r6, #0
 304:	f47f aeaa 	bne.w	5c <tcp_write+0x5c>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:361
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
  u16_t oversize_used = 0;
 308:	46b3      	mov	fp, r6
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:355
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
  u16_t pos = 0; /* position in 'arg' data */
 30a:	4635      	mov	r5, r6
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:354
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 30c:	46b1      	mov	r9, r6
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:353
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
 30e:	4637      	mov	r7, r6
 310:	e70f      	b.n	132 <tcp_write+0x132>

Disassembly of section .text.tcp_enqueue_flags:

00000000 <tcp_enqueue_flags>:
tcp_enqueue_flags():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:728

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
   0:	f8b0 3070 	ldrh.w	r3, [r0, #112]	; 0x70
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:716
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
   4:	b573      	push	{r0, r1, r4, r5, r6, lr}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:728

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
   6:	2b0b      	cmp	r3, #11
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:716
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
   8:	4604      	mov	r4, r0
   a:	460e      	mov	r6, r1
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:728

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
   c:	d80c      	bhi.n	28 <tcp_enqueue_flags+0x28>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:750

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
   e:	f8b0 306e 	ldrh.w	r3, [r0, #110]	; 0x6e
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:715
 * @param flags TCP header flags to set in the outgoing segment.
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
  12:	f3c1 0540 	ubfx	r5, r1, #1, #1
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:744
#if LWIP_TCP_TIMESTAMPS
  if ((pcb->flags & TF_TIMESTAMP)) {
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
  16:	00a9      	lsls	r1, r5, #2
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:750

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
  18:	2b00      	cmp	r3, #0
  1a:	d044      	beq.n	a6 <tcp_enqueue_flags+0xa6>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:757
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  1c:	2000      	movs	r0, #0
  1e:	4602      	mov	r2, r0
  20:	f7ff fffe 	bl	0 <pbuf_alloc>
  24:	4601      	mov	r1, r0
  26:	b930      	cbnz	r0, 36 <tcp_enqueue_flags+0x36>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:758
    pcb->flags |= TF_NAGLEMEMERR;
  28:	f894 3020 	ldrb.w	r3, [r4, #32]
  2c:	f063 037f 	orn	r3, r3, #127	; 0x7f
  30:	f884 3020 	strb.w	r3, [r4, #32]
  34:	e037      	b.n	a6 <tcp_enqueue_flags+0xa6>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:766
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
  36:	4620      	mov	r0, r4
  38:	4632      	mov	r2, r6
  3a:	6ea3      	ldr	r3, [r4, #104]	; 0x68
  3c:	9500      	str	r5, [sp, #0]
  3e:	f7ff fffe 	bl	0 <tcp_enqueue_flags>
  42:	b938      	cbnz	r0, 54 <tcp_enqueue_flags+0x54>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:767
    pcb->flags |= TF_NAGLEMEMERR;
  44:	f894 3020 	ldrb.w	r3, [r4, #32]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:769
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  48:	30ff      	adds	r0, #255	; 0xff
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:767
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
  4a:	f063 037f 	orn	r3, r3, #127	; 0x7f
  4e:	f884 3020 	strb.w	r3, [r4, #32]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:769
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  52:	e029      	b.n	a8 <tcp_enqueue_flags+0xa8>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:781
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
  54:	6f63      	ldr	r3, [r4, #116]	; 0x74
  56:	b913      	cbnz	r3, 5e <tcp_enqueue_flags+0x5e>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:782
    pcb->unsent = seg;
  58:	6760      	str	r0, [r4, #116]	; 0x74
  5a:	e004      	b.n	66 <tcp_enqueue_flags+0x66>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:785
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  5c:	4613      	mov	r3, r2
  5e:	681a      	ldr	r2, [r3, #0]
  60:	2a00      	cmp	r2, #0
  62:	d1fb      	bne.n	5c <tcp_enqueue_flags+0x5c>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:786
    useg->next = seg;
  64:	6018      	str	r0, [r3, #0]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:790
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
  66:	2300      	movs	r3, #0
  68:	f8a4 3072 	strh.w	r3, [r4, #114]	; 0x72
  6c:	f006 0601 	and.w	r6, r6, #1
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:794
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  70:	b905      	cbnz	r5, 74 <tcp_enqueue_flags+0x74>
  72:	b13e      	cbz	r6, 84 <tcp_enqueue_flags+0x84>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:795
    pcb->snd_lbb++;
  74:	6ea3      	ldr	r3, [r4, #104]	; 0x68
  76:	3301      	adds	r3, #1
  78:	66a3      	str	r3, [r4, #104]	; 0x68
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:797
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
  7a:	f8b4 306e 	ldrh.w	r3, [r4, #110]	; 0x6e
  7e:	3b01      	subs	r3, #1
  80:	f8a4 306e 	strh.w	r3, [r4, #110]	; 0x6e
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:799
  }
  if (flags & TCP_FIN) {
  84:	b12e      	cbz	r6, 92 <tcp_enqueue_flags+0x92>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:800
    pcb->flags |= TF_FIN;
  86:	f894 3020 	ldrb.w	r3, [r4, #32]
  8a:	f043 0320 	orr.w	r3, r3, #32
  8e:	f884 3020 	strb.w	r3, [r4, #32]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:804
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
  92:	6840      	ldr	r0, [r0, #4]
  94:	f8b4 5070 	ldrh.w	r5, [r4, #112]	; 0x70
  98:	f7ff fffe 	bl	0 <pbuf_clen>
  9c:	1940      	adds	r0, r0, r5
  9e:	f8a4 0070 	strh.w	r0, [r4, #112]	; 0x70
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:811
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
  a2:	2000      	movs	r0, #0
  a4:	e000      	b.n	a8 <tcp_enqueue_flags+0xa8>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:753
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  a6:	20ff      	movs	r0, #255	; 0xff
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:812
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
}
  a8:	b240      	sxtb	r0, r0
  aa:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}

Disassembly of section .text.tcp_send_fin:

00000000 <tcp_send_fin>:
tcp_send_fin():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:124
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:126
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
   2:	6f44      	ldr	r4, [r0, #116]	; 0x74
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:124
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
   4:	4605      	mov	r5, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:126
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
   6:	b90c      	cbnz	r4, c <tcp_send_fin+0xc>
   8:	e01d      	b.n	46 <tcp_send_fin+0x46>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:128
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
   a:	461c      	mov	r4, r3
   c:	6823      	ldr	r3, [r4, #0]
   e:	2b00      	cmp	r3, #0
  10:	d1fb      	bne.n	a <tcp_send_fin+0xa>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:131
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
  12:	68e3      	ldr	r3, [r4, #12]
  14:	7b1a      	ldrb	r2, [r3, #12]
  16:	7b58      	ldrb	r0, [r3, #13]
  18:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  1c:	f7ff fffe 	bl	0 <lwip_ntohs>
  20:	f010 0607 	ands.w	r6, r0, #7
  24:	d10f      	bne.n	46 <tcp_send_fin+0x46>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:133
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
  26:	68e4      	ldr	r4, [r4, #12]
  28:	2001      	movs	r0, #1
  2a:	7b23      	ldrb	r3, [r4, #12]
  2c:	7b65      	ldrb	r5, [r4, #13]
  2e:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
  32:	f7ff fffe 	bl	0 <lwip_htons>
  36:	ea40 0505 	orr.w	r5, r0, r5
  3a:	b2ad      	uxth	r5, r5
  3c:	7325      	strb	r5, [r4, #12]
  3e:	0a2d      	lsrs	r5, r5, #8
  40:	7365      	strb	r5, [r4, #13]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:139
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
}
  42:	4630      	mov	r0, r6
  44:	bd70      	pop	{r4, r5, r6, pc}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:138
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
  46:	4628      	mov	r0, r5
  48:	2101      	movs	r1, #1
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:139
}
  4a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:138
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
  4e:	f7ff bffe 	b.w	0 <tcp_send_fin>

Disassembly of section .text.tcp_send_empty_ack:

00000000 <tcp_send_empty_ack>:
tcp_send_empty_ack():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:837
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
   0:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2:	4605      	mov	r5, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:848
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
   4:	6d80      	ldr	r0, [r0, #88]	; 0x58
   6:	f7ff fffe 	bl	0 <lwip_htonl>
   a:	2100      	movs	r1, #0
   c:	4602      	mov	r2, r0
   e:	4628      	mov	r0, r5
  10:	f7ff fffe 	bl	0 <tcp_send_empty_ack>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:849
  if (p == NULL) {
  14:	4604      	mov	r4, r0
  16:	b198      	cbz	r0, 40 <tcp_send_empty_ack+0x40>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:857
  }
  tcphdr = (struct tcp_hdr *)p->payload;
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  18:	f895 3020 	ldrb.w	r3, [r5, #32]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:876
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  1c:	7a6a      	ldrb	r2, [r5, #9]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:857
  }
  tcphdr = (struct tcp_hdr *)p->payload;
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  1e:	f023 0303 	bic.w	r3, r3, #3
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:876
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  22:	9200      	str	r2, [sp, #0]
  24:	2206      	movs	r2, #6
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:857
  }
  tcphdr = (struct tcp_hdr *)p->payload;
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  26:	f885 3020 	strb.w	r3, [r5, #32]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:876
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  2a:	9201      	str	r2, [sp, #4]
  2c:	7aab      	ldrb	r3, [r5, #10]
  2e:	4629      	mov	r1, r5
  30:	1d2a      	adds	r2, r5, #4
  32:	f7ff fffe 	bl	0 <ip_output>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:879
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
  36:	4620      	mov	r0, r4
  38:	f7ff fffe 	bl	0 <pbuf_free>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:881

  return ERR_OK;
  3c:	2000      	movs	r0, #0
  3e:	e000      	b.n	42 <tcp_send_empty_ack+0x42>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:851
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
  if (p == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
  40:	20fe      	movs	r0, #254	; 0xfe
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:882
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);

  return ERR_OK;
}
  42:	b240      	sxtb	r0, r0
  44:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

Disassembly of section .text.tcp_output:

00000000 <tcp_output>:
tcp_output():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:904

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
   0:	4b96      	ldr	r3, [pc, #600]	; (25c <tcp_output+0x25c>)
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:893
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
   2:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:904

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
   6:	681b      	ldr	r3, [r3, #0]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:893
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
   8:	4604      	mov	r4, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:904

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
   a:	4283      	cmp	r3, r0
   c:	f000 819a 	beq.w	344 <tcp_output+0x344>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:908
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  10:	f8b0 3052 	ldrh.w	r3, [r0, #82]	; 0x52
  14:	f8b0 705c 	ldrh.w	r7, [r0, #92]	; 0x5c
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:910

  seg = pcb->unsent;
  18:	6f45      	ldr	r5, [r0, #116]	; 0x74
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:908
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  1a:	429f      	cmp	r7, r3
  1c:	bf28      	it	cs
  1e:	461f      	movcs	r7, r3
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:918
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  20:	f890 3020 	ldrb.w	r3, [r0, #32]
  24:	f013 0f02 	tst.w	r3, #2
  28:	d019      	beq.n	5e <tcp_output+0x5e>
  2a:	b195      	cbz	r5, 52 <tcp_output+0x52>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:920
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  2c:	68eb      	ldr	r3, [r5, #12]
  2e:	7959      	ldrb	r1, [r3, #5]
  30:	791a      	ldrb	r2, [r3, #4]
  32:	79d8      	ldrb	r0, [r3, #7]
  34:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  38:	7999      	ldrb	r1, [r3, #6]
  3a:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  3e:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
  42:	f7ff fffe 	bl	0 <lwip_ntohl>
  46:	892a      	ldrh	r2, [r5, #8]
  48:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  4a:	1ad3      	subs	r3, r2, r3
  4c:	181b      	adds	r3, r3, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:919
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  4e:	42bb      	cmp	r3, r7
  50:	d905      	bls.n	5e <tcp_output+0x5e>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:921
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
  52:	4620      	mov	r0, r4
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1037
    pcb->persist_backoff = 1;
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
  54:	b003      	add	sp, #12
  56:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:921
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
  5a:	f7ff bffe 	b.w	0 <tcp_output>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:925
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  5e:	6fa6      	ldr	r6, [r4, #120]	; 0x78
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:926
  if (useg != NULL) {
  60:	b90e      	cbnz	r6, 66 <tcp_output+0x66>
  62:	e132      	b.n	2ca <tcp_output+0x2ca>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:927
    for (; useg->next != NULL; useg = useg->next);
  64:	461e      	mov	r6, r3
  66:	6833      	ldr	r3, [r6, #0]
  68:	2b00      	cmp	r3, #0
  6a:	d1fb      	bne.n	64 <tcp_output+0x64>
  6c:	e12d      	b.n	2ca <tcp_output+0x2ca>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:954
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  6e:	68eb      	ldr	r3, [r5, #12]
  70:	7b1a      	ldrb	r2, [r3, #12]
  72:	7b58      	ldrb	r0, [r3, #13]
  74:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  78:	f7ff fffe 	bl	0 <lwip_ntohs>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:963
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  7c:	6fa3      	ldr	r3, [r4, #120]	; 0x78
  7e:	b17b      	cbz	r3, a0 <tcp_output+0xa0>
  80:	f894 2020 	ldrb.w	r2, [r4, #32]
  84:	f012 0f44 	tst.w	r2, #68	; 0x44
  88:	d10a      	bne.n	a0 <tcp_output+0xa0>
  8a:	6f63      	ldr	r3, [r4, #116]	; 0x74
  8c:	2b00      	cmp	r3, #0
  8e:	f000 815d 	beq.w	34c <tcp_output+0x34c>
  92:	6819      	ldr	r1, [r3, #0]
  94:	b921      	cbnz	r1, a0 <tcp_output+0xa0>
  96:	8919      	ldrh	r1, [r3, #8]
  98:	8f23      	ldrh	r3, [r4, #56]	; 0x38
  9a:	4299      	cmp	r1, r3
  9c:	f0c0 8156 	bcc.w	34c <tcp_output+0x34c>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:976
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  a0:	682b      	ldr	r3, [r5, #0]
  a2:	6763      	str	r3, [r4, #116]	; 0x74
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:978

    if (pcb->state != SYN_SENT) {
  a4:	7c23      	ldrb	r3, [r4, #16]
  a6:	2b02      	cmp	r3, #2
  a8:	d01a      	beq.n	e0 <tcp_output+0xe0>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:979
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  aa:	f8d5 800c 	ldr.w	r8, [r5, #12]
  ae:	2010      	movs	r0, #16
  b0:	f898 300c 	ldrb.w	r3, [r8, #12]
  b4:	f898 900d 	ldrb.w	r9, [r8, #13]
  b8:	ea43 2909 	orr.w	r9, r3, r9, lsl #8
  bc:	f7ff fffe 	bl	0 <lwip_htons>
  c0:	ea40 0909 	orr.w	r9, r0, r9
  c4:	fa1f f989 	uxth.w	r9, r9
  c8:	f888 900c 	strb.w	r9, [r8, #12]
  cc:	ea4f 2919 	mov.w	r9, r9, lsr #8
  d0:	f888 900d 	strb.w	r9, [r8, #13]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:980
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  d4:	f894 3020 	ldrb.w	r3, [r4, #32]
  d8:	f023 0303 	bic.w	r3, r3, #3
  dc:	f884 3020 	strb.w	r3, [r4, #32]
tcp_output_segment():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1057
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  e0:	6a60      	ldr	r0, [r4, #36]	; 0x24
  e2:	f8d5 800c 	ldr.w	r8, [r5, #12]
  e6:	f7ff fffe 	bl	0 <lwip_htonl>
  ea:	0a03      	lsrs	r3, r0, #8
  ec:	f888 0008 	strb.w	r0, [r8, #8]
  f0:	f888 3009 	strb.w	r3, [r8, #9]
  f4:	0c03      	lsrs	r3, r0, #16
  f6:	0e00      	lsrs	r0, r0, #24
  f8:	f888 300a 	strb.w	r3, [r8, #10]
  fc:	f888 000b 	strb.w	r0, [r8, #11]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1060

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 100:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
 102:	f8d5 800c 	ldr.w	r8, [r5, #12]
 106:	f7ff fffe 	bl	0 <lwip_htons>
 10a:	f888 000e 	strb.w	r0, [r8, #14]
 10e:	0a00      	lsrs	r0, r0, #8
 110:	f888 000f 	strb.w	r0, [r8, #15]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1062

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 114:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 116:	6a63      	ldr	r3, [r4, #36]	; 0x24
 118:	18d3      	adds	r3, r2, r3
 11a:	62e3      	str	r3, [r4, #44]	; 0x2c
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1068

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
 11c:	7aaa      	ldrb	r2, [r5, #10]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1067
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 11e:	68eb      	ldr	r3, [r5, #12]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1068
  if (seg->flags & TF_SEG_OPTS_MSS) {
 120:	f012 0f01 	tst.w	r2, #1
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1069
    TCP_BUILD_MSS_OPTION(*opts);
 124:	bf1c      	itt	ne
 126:	4a4e      	ldrne	r2, [pc, #312]	; (260 <tcp_output+0x260>)
 128:	615a      	strne	r2, [r3, #20]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1083
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
 12a:	f9b4 3036 	ldrsh.w	r3, [r4, #54]	; 0x36
 12e:	f1b3 3fff 	cmp.w	r3, #4294967295
 132:	d101      	bne.n	138 <tcp_output+0x138>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1084
    pcb->rtime = 0;
 134:	2300      	movs	r3, #0
 136:	86e3      	strh	r3, [r4, #54]	; 0x36
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1089
  }

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
 138:	6823      	ldr	r3, [r4, #0]
 13a:	b933      	cbnz	r3, 14a <tcp_output+0x14a>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1090
    netif = ip_route(&(pcb->remote_ip));
 13c:	1d20      	adds	r0, r4, #4
 13e:	f7ff fffe 	bl	0 <ip_route>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1091
    if (netif == NULL) {
 142:	2800      	cmp	r0, #0
 144:	d02c      	beq.n	1a0 <tcp_output+0x1a0>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1094
      return;
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
 146:	6843      	ldr	r3, [r0, #4]
 148:	6023      	str	r3, [r4, #0]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1097
  }

  if (pcb->rttest == 0) {
 14a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 14c:	b983      	cbnz	r3, 170 <tcp_output+0x170>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1098
    pcb->rttest = tcp_ticks;
 14e:	4b45      	ldr	r3, [pc, #276]	; (264 <tcp_output+0x264>)
 150:	681b      	ldr	r3, [r3, #0]
 152:	63e3      	str	r3, [r4, #60]	; 0x3c
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1099
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 154:	68eb      	ldr	r3, [r5, #12]
 156:	7959      	ldrb	r1, [r3, #5]
 158:	791a      	ldrb	r2, [r3, #4]
 15a:	79d8      	ldrb	r0, [r3, #7]
 15c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 160:	7999      	ldrb	r1, [r3, #6]
 162:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 166:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
 16a:	f7ff fffe 	bl	0 <lwip_ntohl>
 16e:	6420      	str	r0, [r4, #64]	; 0x40
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1107
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 170:	6868      	ldr	r0, [r5, #4]
 172:	68eb      	ldr	r3, [r5, #12]
 174:	6842      	ldr	r2, [r0, #4]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1109

  seg->p->len -= len;
 176:	8941      	ldrh	r1, [r0, #10]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1107
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 178:	1a9a      	subs	r2, r3, r2
 17a:	b292      	uxth	r2, r2
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1109

  seg->p->len -= len;
 17c:	1a89      	subs	r1, r1, r2
 17e:	8141      	strh	r1, [r0, #10]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1110
  seg->p->tot_len -= len;
 180:	8901      	ldrh	r1, [r0, #8]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1112

  seg->p->payload = seg->tcphdr;
 182:	6043      	str	r3, [r0, #4]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1110
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);

  seg->p->len -= len;
  seg->p->tot_len -= len;
 184:	1a8a      	subs	r2, r1, r2
 186:	8102      	strh	r2, [r0, #8]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1114

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
 188:	2200      	movs	r2, #0
 18a:	741a      	strb	r2, [r3, #16]
 18c:	745a      	strb	r2, [r3, #17]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1161

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 18e:	7a62      	ldrb	r2, [r4, #9]
 190:	7aa3      	ldrb	r3, [r4, #10]
 192:	9200      	str	r2, [sp, #0]
 194:	2206      	movs	r2, #6
 196:	9201      	str	r2, [sp, #4]
 198:	4621      	mov	r1, r4
 19a:	1d22      	adds	r2, r4, #4
 19c:	f7ff fffe 	bl	0 <ip_output>
tcp_output():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:984
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 1a0:	68eb      	ldr	r3, [r5, #12]
 1a2:	7959      	ldrb	r1, [r3, #5]
 1a4:	791a      	ldrb	r2, [r3, #4]
 1a6:	79d8      	ldrb	r0, [r3, #7]
 1a8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 1ac:	7999      	ldrb	r1, [r3, #6]
 1ae:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 1b2:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
 1b6:	f7ff fffe 	bl	0 <lwip_ntohl>
 1ba:	68eb      	ldr	r3, [r5, #12]
 1bc:	4680      	mov	r8, r0
 1be:	7b1a      	ldrb	r2, [r3, #12]
 1c0:	7b58      	ldrb	r0, [r3, #13]
 1c2:	f8b5 9008 	ldrh.w	r9, [r5, #8]
 1c6:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 1ca:	f7ff fffe 	bl	0 <lwip_ntohs>
 1ce:	f000 0003 	and.w	r0, r0, #3
 1d2:	2800      	cmp	r0, #0
 1d4:	bf18      	it	ne
 1d6:	f109 0901 	addne.w	r9, r9, #1
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:985
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 1da:	6da2      	ldr	r2, [r4, #88]	; 0x58
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:984
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 1dc:	eb09 0308 	add.w	r3, r9, r8
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:985
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 1e0:	1ad2      	subs	r2, r2, r3
 1e2:	2a00      	cmp	r2, #0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:986
      pcb->snd_nxt = snd_nxt;
 1e4:	bfb8      	it	lt
 1e6:	65a3      	strlt	r3, [r4, #88]	; 0x58
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:989
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 1e8:	68eb      	ldr	r3, [r5, #12]
 1ea:	f8b5 8008 	ldrh.w	r8, [r5, #8]
 1ee:	7b1a      	ldrb	r2, [r3, #12]
 1f0:	7b58      	ldrb	r0, [r3, #13]
 1f2:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 1f6:	f7ff fffe 	bl	0 <lwip_ntohs>
 1fa:	f000 0003 	and.w	r0, r0, #3
 1fe:	2800      	cmp	r0, #0
 200:	bf0c      	ite	eq
 202:	4640      	moveq	r0, r8
 204:	f108 0001 	addne.w	r0, r8, #1
 208:	2800      	cmp	r0, #0
 20a:	d05a      	beq.n	2c2 <tcp_output+0x2c2>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:990
      seg->next = NULL;
 20c:	2300      	movs	r3, #0
 20e:	602b      	str	r3, [r5, #0]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:992
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 210:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 212:	b90b      	cbnz	r3, 218 <tcp_output+0x218>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:993
        pcb->unacked = seg;
 214:	67a5      	str	r5, [r4, #120]	; 0x78
 216:	e052      	b.n	2be <tcp_output+0x2be>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1000
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
 218:	68eb      	ldr	r3, [r5, #12]
 21a:	7959      	ldrb	r1, [r3, #5]
 21c:	791a      	ldrb	r2, [r3, #4]
 21e:	79d8      	ldrb	r0, [r3, #7]
 220:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 224:	7999      	ldrb	r1, [r3, #6]
 226:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 22a:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
 22e:	f7ff fffe 	bl	0 <lwip_ntohl>
 232:	68f3      	ldr	r3, [r6, #12]
 234:	4680      	mov	r8, r0
 236:	7959      	ldrb	r1, [r3, #5]
 238:	791a      	ldrb	r2, [r3, #4]
 23a:	79d8      	ldrb	r0, [r3, #7]
 23c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 240:	7999      	ldrb	r1, [r3, #6]
 242:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 246:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
 24a:	f7ff fffe 	bl	0 <lwip_ntohl>
 24e:	ebc0 0008 	rsb	r0, r0, r8
 252:	2800      	cmp	r0, #0
 254:	da32      	bge.n	2bc <tcp_output+0x2bc>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1002
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
 256:	f104 0878 	add.w	r8, r4, #120	; 0x78
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1003
          while (*cur_seg &&
 25a:	e007      	b.n	12 <tcp_input_pcb+0x12>
 25c:	00000000 	.word	0x00000000
 260:	b4050402 	.word	0xb4050402
 264:	00000000 	.word	0x00000000
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1005
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
 268:	f8d8 8000 	ldr.w	r8, [r8]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1003
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 26c:	f8d8 3000 	ldr.w	r3, [r8]
 270:	b1f3      	cbz	r3, 2b0 <tcp_output+0x2b0>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1004
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 272:	68db      	ldr	r3, [r3, #12]
 274:	7959      	ldrb	r1, [r3, #5]
 276:	791a      	ldrb	r2, [r3, #4]
 278:	79d8      	ldrb	r0, [r3, #7]
 27a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 27e:	7999      	ldrb	r1, [r3, #6]
 280:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 284:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
 288:	f7ff fffe 	bl	0 <lwip_ntohl>
 28c:	68eb      	ldr	r3, [r5, #12]
 28e:	4681      	mov	r9, r0
 290:	7959      	ldrb	r1, [r3, #5]
 292:	791a      	ldrb	r2, [r3, #4]
 294:	79d8      	ldrb	r0, [r3, #7]
 296:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 29a:	7999      	ldrb	r1, [r3, #6]
 29c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 2a0:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
 2a4:	f7ff fffe 	bl	0 <lwip_ntohl>
 2a8:	ebc0 0009 	rsb	r0, r0, r9
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1003
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 2ac:	2800      	cmp	r0, #0
 2ae:	dbdb      	blt.n	268 <tcp_output+0x268>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1007
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
 2b0:	f8d8 3000 	ldr.w	r3, [r8]
 2b4:	602b      	str	r3, [r5, #0]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1008
          (*cur_seg) = seg;
 2b6:	f8c8 5000 	str.w	r5, [r8]
 2ba:	e005      	b.n	2c8 <tcp_output+0x2c8>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1011
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
 2bc:	6035      	str	r5, [r6, #0]
 2be:	462e      	mov	r6, r5
 2c0:	e002      	b.n	2c8 <tcp_output+0x2c8>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1017
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
 2c2:	4628      	mov	r0, r5
 2c4:	f7ff fffe 	bl	0 <tcp_seg_free>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1019
    }
    seg = pcb->unsent;
 2c8:	6f65      	ldr	r5, [r4, #116]	; 0x74
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:952
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 2ca:	b19d      	cbz	r5, 2f4 <tcp_output+0x2f4>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:953
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 2cc:	68eb      	ldr	r3, [r5, #12]
 2ce:	7959      	ldrb	r1, [r3, #5]
 2d0:	791a      	ldrb	r2, [r3, #4]
 2d2:	79d8      	ldrb	r0, [r3, #7]
 2d4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 2d8:	7999      	ldrb	r1, [r3, #6]
 2da:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 2de:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
 2e2:	f7ff fffe 	bl	0 <lwip_ntohl>
 2e6:	892a      	ldrh	r2, [r5, #8]
 2e8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 2ea:	1ad3      	subs	r3, r2, r3
 2ec:	181b      	adds	r3, r3, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:952
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 2ee:	42bb      	cmp	r3, r7
 2f0:	f67f aebd 	bls.w	6e <tcp_output+0x6e>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1022
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
 2f4:	6f63      	ldr	r3, [r4, #116]	; 0x74
 2f6:	b90b      	cbnz	r3, 2fc <tcp_output+0x2fc>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1024
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 2f8:	f8a4 3072 	strh.w	r3, [r4, #114]	; 0x72
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1028
  }
#endif /* TCP_OVERSIZE */

  if (seg != NULL && pcb->persist_backoff == 0 && 
 2fc:	b1e5      	cbz	r5, 338 <tcp_output+0x338>
 2fe:	f894 609c 	ldrb.w	r6, [r4, #156]	; 0x9c
 302:	b9ce      	cbnz	r6, 338 <tcp_output+0x338>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1029
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
 304:	68eb      	ldr	r3, [r5, #12]
 306:	7959      	ldrb	r1, [r3, #5]
 308:	791a      	ldrb	r2, [r3, #4]
 30a:	79d8      	ldrb	r0, [r3, #7]
 30c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 310:	7999      	ldrb	r1, [r3, #6]
 312:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 316:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
 31a:	f7ff fffe 	bl	0 <lwip_ntohl>
 31e:	892a      	ldrh	r2, [r5, #8]
 320:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 322:	1ad3      	subs	r3, r2, r3
 324:	f8b4 205c 	ldrh.w	r2, [r4, #92]	; 0x5c
 328:	181b      	adds	r3, r3, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1028
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  if (seg != NULL && pcb->persist_backoff == 0 && 
 32a:	4293      	cmp	r3, r2
 32c:	d904      	bls.n	338 <tcp_output+0x338>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1032
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
    pcb->persist_backoff = 1;
 32e:	2301      	movs	r3, #1
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1031
#endif /* TCP_OVERSIZE */

  if (seg != NULL && pcb->persist_backoff == 0 && 
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
 330:	f8c4 6098 	str.w	r6, [r4, #152]	; 0x98
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1032
    pcb->persist_backoff = 1;
 334:	f884 309c 	strb.w	r3, [r4, #156]	; 0x9c
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1035
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
 338:	f894 3020 	ldrb.w	r3, [r4, #32]
 33c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 340:	f884 3020 	strb.w	r3, [r4, #32]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1037
  return ERR_OK;
}
 344:	2000      	movs	r0, #0
 346:	b003      	add	sp, #12
 348:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:963
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
 34c:	f012 0fa0 	tst.w	r2, #160	; 0xa0
 350:	f47f aea6 	bne.w	a0 <tcp_output+0xa0>
 354:	e7ce      	b.n	2f4 <tcp_output+0x2f4>
 356:	bf00      	nop

Disassembly of section .text.tcp_rst:

00000000 <tcp_rst>:
tcp_rst():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1190
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4606      	mov	r6, r0
   6:	460d      	mov	r5, r1
   8:	4692      	mov	sl, r2
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1193
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   a:	2001      	movs	r0, #1
   c:	2114      	movs	r1, #20
   e:	2200      	movs	r2, #0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1190
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  10:	461f      	mov	r7, r3
  12:	f8bd 9030 	ldrh.w	r9, [sp, #48]	; 0x30
  16:	f8bd 8034 	ldrh.w	r8, [sp, #52]	; 0x34
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1193
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  1a:	f7ff fffe 	bl	0 <pbuf_alloc>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1194
  if (p == NULL) {
  1e:	4604      	mov	r4, r0
  20:	2800      	cmp	r0, #0
  22:	d056      	beq.n	d2 <tcp_rst+0xd2>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1201
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  24:	f8d0 b004 	ldr.w	fp, [r0, #4]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1202
  tcphdr->src = htons(local_port);
  28:	4648      	mov	r0, r9
  2a:	f7ff fffe 	bl	0 <lwip_htons>
  2e:	f88b 0000 	strb.w	r0, [fp]
  32:	0a00      	lsrs	r0, r0, #8
  34:	f88b 0001 	strb.w	r0, [fp, #1]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1203
  tcphdr->dest = htons(remote_port);
  38:	4640      	mov	r0, r8
  3a:	f7ff fffe 	bl	0 <lwip_htons>
  3e:	f88b 0002 	strb.w	r0, [fp, #2]
  42:	0a00      	lsrs	r0, r0, #8
  44:	f88b 0003 	strb.w	r0, [fp, #3]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1204
  tcphdr->seqno = htonl(seqno);
  48:	4630      	mov	r0, r6
  4a:	f7ff fffe 	bl	0 <lwip_htonl>
  4e:	0a03      	lsrs	r3, r0, #8
  50:	f88b 0004 	strb.w	r0, [fp, #4]
  54:	f88b 3005 	strb.w	r3, [fp, #5]
  58:	0c03      	lsrs	r3, r0, #16
  5a:	0e00      	lsrs	r0, r0, #24
  5c:	f88b 3006 	strb.w	r3, [fp, #6]
  60:	f88b 0007 	strb.w	r0, [fp, #7]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1205
  tcphdr->ackno = htonl(ackno);
  64:	4628      	mov	r0, r5
  66:	f7ff fffe 	bl	0 <lwip_htonl>
  6a:	0a03      	lsrs	r3, r0, #8
  6c:	f88b 0008 	strb.w	r0, [fp, #8]
  70:	f88b 3009 	strb.w	r3, [fp, #9]
  74:	0c03      	lsrs	r3, r0, #16
  76:	0e00      	lsrs	r0, r0, #24
  78:	f88b 300a 	strb.w	r3, [fp, #10]
  7c:	f88b 000b 	strb.w	r0, [fp, #11]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1206
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
  80:	f245 0014 	movw	r0, #20500	; 0x5014
  84:	f7ff fffe 	bl	0 <lwip_htons>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1207
  tcphdr->wnd = PP_HTONS(TCP_WND);
  88:	230b      	movs	r3, #11
  8a:	f88b 300e 	strb.w	r3, [fp, #14]
  8e:	335d      	adds	r3, #93	; 0x5d
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1202
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  90:	f04f 0900 	mov.w	r9, #0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1206
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
  tcphdr->ackno = htonl(ackno);
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
  94:	f88b 000c 	strb.w	r0, [fp, #12]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1207
  tcphdr->wnd = PP_HTONS(TCP_WND);
  98:	f88b 300f 	strb.w	r3, [fp, #15]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1206
  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
  tcphdr->ackno = htonl(ackno);
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
  9c:	0a00      	lsrs	r0, r0, #8
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1218
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  9e:	3b62      	subs	r3, #98	; 0x62
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1206
  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
  tcphdr->ackno = htonl(ackno);
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
  a0:	f88b 000d 	strb.w	r0, [fp, #13]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1208
  tcphdr->wnd = PP_HTONS(TCP_WND);
  tcphdr->chksum = 0;
  a4:	f88b 9010 	strb.w	r9, [fp, #16]
  a8:	f88b 9011 	strb.w	r9, [fp, #17]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1209
  tcphdr->urgp = 0;
  ac:	f88b 9012 	strb.w	r9, [fp, #18]
  b0:	f88b 9013 	strb.w	r9, [fp, #19]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1218
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  b4:	4620      	mov	r0, r4
  b6:	9301      	str	r3, [sp, #4]
  b8:	4651      	mov	r1, sl
  ba:	463a      	mov	r2, r7
  bc:	33f9      	adds	r3, #249	; 0xf9
  be:	f8cd 9000 	str.w	r9, [sp]
  c2:	f7ff fffe 	bl	0 <ip_output>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1219
  pbuf_free(p);
  c6:	4620      	mov	r0, r4
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1221
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  c8:	b003      	add	sp, #12
  ca:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1219
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  ce:	f7ff bffe 	b.w	0 <pbuf_free>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1221
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  d2:	b003      	add	sp, #12
  d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text.tcp_rexmit_rto:

00000000 <tcp_rexmit_rto>:
tcp_rexmit_rto():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1235
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
   0:	6f82      	ldr	r2, [r0, #120]	; 0x78
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1232
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
   2:	b510      	push	{r4, lr}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1235
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
   4:	b19a      	cbz	r2, 2e <tcp_rexmit_rto+0x2e>
   6:	4611      	mov	r1, r2
   8:	e000      	b.n	c <tcp_rexmit_rto+0xc>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1240
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
   a:	4619      	mov	r1, r3
   c:	680b      	ldr	r3, [r1, #0]
   e:	2b00      	cmp	r3, #0
  10:	d1fb      	bne.n	a <tcp_rexmit_rto+0xa>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1242
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  12:	6f44      	ldr	r4, [r0, #116]	; 0x74
  14:	600c      	str	r4, [r1, #0]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1244
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  16:	6742      	str	r2, [r0, #116]	; 0x74
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1249
  /* unacked queue is now empty */
  pcb->unacked = NULL;

  /* increment number of retransmissions */
  ++pcb->nrtx;
  18:	f890 204a 	ldrb.w	r2, [r0, #74]	; 0x4a
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1246
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  1c:	6783      	str	r3, [r0, #120]	; 0x78
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1249

  /* increment number of retransmissions */
  ++pcb->nrtx;
  1e:	3201      	adds	r2, #1
  20:	f880 204a 	strb.w	r2, [r0, #74]	; 0x4a
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1252

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  24:	63c3      	str	r3, [r0, #60]	; 0x3c
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1256

  /* Do the actual retransmission */
  tcp_output(pcb);
}
  26:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1255

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
  2a:	f7ff bffe 	b.w	0 <tcp_rexmit_rto>
  2e:	bd10      	pop	{r4, pc}

Disassembly of section .text.tcp_rexmit:

00000000 <tcp_rexmit>:
tcp_rexmit():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1267
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1271
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
   2:	6f86      	ldr	r6, [r0, #120]	; 0x78
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1267
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
   4:	4604      	mov	r4, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1271
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
   6:	2e00      	cmp	r6, #0
   8:	d02f      	beq.n	6a <tcp_rexmit+0x6a>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1278
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
   a:	6833      	ldr	r3, [r6, #0]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1280

  cur_seg = &(pcb->unsent);
   c:	f100 0574 	add.w	r5, r0, #116	; 0x74
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1278
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
  10:	6783      	str	r3, [r0, #120]	; 0x78
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1281

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
  12:	e000      	b.n	16 <tcp_rexmit+0x16>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1283
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  14:	682d      	ldr	r5, [r5, #0]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1281
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
  16:	682b      	ldr	r3, [r5, #0]
  18:	b1eb      	cbz	r3, 56 <tcp_rexmit+0x56>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1282
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
  1a:	68db      	ldr	r3, [r3, #12]
  1c:	7959      	ldrb	r1, [r3, #5]
  1e:	791a      	ldrb	r2, [r3, #4]
  20:	79d8      	ldrb	r0, [r3, #7]
  22:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  26:	7999      	ldrb	r1, [r3, #6]
  28:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  2c:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
  30:	f7ff fffe 	bl	0 <lwip_ntohl>
  34:	68f3      	ldr	r3, [r6, #12]
  36:	4607      	mov	r7, r0
  38:	7959      	ldrb	r1, [r3, #5]
  3a:	791a      	ldrb	r2, [r3, #4]
  3c:	79d8      	ldrb	r0, [r3, #7]
  3e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  42:	7999      	ldrb	r1, [r3, #6]
  44:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  48:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
  4c:	f7ff fffe 	bl	0 <lwip_ntohl>
  50:	1a38      	subs	r0, r7, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1281
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
  52:	2800      	cmp	r0, #0
  54:	dbde      	blt.n	14 <tcp_rexmit+0x14>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1285
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
  56:	682b      	ldr	r3, [r5, #0]
  58:	6033      	str	r3, [r6, #0]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1286
  *cur_seg = seg;
  5a:	602e      	str	r6, [r5, #0]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1288

  ++pcb->nrtx;
  5c:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
  60:	3301      	adds	r3, #1
  62:	f884 304a 	strb.w	r3, [r4, #74]	; 0x4a
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1291

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  66:	2300      	movs	r3, #0
  68:	63e3      	str	r3, [r4, #60]	; 0x3c
  6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.tcp_rexmit_fast:

00000000 <tcp_rexmit_fast>:
tcp_rexmit_fast():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1308
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
   0:	6f83      	ldr	r3, [r0, #120]	; 0x78
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1307
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
   2:	b510      	push	{r4, lr}
   4:	4604      	mov	r4, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1308
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
   6:	b33b      	cbz	r3, 58 <tcp_rexmit_fast+0x58>
   8:	f890 3020 	ldrb.w	r3, [r0, #32]
   c:	f013 0f04 	tst.w	r3, #4
  10:	d122      	bne.n	48 <tcp_rexmit_fast+0x48>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1315
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
  12:	f7ff fffe 	bl	0 <tcp_rexmit_fast>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1319

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
  16:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
  1a:	f8b4 205c 	ldrh.w	r2, [r4, #92]	; 0x5c
  1e:	4293      	cmp	r3, r2
  20:	d903      	bls.n	2a <tcp_rexmit_fast+0x2a>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1320
      pcb->ssthresh = pcb->snd_wnd / 2;
  22:	0852      	lsrs	r2, r2, #1
  24:	f8a4 2054 	strh.w	r2, [r4, #84]	; 0x54
  28:	e002      	b.n	30 <tcp_rexmit_fast+0x30>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1322
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
  2a:	085b      	lsrs	r3, r3, #1
  2c:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1326
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
  30:	8f22      	ldrh	r2, [r4, #56]	; 0x38
  32:	f8b4 1054 	ldrh.w	r1, [r4, #84]	; 0x54
  36:	0053      	lsls	r3, r2, #1
  38:	4299      	cmp	r1, r3
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1331
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
  3a:	bfb8      	it	lt
  3c:	f8a4 3054 	strhlt.w	r3, [r4, #84]	; 0x54
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1334
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  40:	f8b4 1054 	ldrh.w	r1, [r4, #84]	; 0x54
  44:	189b      	adds	r3, r3, r2
  46:	185b      	adds	r3, r3, r1
  48:	f8a4 3052 	strh.w	r3, [r4, #82]	; 0x52
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1335
    pcb->flags |= TF_INFR;
  4c:	f894 3020 	ldrb.w	r3, [r4, #32]
  50:	f043 0304 	orr.w	r3, r3, #4
  54:	f884 3020 	strb.w	r3, [r4, #32]
  58:	bd10      	pop	{r4, pc}

Disassembly of section .text.tcp_keepalive:

00000000 <tcp_keepalive>:
tcp_keepalive():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1350
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
   0:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2:	4605      	mov	r5, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1361
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
   4:	6d80      	ldr	r0, [r0, #88]	; 0x58
   6:	3801      	subs	r0, #1
   8:	f7ff fffe 	bl	0 <lwip_htonl>
   c:	2100      	movs	r1, #0
   e:	4602      	mov	r2, r0
  10:	4628      	mov	r0, r5
  12:	f7ff fffe 	bl	0 <tcp_keepalive>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1362
  if(p == NULL) {
  16:	4604      	mov	r4, r0
  18:	b170      	cbz	r0, 38 <tcp_keepalive+0x38>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1380
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  1a:	2200      	movs	r2, #0
  1c:	9200      	str	r2, [sp, #0]
  1e:	3206      	adds	r2, #6
  20:	9201      	str	r2, [sp, #4]
  22:	7aab      	ldrb	r3, [r5, #10]
  24:	4629      	mov	r1, r5
  26:	1d2a      	adds	r2, r5, #4
  28:	f7ff fffe 	bl	0 <ip_output>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1383
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  2c:	4620      	mov	r0, r4
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1387

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  2e:	b003      	add	sp, #12
  30:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1383
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  34:	f7ff bffe 	b.w	0 <pbuf_free>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1387

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  38:	b003      	add	sp, #12
  3a:	bd30      	pop	{r4, r5, pc}

Disassembly of section .text.tcp_zero_window_probe:

00000000 <tcp_zero_window_probe>:
tcp_zero_window_probe():
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1400
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
   0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1418
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
   4:	6f86      	ldr	r6, [r0, #120]	; 0x78
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1400
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
   6:	4604      	mov	r4, r0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1420
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;

  if(seg == NULL) {
   8:	b916      	cbnz	r6, 10 <tcp_zero_window_probe+0x10>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1421
    seg = pcb->unsent;
   a:	6f46      	ldr	r6, [r0, #116]	; 0x74
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1423
  }
  if(seg == NULL) {
   c:	2e00      	cmp	r6, #0
   e:	d05e      	beq.n	ce <tcp_zero_window_probe+0xce>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1427
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
  10:	68f3      	ldr	r3, [r6, #12]
  12:	7b1a      	ldrb	r2, [r3, #12]
  14:	7b58      	ldrb	r0, [r3, #13]
  16:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  1a:	f7ff fffe 	bl	0 <lwip_ntohs>
  1e:	f010 0701 	ands.w	r7, r0, #1
  22:	d004      	beq.n	2e <tcp_zero_window_probe+0x2e>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1399
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
  24:	8937      	ldrh	r7, [r6, #8]
  26:	f1d7 0701 	rsbs	r7, r7, #1
  2a:	bf38      	it	cc
  2c:	2700      	movcc	r7, #0
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1431

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
  2e:	68f2      	ldr	r2, [r6, #12]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1427
  }
  if(seg == NULL) {
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
  30:	b2ff      	uxtb	r7, r7
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1431
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
  32:	7951      	ldrb	r1, [r2, #5]
  34:	7913      	ldrb	r3, [r2, #4]
  36:	4620      	mov	r0, r4
  38:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  3c:	7991      	ldrb	r1, [r2, #6]
  3e:	79d2      	ldrb	r2, [r2, #7]
  40:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  44:	ea43 6202 	orr.w	r2, r3, r2, lsl #24
  48:	f087 0101 	eor.w	r1, r7, #1
  4c:	f7ff fffe 	bl	0 <tcp_zero_window_probe>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1432
  if(p == NULL) {
  50:	4605      	mov	r5, r0
  52:	2800      	cmp	r0, #0
  54:	d03b      	beq.n	ce <tcp_zero_window_probe+0xce>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1436
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
  56:	f8d0 8004 	ldr.w	r8, [r0, #4]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1438

  if (is_fin) {
  5a:	b1af      	cbz	r7, 88 <tcp_zero_window_probe+0x88>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1440
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
  5c:	f898 300c 	ldrb.w	r3, [r8, #12]
  60:	f898 200d 	ldrb.w	r2, [r8, #13]
  64:	f24c 06ff 	movw	r6, #49407	; 0xc0ff
  68:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  6c:	2011      	movs	r0, #17
  6e:	ea03 0606 	and.w	r6, r3, r6
  72:	f7ff fffe 	bl	0 <lwip_htons>
  76:	ea40 0606 	orr.w	r6, r0, r6
  7a:	b2b6      	uxth	r6, r6
  7c:	f888 600c 	strb.w	r6, [r8, #12]
  80:	0a36      	lsrs	r6, r6, #8
  82:	f888 600d 	strb.w	r6, [r8, #13]
  86:	e012      	b.n	ae <tcp_zero_window_probe+0xae>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1443
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    struct tcp_hdr *thdr = (struct tcp_hdr *)seg->p->payload;
  88:	6877      	ldr	r7, [r6, #4]
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1445
    char *d = ((char *)p->payload + TCP_HLEN);
    pbuf_copy_partial(seg->p, d, 1, TCPH_HDRLEN(thdr) * 4);
  8a:	687b      	ldr	r3, [r7, #4]
  8c:	7b1a      	ldrb	r2, [r3, #12]
  8e:	7b58      	ldrb	r0, [r3, #13]
  90:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  94:	f7ff fffe 	bl	0 <lwip_ntohs>
  98:	f64f 73fc 	movw	r3, #65532	; 0xfffc
  9c:	0a86      	lsrs	r6, r0, #10
  9e:	f108 0114 	add.w	r1, r8, #20
  a2:	4638      	mov	r0, r7
  a4:	2201      	movs	r2, #1
  a6:	ea06 0303 	and.w	r3, r6, r3
  aa:	f7ff fffe 	bl	0 <pbuf_copy_partial>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1459
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  ae:	2200      	movs	r2, #0
  b0:	9200      	str	r2, [sp, #0]
  b2:	3206      	adds	r2, #6
  b4:	9201      	str	r2, [sp, #4]
  b6:	7aa3      	ldrb	r3, [r4, #10]
  b8:	4628      	mov	r0, r5
  ba:	4621      	mov	r1, r4
  bc:	1d22      	adds	r2, r4, #4
  be:	f7ff fffe 	bl	0 <ip_output>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1462
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  c2:	4628      	mov	r0, r5
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1467

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  c4:	b002      	add	sp, #8
  c6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1462
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  ca:	f7ff bffe 	b.w	0 <pbuf_free>
D:\sunny\stm32\therme\Utilities\lwip-1.3.1\src\core/tcp_out.c:1467

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  ce:	b002      	add	sp, #8
  d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
